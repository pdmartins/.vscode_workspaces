using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using Google.Cloud.Speech.V2;
using Microsoft.Extensions.Options;
using SttGcp.Api.Configuration;
using SttGcp.Api.Models;

namespace SttGcp.Api.Services;

/// <summary>
/// Streaming transcription via Chirp model (Speech-to-Text V2 with regional endpoint).
/// </summary>
public sealed class StreamingChirpService(
    [FromKeyedServices("chirp-client")] SpeechClient client,
    IOptions<GcpSettings> settings,
    ILogger<StreamingChirpService> logger) : IStreamingTranscriptionService
{
    private const int MaxChunkSize = 25_000;

    public string ProviderName => "Chirp";

    public async Task TranscribeStreamAsync(WebSocket webSocket, CancellationToken ct = default)
    {
        var cfg = settings.Value;
        var providerCfg = cfg.Providers.Chirp;
        var model = string.IsNullOrEmpty(providerCfg.Model) ? "chirp_2" : providerCfg.Model;
        var recognizer = $"projects/{cfg.ProjectId}/locations/{cfg.Region}/recognizers/_";

        var streamingCall = client.StreamingRecognize();

        // Send initial config (no audio)
        await streamingCall.WriteAsync(new StreamingRecognizeRequest
        {
            Recognizer = recognizer,
            StreamingConfig = new StreamingRecognitionConfig
            {
                Config = new RecognitionConfig
                {
                    AutoDecodingConfig = new AutoDetectDecodingConfig(),
                    LanguageCodes = { cfg.LanguageCode },
                    Model = model,
                    Features = new RecognitionFeatures
                    {
                        EnableAutomaticPunctuation = true
                    }
                },
                StreamingFeatures = new StreamingRecognitionFeatures
                {
                    InterimResults = true
                }
            }
        });

        logger.LogInformation("Chirp streaming session started with model {Model}", model);

        // Read responses from gRPC and forward to WebSocket
        var readTask = Task.Run(async () =>
        {
            var responseStream = streamingCall.GetResponseStream();
            while (await responseStream.MoveNextAsync(ct))
            {
                var response = responseStream.Current;
                foreach (var result in response.Results)
                {
                    var alt = result.Alternatives.FirstOrDefault();
                    if (alt is null) continue;

                    var streamResult = new StreamingTranscribeResult(
                        IsFinal: result.IsFinal,
                        Transcript: alt.Transcript,
                        Confidence: alt.Confidence,
                        Stability: result.Stability);

                    var json = JsonSerializer.Serialize(streamResult);
                    var bytes = Encoding.UTF8.GetBytes(json);

                    if (webSocket.State == WebSocketState.Open)
                    {
                        await webSocket.SendAsync(
                            new ArraySegment<byte>(bytes),
                            WebSocketMessageType.Text,
                            endOfMessage: true,
                            ct);
                    }
                }
            }
        }, ct);

        // Read audio chunks from WebSocket and forward to gRPC
        var buffer = new byte[MaxChunkSize];
        try
        {
            while (webSocket.State == WebSocketState.Open && !ct.IsCancellationRequested)
            {
                var received = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), ct);

                if (received.MessageType == WebSocketMessageType.Close)
                {
                    logger.LogInformation("Chirp streaming: client closed connection");
                    break;
                }

                if (received.Count > 0)
                {
                    await streamingCall.WriteAsync(new StreamingRecognizeRequest
                    {
                        Audio = Google.Protobuf.ByteString.CopyFrom(buffer, 0, received.Count)
                    });
                }
            }
        }
        finally
        {
            await streamingCall.WriteCompleteAsync();
            await readTask;

            if (webSocket.State == WebSocketState.Open)
            {
                await webSocket.CloseAsync(
                    WebSocketCloseStatus.NormalClosure,
                    "Transcription complete",
                    ct);
            }

            logger.LogInformation("Chirp streaming session ended");
        }
    }
}
