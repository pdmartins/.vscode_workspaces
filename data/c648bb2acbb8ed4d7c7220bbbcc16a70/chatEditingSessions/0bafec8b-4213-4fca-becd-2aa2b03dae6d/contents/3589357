# ‚ö†Ô∏è DEPRECATED ‚Äî Use `memory/index.md`

Este arquivo foi substitu√≠do pela estrutura folder-based:

- **Cat√°logo**: `memory/index.md`
- **Padr√µes**: `memory/patterns/*.md`
- **Decis√µes**: `memory/decisions/*.md`
- **Conceitos**: `memory/concepts/*.md`
- **Prefer√™ncias**: `memory/preferences/*.md`

> 24 li√ß√µes migradas em 2026-02-17 (XML ‚Üí bullet-list). Este arquivo ser√° removido em vers√£o futura.

<lesson date="2026-02-17" category="arquitetura">
  <context>O copilot-core n√£o tinha mecanismo para registrar atividades futuras, features planejadas, ideias ou TODOs persistentes. agent-task-manage √© ef√™mero (morre com a sess√£o), agent-chat-save salva estado da sess√£o mas n√£o √© backlog, agent-memory-register √© orientado ao passado (li√ß√µes). Havia um gap claro para planejamento futuro.</context>
  <decision>Criada skill project-backlog-manage no core (.copilot-core/skills/project/). Persiste itens em .copilot-project/backlog/backlog.md com formato estruturado (IDs sequenciais BKL-NNN, prioridades, categorias). Suporta opera√ß√µes: adicionar, listar, atualizar, concluir. Inclui auto-init para criar estrutura quando inexistente. Integra com agent-turn-reflect para consulta autom√°tica no in√≠cio de sess√µes.</decision>
  <outcome>Sistema agora cobre 4 orienta√ß√µes temporais: passado (memory-register), presente/sess√£o (task-manage, chat-save), futuro (backlog-manage). Project skills subiu de 10 para 11. Total do sistema: 63 skills.</outcome>
</lesson>

<lesson date="2026-02-16" category="arquitetura">
  <context>Auditoria profunda revelou: (1) 56-skill table triplicada em 3 always-loaded instruction files (~3,200 tokens desperdi√ßados por conversa), (2) symlinks com nomes gen√©ricos (default.instructions.md, workspace.instructions.md) causando potenciais conflitos com outros instruction files, (3) scripts de setup duplicados em 2 skills diferentes (project-workspace-create e project-setup-bootstrap) com ~130 linhas cada, (4) sem mecanismo de valida√ß√£o de impacto em cascata para edi√ß√µes multi-arquivo, (5) sem busca sem√¢ntica sobre mem√≥ria e contexto.</context>
  <decision>Reestrutura√ß√£o profunda em 5 fases: (1) Capability Manifest compacto (~10 linhas) substituiu tabelas de 56 skills nos 3 instruction files, com cat√°logos como Stage 2 de descoberta. (2) Symlinks renomeados para agent-skills-core.instructions.md e agent-skills-project.instructions.md. (3) Scripts extra√≠dos para templates/setup-scripts.md compartilhado. (4) Criadas 2 novas skills: agent-impact-validate (cascata) e agent-memory-sync (MCP sync). (5) MCP memory-service (doobidoo) configurado com SQLite-vec via Git LFS para busca sem√¢ntica h√≠brida BM25+vector.</decision>
  <outcome>Token efficiency ~50% nos instruction files always-loaded. System cresceu de 56 para 58 skills. Cadeia de finaliza√ß√£o expandida: task-manage ‚Üí action-review ‚Üí impact-validate (se 3+ arquivos) ‚Üí chat-save. Memory skills evolu√≠dos para dual-write (.md + MCP). Fonte de verdade permanece nos .md; MCP SQLite √© √≠ndice derivado reconstru√≠vel.</outcome>
</lesson>

<lesson date="2026-02-16" category="padr√µes">
  <context>O padr√£o de lazy loading de skills atrav√©s de cat√°logos funcionava bem, mas a tabela completa de 56 skills nos instruction files consumia tokens desnecess√°rios em TODA conversa, mesmo quando o agente n√£o precisava da lista completa.</context>
  <decision>Padr√£o "Capability Manifest": instruction files always-loaded cont√™m apenas uma tabela compacta com tipo, quantidade, nome do cat√°logo e exemplos de skills (~10 linhas). Para descoberta completa, o agente consulta {tipo}-catalog-query. Uma lista "Always-Known" de ~10 skills frequentes √© mantida inline para ativa√ß√£o direta sem cat√°logo.</decision>
  <outcome>Redu√ß√£o de ~158 linhas para ~15 linhas por instruction file. Cat√°logos passam a ser o mecanismo principal de descoberta. Padr√£o aplic√°vel a qualquer sistema com invent√°rio grande que precisa ser lazy-loaded.</outcome>
</lesson>

<lesson date="2026-02-16" category="regras">
  <context>Symlinks de instructions usavam nomes gen√©ricos default.instructions.md e workspace.instructions.md que poderiam conflitar com outros instruction files em projetos que j√° usam o mecanismo de instructions do VS Code.</context>
  <decision>Renomear para nomes n√£o-comuns com prefixo agent-skills-*: agent-skills-core.instructions.md (antes default) e agent-skills-project.instructions.md (antes workspace). Arquivos fonte nos repos tamb√©m renomeados para manter consist√™ncia. 2 symlinks mantidos (n√£o consolidar em 1) porque servem prop√≥sitos distintos: core √© gen√©rico cross-project, project √© espec√≠fico por branch.</decision>
  <outcome>Todos os arquivos, symlinks, templates e skills atualizados com novos nomes. Scripts de setup extra√≠dos para template compartilhado com nomes corretos. Risco de conflito eliminado.</outcome>
</lesson>

<lesson date="2026-02-16" category="tooling">
  <context>Sistema de mem√≥ria dependia exclusivamente de leitura sequencial de arquivos .md ‚Äî sem capacidade de busca sem√¢ntica. Busca por keywords exigia grep exato, ineficiente para consultas conceituais ("decis√µes sobre arquitetura").</context>
  <decision>Integrar mcp-memory-service (@doobidoo) com busca h√≠brida BM25+vector via SQLite-vec. Configura√ß√£o em .vscode/mcp.json, database em .copilot-project/memory/memory.db com Git LFS. Fonte de verdade permanece nos .md ‚Äî MCP SQLite √© √≠ndice derivado. Dual-write: agent-memory-register grava no .md primeiro, depois sincroniza com MCP. agent-memory-query prioriza MCP search com fallback para .md.</decision>
  <outcome>Skills evolu√≠dos: agent-memory-query v2.0, agent-memory-register v2.0, project-context-query v2.0. Nova skill agent-memory-sync para rebuild/incremental sync. Arquitetura de 3 camadas preservada: .md (fonte) ‚Üí MCP (√≠ndice) ‚Üí runtime (sess√£o).</outcome>
</lesson>

<lesson date="2026-02-16" category="arquitetura">
  <context>agent-action-review validava side-effects (codemap atualizado? mem√≥ria registrada?) mas n√£o verificava impacto em cascata de edi√ß√µes multi-arquivo (refer√™ncias quebradas, contagens desatualizadas, nomes inconsistentes ap√≥s renames).</context>
  <decision>Criar agent-impact-validate complementar ao action-review. Foco: grafo de impacto (arquivo_modificado ‚Üí referenciado_por), valida√ß√£o de paths p√≥s-rename (grep pelo nome antigo), consist√™ncia de contagens entre Manifests, integridade de symlinks, templates vs inst√¢ncias derivadas. Cadeia atualizada: task-manage ‚Üí action-review ‚Üí impact-validate (se 3+ arquivos) ‚Üí chat-save.</decision>
  <outcome>Valida√ß√£o em 2 camadas: completude (action-review) + consist√™ncia (impact-validate). Impact-validate √© delegable: full, ativado condicionalmente (3+ arquivos). Ambas skills coordenadas ‚Äî action-review chama impact-validate quando detecta edi√ß√µes multi-arquivo significativas.</outcome>
</lesson>

<lesson date="2026-02-16" category="estrutura">
  <context>Scripts de setup PowerShell e Bash apareciam inline em 2 skills (project-workspace-create ~130 linhas e project-setup-bootstrap ~150 linhas), triplicando esfor√ßo de manuten√ß√£o quando nomes de symlinks ou estrutura mudavam.</context>
  <decision>Extrair scripts para templates/setup-scripts.md centralizado. Skills referenciam o template com bloco de nota: "> üìã Scripts de setup completos: ver .copilot-core/templates/setup-scripts.md". Template usa vari√°veis {nome-projeto}, {repo-core}, {repo-project} e documenta ambos os modos (aberto/stealth) com scripts para ambas plataformas.</decision>
  <outcome>Single source of truth para scripts de setup. Atualiza√ß√£o de nomes/caminhos requer editar apenas 1 arquivo. Skills de setup ficaram significativamente menores e focados no workflow, n√£o nos scripts.</outcome>
</lesson>

<lesson date="2026-02-15" category="arquitetura">
  <context>O sistema de skills tinha mecanismos reativos de qualidade (agent-memory-register aprende ap√≥s o usu√°rio corrigir) mas nenhum mecanismo proativo (verificar antes do usu√°rio ver). N√£o havia: (1) verifica√ß√£o de side-effects obrigat√≥rios (codemap, mem√≥ria, contexto, contagens), (2) valida√ß√£o de estrutura de artefatos (SKILL.md, instructions, cat√°logos), (3) quality gate entre task-manage completar e sess√£o ser salva.</context>
  <decision>Criadas duas skills complementares: (1) agent-action-review ‚Äî valida completude e consist√™ncia cross-artefato das a√ß√µes do agente (codemap atualizado? mem√≥ria registrada? contagens sincronizadas?), disparada automaticamente ap√≥s agent-task-manage completar. (2) skill-output-validate ‚Äî valida estrutura e qualidade de artefatos de metadata (frontmatter schema, naming conventions, consist√™ncia entre instructions/cat√°logos, formato de memory/context/codemap). Cada uma no tipo correto: agent (comportamento) e skill (sistema de skills).</decision>
  <outcome>Cadeia de finaliza√ß√£o completa: agent-task-manage ‚Üí agent-action-review ‚Üí agent-chat-save. Sistema agora tem valida√ß√£o proativa. Core cresceu de 54 para 56 skills. agent-catalog-query indexa 7 skills. Ambas skills delegable: full ‚Äî podem ser executadas por subagents.</outcome>
</lesson>

<lesson date="2026-02-15" category="regras">
  <context>Havia d√∫vida se valida√ß√£o p√≥s-a√ß√£o deveria ser uma skill ou m√∫ltiplas, e em qual tipo classificar.</context>
  <decision>Duas skills com escopos distintos: agent-action-review (tipo agent, foco no comportamento ‚Äî "o agente fez tudo que deveria?") e skill-output-validate (tipo skill, foco nos artefatos ‚Äî "o que foi produzido est√° bem formado?"). A separa√ß√£o segue o princ√≠pio de responsabilidade √∫nica: uma valida a√ß√µes/side-effects, outra valida estrutura/qualidade.</decision>
  <outcome>Padr√£o: quando valida√ß√£o cobre escopos fundamentalmente diferentes (comportamento vs estrutura), separar em skills distintas em tipos distintos. agent-action-review delega para skill-output-validate quando precisa validar artefatos de metadata.</outcome>
</lesson>

<lesson date="2026-02-15" category="estrutura">
  <context>O sistema de skills tinha persist√™ncia de longo prazo (lessons-learned, project.md, code-map) via git, mas nenhuma camada de estado de sess√£o. Todo working context ‚Äî tarefas em andamento, decis√µes pendentes, racioc√≠nio, arquivos sendo modificados ‚Äî se perdia ao trocar de m√°quina ou encerrar o chat. O manage_todo_list √© runtime-only, sem persist√™ncia em disco.</context>
  <decision>Criada camada de persist√™ncia de sess√£o com: (1) pasta chat-memory/ no .copilot-project/ para arquivos de sess√£o nomeados YYYY-MM-DD_{topic}.md, (2) skill agent-chat-save para salvar estado manualmente ou auto ap√≥s agent-task-manage completar, (3) skill agent-chat-resume para retomar sess√£o anterior com briefing formatado. Naming das skills usa prefixo "chat" para alinhar com a pasta chat-memory/.</decision>
  <outcome>Contexto de trabalho agora sobrevive entre m√°quinas via git. Sess√µes s√£o sincronizadas automaticamente com push/pull do .copilot-project. Core cresceu de 51 para 53 skills. Cat√°logo agent atualizado de 3 para 5 skills.</outcome>
</lesson>

<lesson date="2026-02-15" category="regras">
  <context>Skills de persist√™ncia de sess√£o foram inicialmente nomeados agent-session-save e agent-session-resume.</context>
  <decision>Renomear para agent-chat-save e agent-chat-resume. O feature segment do nome da skill deve espelhar a pasta onde os dados s√£o armazenados (chat-memory/ ‚Üí chat-*). Isso mant√©m consist√™ncia sem√¢ntica entre nomenclatura de skills e estrutura de diret√≥rios.</decision>
  <outcome>Regra de naming: quando skill opera sobre uma pasta espec√≠fica, o feature segment deve alinhar com o nome da pasta. Exemplos: chat-memory/ ‚Üí agent-chat-*, memory/ ‚Üí agent-memory-*.</outcome>
</lesson>

<lesson date="2026-02-15" category="estrutura">
  <context>Existiam duas camadas temporais no sistema: permanente (lessons-learned, project.md, code-map) e ef√™mera (chat history, todo lists). N√£o havia camada intermedi√°ria para estado de sess√£o transiente mas persist√≠vel.</context>
  <decision>O chat-memory/ √© top-level no .copilot-project/ (n√£o dentro de memory/) porque √© conceitualmente distinto: sessions s√£o transientes com ciclo de vida pr√≥prio (in-progress ‚Üí paused ‚Üí completed), enquanto lessons-learned s√£o permanentes. Um arquivo por sess√£o (n√£o arquivo √∫nico) para hist√≥rico naveg√°vel e evitar conflitos de merge.</decision>
  <outcome>Tr√™s camadas temporais: permanente (memory/, context/), sess√£o (chat-memory/), ef√™mero (runtime). Cada camada com localiza√ß√£o, formato e ciclo de vida distintos.</outcome>
</lesson>

<lesson date="2026-02-10" category="estrutura">
  <context>Arquivos de instructions (.github/instructions/) eram copiados dos templates ‚Äî workspace.instructions.md era copiado de .copilot-core/templates/ para .github/instructions/. default.instructions.md ficava apenas dentro do submodule sem link.</context>
  <decision>Usar SEMPRE symlinks, nunca c√≥pias. default.instructions.md tem symlink para .copilot-core/instructions/. workspace.instructions.md √© armazenado em .copilot-project/instructions/ (espec√≠fico do projeto) com symlink para .github/instructions/. Windows: cmd /c mklink. Linux/Mac: ln -s. Paths relativos: ../../.copilot-core/instructions/ e ../../.copilot-project/instructions/.</decision>
  <outcome>Altera√ß√µes nos repos de origem refletem automaticamente no projeto consumidor. workspace.instructions.md passa a ser responsabilidade do .copilot-project (por branch). Atualizados: templates/workspace.instructions.md, .github/instructions/workspace.instructions.md, project-create, project-init, project-bootstrap, QUICK-START.md, context/project.md.</outcome>
</lesson>

<lesson date="2026-02-14" category="estrutura" supersedes="L002-self-dogfooding">
  <context>O .copilot-core usava um padr√£o excepcional de self-dogfooding: contexto e mem√≥ria ficavam em .copilot-core/.github/ (em vez de .copilot-project) e um junction link .github ‚Üí .copilot-core/.github/ na raiz do workspace permitia que o Copilot descobrisse os arquivos. Isso criava uma exce√ß√£o arquitetural que complicava a documenta√ß√£o e tornava o workspace de desenvolvimento diferente dos projetos consumidores.</context>
  <decision>Migrar para o padr√£o standard: criar branch _pm/copilot-core no .copilot-project com context/, memory/ e instructions/. Substituir o junction por symlinks individuais em .github/instructions/ (mesmo padr√£o que projetos consumidores). Eliminar completamente a pasta .copilot-core/.github/.</decision>
  <outcome>O workspace de desenvolvimento do core agora segue exatamente o mesmo padr√£o dos projetos consumidores. Eliminadas as se√ß√µes "Self-Dogfooding" e "Desambigua√ß√£o de Caminhos" do workspace.instructions.md. Removida a necessidade de explicar o padr√£o excepcional em documenta√ß√£o e skills.</outcome>
</lesson>

<lesson date="2026-02-15" category="estrutura" supersedes="L003-branch-core">
  <context>Existiam duas branches no .copilot-core: main (desenvolvimento completo) e core (distribui√ß√£o limpa). O workflow sync-core.yml em .copilot-core/.github/workflows/ sincronizava main ‚Üí core. Com a migra√ß√£o do self-dogfooding para .copilot-project, a branch core perdeu sua raz√£o de existir ‚Äî todo o conte√∫do de .copilot-core/main j√° √© distribu√≠vel.</context>
  <decision>Eliminar a branch core e o workflow sync-core.yml. Remover completamente a pasta .copilot-core/.github/. O .copilot-core passa a ter apenas a branch main como fonte de verdade e distribui√ß√£o. Projetos consumidores usam exclusivamente branch main.</decision>
  <outcome>Simplifica√ß√£o: sem branch core, sem workflow de sincroniza√ß√£o, sem pasta .github/ no .copilot-core. Atualizados: templates/workspace.instructions.md, .copilot-project instructions e context, skills project-repo-update e project-setup-bootstrap, default.instructions.md.</outcome>
</lesson>

<lesson date="2026-02-10" category="regras">
  <context>O agente s√≥ registrava automaticamente corre√ß√µes de c√≥digo gerado. Defini√ß√µes/corre√ß√µes de regras, estruturas e processos do pr√≥prio .copilot-core n√£o eram capturadas.</context>
  <decision>Ampliar o auto-registro para incluir corre√ß√µes de regras, estrutura e processos. Usar o sistema de mem√≥ria do .copilot-project para governar o desenvolvimento do core.</decision>
  <outcome>Adicionada se√ß√£o "Registro autom√°tico ‚Äî Corre√ß√µes de regras, estrutura e processos" no default.instructions.md. Toda defini√ß√£o ou corre√ß√£o do usu√°rio sobre como o sistema funciona agora √© registrada automaticamente.</outcome>
</lesson>

<lesson date="2026-02-10" category="estrutura">
  <context>Para projetos cujos repos n√£o podem ter refer√™ncia a submodules, a abordagem de junction (mklink /J) foi considerada mas rejeitada porque mudan√ßas de branch no source refletem no projeto consumidor.</context>
  <decision>Para projetos sem submodules, usar clones independentes na raiz do projeto. Estrutura: .copilot-core/ e .copilot-project/ na raiz, adicionados ao .gitignore junto com os symlinks de instructions. Cada dev roda um script de setup ap√≥s clonar o projeto.</decision>
  <outcome>Setup funciona sem tocar nos repos originais. Cada projeto tem seus pr√≥prios clones com branches independentes. Copilot descobre instructions em .github/instructions/ relativo ao workspace root. Modo stealth √© completamente invis√≠vel no reposit√≥rio remoto.</outcome>
</lesson>

<lesson date="2026-02-16" category="regras">
  <context>Em projetos existentes, se .vscode/mcp.json n√£o existia ou memory.db estava vazio, o agente s√≥ detectava o problema quando o usu√°rio pedia explicitamente para consultar mem√≥ria (via agent-memory-query). N√£o havia verifica√ß√£o proativa no in√≠cio da sess√£o.</context>
  <decision>Adicionar regra "MCP Auto-Setup" nas instru√ß√µes core (always-loaded): no in√≠cio de cada sess√£o em projeto existente, verificar presen√ßa de .vscode/mcp.json e estado de memory.db. Se ausente/vazio e .md tem conte√∫do ‚Üí auto-configurar MCP e executar agent-memory-sync full rebuild. Verifica√ß√£o silenciosa se tudo OK.</decision>
  <outcome>MCP agora √© auto-configurado proativamente. Tr√™s cen√°rios cobertos: (1) mcp.json ausente ‚Üí criar, (2) memory.db vazio com .md populado ‚Üí full rebuild, (3) ambos vazios ‚Üí nenhuma a√ß√£o. Output s√≥ aparece quando corrige algo.</outcome>
</lesson>

<lesson date="2026-02-16" category="regras">
  <context>Skills podiam ser criadas com qualquer complexidade ‚Äî sem limite pr√°tico de tamanho ou n√∫mero de steps. O limite anterior de 500 linhas era liberal demais para instru√ß√µes que precisam ser claras e eficientes para o agente GHCP.</context>
  <decision>Definir padr√£o de qualidade para skills: (1) m√°ximo ~150 linhas por SKILL.md, (2) m√°ximo 7 steps no workflow, (3) linguagem imperativa sem narrativa longa, (4) tabelas para l√≥gica condicional, (5) obrigat√≥rio sincronizar com context database (MCP) ap√≥s criar/alterar, (6) dividir em m√∫ltiplas skills quando tiver 2+ responsabilidades. Regras adicionadas ao core instructions, skill-template-create e skill-output-validate.</decision>
  <outcome>Skills devem ser compactas e focadas. Threshold de split reduzido de 500 para 150 linhas. Sync com context database agora √© step obrigat√≥rio no fluxo de cria√ß√£o. Valida√ß√£o atualizada para checar complexidade al√©m de estrutura.</outcome>
</lesson>

<lesson date="2026-02-16" category="regras">
  <context>O agente executava opera√ß√µes git (add, commit, push) livremente em qualquer projeto. Em alguns projetos o usu√°rio quer revisar altera√ß√µes via Source Control do VS Code antes de qualquer commit. Em outros, git liberado. N√£o havia mecanismo de controle por projeto.</context>
  <decision>Criada skill agent-git-guard (tipo agent, delegable: none) com config.yml por projeto. Toda opera√ß√£o git DEVE passar pela skill antes de executar. Config define permiss√µes por repo (path) e por opera√ß√£o (add, commit, push). Default sem config = tudo bloqueado (seguro). Regra obrigat√≥ria adicionada ao core instructions (always-loaded). Skill segue padr√£o Agent Skills: l√≥gica no core, dados no project config.</decision>
  <outcome>Controle granular de git por projeto. Default seguro (sem git). Extens√≠vel (pode adicionar commit_message_prefix, branch restrictions, etc). Subagents n√£o executam git (delegable: none). Sistema cresceu de 58 para 59 skills, agent type de 9 para 10.</outcome>
</lesson>

<lesson date="2026-02-16" category="arquitetura">
  <context>MCP memory-service usava SQLite-vec local como backend com database em .copilot-project/memory/memory.db versionado via Git LFS. Problema: multi-machine exigia sync manual do LFS, database bin√°rio n√£o escalava, cada m√°quina tinha √≠ndice isolado.</context>
  <decision>Migrar para Cloudflare Vectorize + D1 como backend do mcp-memory-service (doobidoo suporta nativamente desde v6.2.0). Backend cloud-only (n√£o h√≠brido). Configura√ß√£o via env vars: MCP_MEMORY_STORAGE_BACKEND=cloudflare, CLOUDFLARE_API_TOKEN, CLOUDFLARE_ACCOUNT_ID, CLOUDFLARE_VECTORIZE_INDEX=mcp-memory-index, CLOUDFLARE_D1_DATABASE_ID. Namespace por projeto = branch name do .copilot-project. Removido Git LFS completamente (.gitattributes deletado).</decision>
  <outcome>√çndice sem√¢ntico agora √© cloud ‚Äî acess√≠vel de qualquer m√°quina sem sync. Mesmas MCP tools (search_nodes, create_entities, etc) ‚Äî zero mudan√ßas no workflow de skills. Atualizados: mcp.json, agent-memory-sync, agent-memory-query, setup-scripts (4 variantes), project-setup-bootstrap, project-workspace-create, core instructions (MCP Auto-Setup), project.md.</outcome>
</lesson>

<lesson date="2026-02-10" category="padr√µes">
  <context>An√°lise profunda revelou inconsist√™ncias: workspace.instructions.md desatualizado vs template, categorias dos code-map skills divergentes entre frontmatter e tabelas, project-update com nota incorreta sobre branch main, URLs hardcoded nos skills de setup.</context>
  <decision>Documentar inconsist√™ncias no contexto do projeto para rastreamento e corre√ß√£o futura. Priorizar: (1) corrigir workspace.instructions.md, (2) alinhar categorias, (3) corrigir notas incorretas.</decision>
  <outcome>Inconsist√™ncias catalogadas em context/project.md se√ß√£o "Inconsist√™ncias Conhecidas". Algumas resolvidas na migra√ß√£o de 2026-02-14.</outcome>
</lesson>

<lesson date="2026-02-15" category="estrutura">
  <context>Skills em projetos espec√≠ficos (bw/bewiser.assistant.api, scripts) continham padr√µes gen√©ricos reutiliz√°veis misturados com dados espec√≠ficos do projeto. 21 skills de projeto eram na verdade padr√µes universais (.NET CQRS, DDD, testes, infra) com namespaces e exemplos hardcoded para BeWiser.</context>
  <decision>Migra√ß√£o massiva de skills: (1) 4 skills gen√©ricos movidos as-is de scripts/ para core (code-bash-write, code-powershell-write, code-crossplatform-sync, editor-readme-generate). (2) 13 skills refatorados de bw/api para core ‚Äî genericizados com {RootNamespace} placeholders + Config Loading + Config Schema sections; projeto mant√©m apenas config.yml. (3) 4 skills split ‚Äî padr√µes gen√©ricos para core, conte√∫do provider-specific (Twilio, MassTransit, Dapper, HTTP clients) como SKILL.md complementar no projeto. (4) 1 skill redundante eliminado (infra-docker-deploy). Core cresceu de 30 para 51 skills.</decision>
  <outcome>Core agora cont√©m todos os padr√µes gen√©ricos .NET/CQRS/DDD/testes/infra. Projetos estendem via config.yml (dados estruturados) + SKILL.md opcional (extens√µes provider-specific). Atualizados: ambos cat√°logos, default.instructions.md, workspace.instructions.md (template + project), READMEs de bw/api e scripts.</outcome>
</lesson>

<lesson date="2026-02-15" category="regras">
  <context>O .copilot-project no workspace de desenvolvimento do core estava com a branch main ativa (checkout direto) e as worktrees de projetos pessoais (scripts, docker-framework) usavam branches sem prefixo _pm/. Isso desalinhava do padr√£o de naming _pm/{projeto} usado para projetos pessoais e fazia com que a branch errada fosse ativa no workspace.</context>
  <decision>Regra obrigat√≥ria: (1) .copilot-project/ deve SEMPRE ter a branch _pm/copilot-core ativa (checkout direto) neste workspace. (2) main (template base) deve SEMPRE existir como worktree em .copilot-project-worktrees/main/, nunca como branch ativa. (3) Branches de projetos pessoais usam prefixo _pm/ (ex: _pm/scripts, _pm/docker-framework). Worktrees renomeadas para espelhar os nomes das branches.</decision>
  <outcome>Branch _pm/copilot-core ativada, main movida para worktree. Branches scripts e docker-framework renomeadas para _pm/scripts e _pm/docker-framework (local + remote). Worktrees realocadas para .copilot-project-worktrees/_pm/{projeto}/. Regra documentada em project.md e workspace.instructions.md.</outcome>
</lesson>

<lesson date="2026-02-17" category="padr√µes">
  <context>Agente criou script start-memory-dashboard.ps1 com path absoluto do Python hardcoded no credentials.yml (C:\Users\pedro.d.martins\...). Scripts e config em .copilot-core/ s√£o compartilhados entre m√°quinas diferentes.</context>
  <decision>NUNCA hardcodar paths absolutos de m√°quina em scripts, instru√ß√µes ou config compartilhado (.copilot-core/). Paths devem ser detectados em runtime via: (1) mcp.json do workspace (gerado por m√°quina), (2) PATH do sistema com fallbacks. O credentials.yml deve conter apenas credenciais e configs agn√≥sticos de m√°quina.</decision>
  <outcome>Removido path fixo do credentials.yml. Script .ps1 corrigido para detectar Python via mcp.json ‚Üí PATH (skip WindowsApps stubs). Script .sh usa python3/python do PATH. Regra registrada para futuras gera√ß√µes.</outcome>
</lesson>

<lesson date="2026-02-17" category="tooling">
  <context>Sistema LLM-as-Judge criado para avaliar skills em 3 dimens√µes: routing (skill certa para o prompt?), quality (c√≥digo gerado segue padr√µes?) e hallucination (agente inventa coisas que n√£o existem?). Precisa de scripts e workflows documentados para execu√ß√£o futura.</context>
  <decision>
    **Estrutura:**
    - Branch isolada: `_test/llm-judge` com worktree em `.copilot-project-worktrees/_test/llm-judge/`
    - Cen√°rios YAML: `scenarios/{routing|quality|hallucination}/NNN-slug.yaml` (112 cen√°rios, 62 routing + 30 quality + 20 hallucination)
    - Skill core: `code-skill-evaluate` (orquestra avalia√ß√£o, delegable: orchestrated)
    - Config do projeto: `skills/code-skill-evaluate/config.yml` (thresholds, pesos, score interpretation)

    **Scripts em `.copilot-core/.internal/scripts/`:**
    1. `generate-scenarios.py` ‚Äî Gera cen√°rios faltantes para skills sem cobertura
       - `python scripts/generate-scenarios.py --report` ‚Üí relat√≥rio de cobertura
       - `python scripts/generate-scenarios.py --dry-run` ‚Üí preview sem criar arquivos
       - `python scripts/generate-scenarios.py` ‚Üí gerar todos os faltantes
       - `python scripts/generate-scenarios.py --type routing` ‚Üí apenas um tipo
    2. `run-evaluation.ps1` ‚Äî Runner de avalia√ß√£o (3 modos)
       - `.\scripts\run-evaluation.ps1 -List` ‚Üí listar cen√°rios dispon√≠veis
       - `.\scripts\run-evaluation.ps1 -Validate` ‚Üí rodar pytest nos cen√°rios
       - `.\scripts\run-evaluation.ps1 -Type routing -Skill code-entity-generate` ‚Üí gerar prompt de avalia√ß√£o ‚Üí clipboard
    3. `run-evaluation.sh` ‚Äî Vers√£o bash do runner

    **Valida√ß√£o pytest:**
    - `pytest tests/behavioral/test_evaluation_scenarios.py -q` ‚Üí valida schema YAML de todos os cen√°rios
    - Marker: `@pytest.mark.evaluation`
    - Todos os scripts rodam com venv: `.copilot-core/.internal/.venv/`

    **Workflow de uso:**
    1. Usu√°rio pede "avalia a skill X" ‚Üí agente ativa `code-skill-evaluate`
    2. Skill carrega cen√°rios YAML da worktree `_test/llm-judge/scenarios/`
    3. Para cada cen√°rio: gera prompt ‚Üí envia ao GHCP ‚Üí analisa resposta vs rubric
    4. Resultado: score 0-5 por crit√©rio, m√©dia ponderada, pass/fail por threshold
  </decision>
  <outcome>112 cen√°rios cobrindo 100% das 62 skills em routing, 30 em quality, 20 em hallucination. Suite completa: 2590 passed, 0 failed. Gerador reutiliz√°vel para skills futuras. Execu√ß√£o sob demanda ‚Äî basta pedir "roda avalia√ß√£o" ou "gera cen√°rios".</outcome>
</lesson>
