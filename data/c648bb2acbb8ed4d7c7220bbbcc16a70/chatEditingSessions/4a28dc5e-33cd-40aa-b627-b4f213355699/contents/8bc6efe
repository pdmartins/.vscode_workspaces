---
applyTo: '**'
---

# Copilot Agent Instructions

Regras globais para o agente. Skills sÃ£o carregados automaticamente conforme necessidade.

## PrincÃ­pios

1. **InstruÃ§Ãµes sÃ£o obrigatÃ³rias** - nÃ£o sÃ£o sugestÃµes
2. **Perguntar antes de assumir** - quando houver ambiguidade, perguntar
3. **PortuguÃªs para chat, inglÃªs para cÃ³digo** - variÃ¡veis, funÃ§Ãµes, nomes de arquivo em inglÃªs

## ClarificaÃ§Ã£o

**Perguntar quando:**
- Pedido Ã© vago ou ambÃ­guo
- MÃºltiplas interpretaÃ§Ãµes possÃ­veis
- InformaÃ§Ã£o crÃ­tica faltando
- DecisÃ£o impacta significativamente o resultado

**NÃƒO perguntar quando:**
- InformaÃ§Ã£o estÃ¡ explÃ­cita
- ConvenÃ§Ã£o estÃ¡ documentada
- DecisÃ£o Ã© trivial
- Contexto torna resposta Ã³bvia

**Formato**: â“ **Preciso de clarificaÃ§Ã£o**: {pergunta}

## Skills

Este projeto usa o padrÃ£o [Agent Skills](https://agentskills.io).

### SinalizaÃ§Ã£o de Uso

**Sempre que uma skill for ativada**, o agente DEVE sinalizar no inÃ­cio da resposta:

```
ğŸ”§ Skill: `{nome-da-skill}`
```

Se mÃºltiplas skills forem ativadas na mesma resposta:

```
ğŸ”§ Skills: `{skill-1}`, `{skill-2}`
```

Isso garante rastreabilidade e transparÃªncia sobre quais skills estÃ£o sendo utilizadas.

### Descoberta de Skills

O agente DEVE escanear os seguintes diretÃ³rios para descobrir skills disponÃ­veis:

1. **Core Skills**: `.copilot-core/skills/` (organizados em subpastas por tipo: `agent/`, `code/`, `editor/`, `infra/`, `project/`, `skill/`)
2. **Project Skills**: `.copilot-project/skills/`

Para cada skill encontrado (recursivamente), ler o frontmatter (`name` e `description`) do `SKILL.md`.
Usar o campo `description` para decidir quando ativar cada skill.

> **CatÃ¡logo unificado**: O agente trabalha com um catÃ¡logo Ãºnico que combina core skills + project skills. Project skills complementam o core â€” podem adicionar funcionalidade especÃ­fica do projeto (ex: `editor-english-sync` em projetos que precisam de sync de README). Quando houver skill com mesmo nome em ambos, o project skill prevalece.

### Dados do Projeto

O agente DEVE consultar quando relevante:

- **Contexto**: `.copilot-project/context/index.md` â†’ subpastas sob demanda
- **MemÃ³ria**: `.copilot-project/memory/index.md` â†’ subpastas sob demanda
- **Chat Memory**: `.copilot-project/chat-memory/`
- **Mapa de CÃ³digo**: `.copilot-project/context/code-map/`

**Nomenclatura**: `{tipo}/{tipo}-{feature}-{aÃ§Ã£o}/SKILL.md`

### Skills Core

O sistema possui **62 skills** organizados em 6 tipos. A descoberta usa catÃ¡logos por tipo.

#### Capability Manifest

| Tipo | Capacidades | Descoberta | Skills |
|------|------------|------------|--------|
| `agent` | MemÃ³ria, delegaÃ§Ã£o, tarefas, sessÃµes, validaÃ§Ã£o, git guard, reflexÃ£o per-turn, guia interativo | `agent-catalog-query` | 12 |
| `code` | Review, geraÃ§Ã£o .NET, CQRS/DDD, testes, bash/powershell, avaliaÃ§Ã£o | `code-catalog-query` | 23 |
| `infra` | Docker, K8s, Redis, GCP, pipelines, JWT, mensageria | `infra-catalog-query` | 12 |
| `project` | Contexto, codemap, setup, branches, anÃ¡lise, backlog | `project-catalog-query` | 11 |
| `skill` | Criar e validar skills | (direto) | 2 |
| `editor` | Markdown lint, READMEs | (direto) | 2 |

#### Skills Always-Known (ativaÃ§Ã£o direta, sem catÃ¡logo)

| Skill | PropÃ³sito |
|-------|-----------|
| `agent-memory-query` | Consultar memÃ³ria do agente (index-first, deep-load on-demand) |
| `agent-memory-update` | Criar/atualizar entradas de memÃ³ria (preferences, patterns, decisions, concepts) |
| `agent-action-review` | Validar completude e consistÃªncia pÃ³s-aÃ§Ã£o |
| `agent-impact-validate` | Validar impactos em cascade pÃ³s-ediÃ§Ã£o |
| `agent-git-guard` | Verificar permissÃµes git antes de executar (add/commit/push) |
| `project-context-query` | Consultar contexto do projeto (index-first, deep-load on-demand) |
| `skill-template-create` | Criar novos skills |
| `skill-output-validate` | Validar estrutura e qualidade de artefatos |
| `editor-markdown-lint` | Regras de formataÃ§Ã£o Markdown |
| `editor-readme-generate` | CriaÃ§Ã£o e atualizaÃ§Ã£o de READMEs |
| `agent-turn-reflect` | ReflexÃ£o automÃ¡tica per-turn (contexto, memÃ³rias, chat-memory) |
| `agent-guide-stepbystep` | Guiar usuÃ¡rio passo a passo interativamente |

### Descoberta Otimizada

Para evitar carregar frontmatter de 50+ skills a cada sessÃ£o:

1. **Identificar tipo** â€” pela tarefa do usuÃ¡rio, determinar o tipo (`agent`, `code`, `infra`, `project`)
2. **Consultar catÃ¡logo core** â€” usar `runSubagent` para ler o `{tipo}-catalog-query` e listar skills do tipo
3. **Consultar project skills** â€” verificar se `.copilot-project/skills/` contÃ©m skills adicionais do tipo relevante
4. **Ativar skill especÃ­fica** â€” carregar apenas o SKILL.md necessÃ¡rio (core ou project)

**Exemplo de fluxo com subagent:**
```
Tarefa: "criar Dockerfile para o projeto"
â†’ Tipo: infra
â†’ Subagent lÃª: infra-catalog-query + project skills infra-*
â†’ Resultado: usar infra-docker-build (+ config.yml do project se existir)
â†’ Agente carrega: infra-docker-build/SKILL.md
```

Para skills de uso direto (`skill-template-create`, `editor-markdown-lint`) â€” ativar sem catÃ¡logo.

### DelegaÃ§Ã£o a Subagents

Skills podem ser delegadas a subagents via `runSubagent`. Consultar `agent-subagent-delegate` para regras completas e classificaÃ§Ã£o de cada skill.

Cada skill tem `delegable` no frontmatter: `full` (autÃ´nomo), `orchestrated` (main coleta inputs), `none` (main agent only).

#### Template de Prompt

Usar `.copilot-core/.internal/templates/subagent-prompt.md` para montar prompts padronizados.

## Agent vs Plan Mode

| Modo | Quando usar |
|------|------------|
| **Agent** | Tarefas claras e diretas â€” registrar liÃ§Ã£o, criar skill, configurar projeto jÃ¡ plugado |
| **Plan** | Tarefas complexas que precisam de revisÃ£o â€” `project-workspace-create`, refatoraÃ§Ãµes grandes, anÃ¡lises de arquitetura |

> **`project-workspace-create` deve ser usado com Plan mode** â€” envolve coleta de contexto profundo, decisÃ£o de quais skills criar e revisÃ£o antes de executar.

## Tarefas Complexas

**Usar `manage_todo_list` quando:**
- Tarefa tem 4+ steps distintos
- UsuÃ¡rio pede mÃºltiplas coisas
- Envolve mÃºltiplos arquivos
- Requer planejamento

**Workflow:**
1. Criar lista com todos os steps
2. Marcar um como `in-progress`
3. Executar e marcar `completed` imediatamente
4. PrÃ³ximo step â†’ `in-progress`

## Passo a Passo Guiado

Quando o usuÃ¡rio pedir um **passo a passo**, **tutorial**, **guia** ou **walkthrough**, usar `agent-guide-stepbystep`:

1. **VisÃ£o macro** â€” Apresentar overview numerado do processo completo (1-2 linhas por passo)
2. **Um passo por vez** â€” Detalhar apenas o passo atual com explicaÃ§Ã£o completa
3. **Aguardar feedback** â€” NUNCA avanÃ§ar sem confirmaÃ§Ã£o do usuÃ¡rio
4. **Adaptar** â€” Resolver dÃºvidas/erros antes de avanÃ§ar

**DiferenÃ§a de `agent-task-manage`**: task-manage Ã© para o agente **executar** tarefas. guide-stepbystep Ã© para o agente **guiar o usuÃ¡rio** atravÃ©s de um processo.

## MemÃ³ria e Contexto

### Arquitetura

O sistema separa **Contexto** (informaÃ§Ã£o sobre o projeto) de **MemÃ³ria** (aprendizados do agente):

```
.copilot-project/
â”œâ”€â”€ context/                    # Sobre o PROJETO
â”‚   â”œâ”€â”€ index.md                # CatÃ¡logo â€” ler primeiro
â”‚   â”œâ”€â”€ architecture/           # DecisÃµes arquiteturais, estrutura, padrÃµes
â”‚   â”œâ”€â”€ business-rules/         # Regras de domÃ­nio, restriÃ§Ãµes de negÃ³cio
â”‚   â”œâ”€â”€ code-map/               # InventÃ¡rio de artefatos e mÃ³dulos
â”‚   â”œâ”€â”€ conventions/            # Nomenclatura, estilo, processos
â”‚   â”œâ”€â”€ infrastructure/         # Stack, ferramentas, integraÃ§Ãµes, deploy
â”‚   â””â”€â”€ team-process/           # SDLC, normas da equipe (opt-in)
â”‚
â”œâ”€â”€ memory/                     # Sobre o AGENTE
â”‚   â”œâ”€â”€ index.md                # CatÃ¡logo â€” ler primeiro
â”‚   â”œâ”€â”€ preferences/            # PreferÃªncias do usuÃ¡rio sobre estilo/abordagens
â”‚   â”œâ”€â”€ patterns/               # PadrÃµes descobertos/aprendidos/corrigidos
â”‚   â”œâ”€â”€ decisions/              # DecisÃµes com rationale
â”‚   â””â”€â”€ concepts/               # Conhecimentos e definiÃ§Ãµes relevantes
â”‚
â””â”€â”€ chat-memory/                # SessÃµes de chat persistidas
```

### Modelo de Consulta â€” Index-First

1. **Ler o index.md** do tipo relevante (`context/index.md` ou `memory/index.md`)
2. **Decidir se precisa deep-load** â€” o index tem resumos suficientes para decisÃµes rÃ¡pidas
3. **Carregar arquivo especÃ­fico** da subpasta apenas quando necessÃ¡rio

### Roteamento â€” Quando o usuÃ¡rio pede para guardar informaÃ§Ã£o

Quando o usuÃ¡rio disser "guarda", "salva", "anota", "lembra", "registra", "memoriza":

| Tipo de InformaÃ§Ã£o | Skill | Destino |
|-------------------|-------|---------|
| Stack, ferramentas, integraÃ§Ãµes, deploy | `project-context-update` | `context/infrastructure/` |
| DecisÃ£o arquitetural, estrutura do sistema | `project-context-update` | `context/architecture/` |
| Regra de negÃ³cio, restriÃ§Ã£o, requisito | `project-context-update` | `context/business-rules/` |
| ConvenÃ§Ã£o de cÃ³digo, naming, processo | `project-context-update` | `context/conventions/` |
| InventÃ¡rio de artefatos | `project-codemap-update` | `context/code-map/` |
| PreferÃªncia de estilo/abordagem do usuÃ¡rio | `agent-memory-update` | `memory/preferences/` |
| PadrÃ£o descoberto ou corrigido | `agent-memory-update` | `memory/patterns/` |
| DecisÃ£o tÃ©cnica com rationale | `agent-memory-update` | `memory/decisions/` |
| Conhecimento/conceito relevante | `agent-memory-update` | `memory/concepts/` |

**Se ambÃ­guo** â†’ perguntar ao usuÃ¡rio: "Isso Ã© informaÃ§Ã£o do projeto (contexto) ou um aprendizado do agente (memÃ³ria)?"

### Registro automÃ¡tico â€” CorreÃ§Ãµes de cÃ³digo gerado

Quando o usuÃ¡rio pedir para **corrigir ou alterar cÃ³digo que o agente gerou**, o agente DEVE:

1. **Aplicar a correÃ§Ã£o** normalmente
2. **Executar `agent-memory-update`** (workflow completo: gravar arquivo â†’ atualizar index â†’ confirmar) em `memory/patterns/`:
   - O que o agente gerou incorretamente
   - O que o usuÃ¡rio corrigiu e qual Ã© o padrÃ£o correto

> **NUNCA** emitir confirmaÃ§Ã£o sem ter gravado o arquivo. O output vem do workflow do `agent-memory-update`, nÃ£o Ã© uma mensagem avulsa de chat.

**Detectar quando:**
- UsuÃ¡rio diz "nÃ£o Ã© assim", "muda isso", "corrige isso", "prefiro assim", "faz diferente"
- UsuÃ¡rio altera padrÃ£o de nomenclatura, estilo, estrutura ou abordagem
- UsuÃ¡rio aponta erro no cÃ³digo gerado pelo agente

**NÃƒO registrar quando:**
- CorreÃ§Ã£o Ã© por mudanÃ§a de requisito (usuÃ¡rio mudou de ideia, nÃ£o corrigiu padrÃ£o)
- Erro factual pontual (typo, variÃ¡vel errada) sem padrÃ£o recorrente

### Registro automÃ¡tico â€” CorreÃ§Ãµes de regras, estrutura e processos

Quando o usuÃ¡rio **definir, corrigir ou alterar regras, estruturas ou processos** do sistema:

1. **Aplicar a mudanÃ§a** nos arquivos relevantes
2. **Executar `agent-memory-update`** (workflow completo) em `memory/decisions/`

**Detectar quando:**
- UsuÃ¡rio define como algo deve funcionar
- UsuÃ¡rio corrige uma decisÃ£o do agente sobre estrutura/processo
- UsuÃ¡rio aponta que uma instruÃ§Ã£o/skill estÃ¡ incorreta

### Consulta automÃ¡tica

**Antes de tarefas complexas:**
- Ler `memory/index.md` para decisÃµes e padrÃµes relevantes
- Ler `context/index.md` para stack e restriÃ§Ãµes

**Antes de gerar cÃ³digo:**
- Consultar `context/code-map/` para evitar duplicaÃ§Ã£o
- Consultar `memory/patterns/` para aplicar preferÃªncias do usuÃ¡rio

**ApÃ³s criar/alterar cÃ³digo:**
- Registrar com `project-codemap-update`

**ApÃ³s decisÃµes importantes:**
- Registrar com `agent-memory-update`

### SessÃ£o e Continuidade

| SituaÃ§Ã£o | Skill | Destino |
|----------|-------|---------|
| Salvar sessÃ£o / trocar de mÃ¡quina | `agent-chat-save` | `chat-memory/{date}_{topic}.md` |
| Retomar sessÃ£o anterior | `agent-chat-resume` | LÃª de `chat-memory/` |
| task-manage completa todas as tarefas (4+ steps) | `agent-action-review` â†’ `agent-chat-save` (auto) | validaÃ§Ã£o + `chat-memory/` |

### ReflexÃ£o Per-Turn

Ao final de **CADA turno**, executar `agent-turn-reflect` (triage rÃ¡pido adaptativo):

| Pergunta | Se "sim" â†’ fase |
|----------|------------------|
| Houve decisÃ£o arquitetural, tÃ©cnica ou de processo? | Fase 3 â€” MemÃ³ria (`agent-memory-update`) |
| Houve mudanÃ§a de stack, restriÃ§Ã£o, integraÃ§Ã£o ou estado? | Fase 1 â€” Contexto (`project-context-update`) |
| Houve gap, erro ou melhoria identificada em skill? | Fase 2 â€” Skills (pergunta ao usuÃ¡rio) |
| Houve progresso reportÃ¡vel (arquivos, tarefas)? | Fase 4 â€” Chat Memory |

**Se TODAS "nÃ£o"** â†’ skip silencioso.

## OperaÃ§Ãµes Git

**OBRIGATÃ“RIO**: Antes de executar qualquer `git add`, `git commit` ou `git push`, o agente DEVE consultar `agent-git-guard` para verificar permissÃµes do projeto. Sem config = sem git (o usuÃ¡rio revisa via Source Control do VS Code).

## Regras de CÃ³digo

- **Linguagem do chat**: PortuguÃªs brasileiro
- **Linguagem do cÃ³digo**: InglÃªs (variÃ¡veis, funÃ§Ãµes, parÃ¢metros, nomes de arquivo)
- **Nunca criar documentaÃ§Ã£o automÃ¡tica** - apenas quando solicitado

## Qualidade de Skills

Toda skill criada ou alterada DEVE seguir estas regras:

| Regra | DescriÃ§Ã£o |
|-------|----------|
| **PadrÃ£o Agent Skills** | Frontmatter completo, naming 3-segmentos, seÃ§Ãµes obrigatÃ³rias |
| **Simplicidade** | Workflow direto, sem instruÃ§Ãµes excessivas. Se SKILL.md > 150 linhas â†’ considerar split |
| **Clareza** | Linguagem imperativa, steps numerados, tabelas para decisÃ£o. O agente GHCP deve entender sem ambiguidade |
| **DivisÃ£o** | Skill com 2+ responsabilidades distintas â†’ dividir em skills separadas |

