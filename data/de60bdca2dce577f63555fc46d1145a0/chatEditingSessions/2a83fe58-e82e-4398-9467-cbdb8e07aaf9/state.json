{"version":2,"initialFileContents":[["file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","24474c6"],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Domain/Entities/Product.cs","dba9171"],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Domain/Services/Interfaces/IProductMatchingService.cs","aaa59d7"],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Domain/Services/Implementations/ProductMatchingService.cs","cc79014"],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Abstractions/IOpenAiIntentClassifyService.cs","fa5536c"],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","3af1688"],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Mappings/IntentClassificationMappingExtensions.cs","0f27f07"],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","641559c"],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs","d0dc289"],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","8d83af5"],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Settings/AzureOpenAiSettings.cs","3e9894d"],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/appsettings.json","ecba7bb"],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/appsettings.Development.json","47f4bcb"]],"timeline":{"checkpoints":[{"checkpointId":"098edfd7-f44c-4c65-b0a9-fce4c11a59ce","epoch":0,"label":"Initial State","description":"Starting point before any edits"},{"checkpointId":"352f801f-f31e-4ccb-9998-26074c111e07","requestId":"request_ae32375e-6848-4961-bee0-5b7eecb7bdd3","epoch":1,"label":"Request request_ae32375e-6848-4961-bee0-5b7eecb7bdd3"},{"checkpointId":"e4a22b23-ec57-4017-9b53-11c5258c2a17","requestId":"request_ae32375e-6848-4961-bee0-5b7eecb7bdd3","undoStopId":"baf464c5-886f-46a3-9bab-868599247d0b","epoch":2,"label":"Request request_ae32375e-6848-4961-bee0-5b7eecb7bdd3 - Stop baf464c5-886f-46a3-9bab-868599247d0b"},{"checkpointId":"d3de3034-3ab4-4030-8bcb-1dd48c5b9be0","requestId":"request_ae32375e-6848-4961-bee0-5b7eecb7bdd3","undoStopId":"50fe9622-f0f1-4a99-b31c-63b4774a72bd","epoch":5,"label":"Request request_ae32375e-6848-4961-bee0-5b7eecb7bdd3 - Stop 50fe9622-f0f1-4a99-b31c-63b4774a72bd"},{"checkpointId":"fd2beab0-f16a-4464-86e9-ad33045bc92b","requestId":"request_ae32375e-6848-4961-bee0-5b7eecb7bdd3","undoStopId":"0f2c57c8-4b6a-4b3e-b823-f16fa9ed141d","epoch":7,"label":"Request request_ae32375e-6848-4961-bee0-5b7eecb7bdd3 - Stop 0f2c57c8-4b6a-4b3e-b823-f16fa9ed141d"},{"checkpointId":"fe31e8d6-1507-4d47-8e7c-6dca9f02dd8c","requestId":"request_ae32375e-6848-4961-bee0-5b7eecb7bdd3","undoStopId":"4b190512-fbc2-42e5-adca-391b3d517ae2","epoch":9,"label":"Request request_ae32375e-6848-4961-bee0-5b7eecb7bdd3 - Stop 4b190512-fbc2-42e5-adca-391b3d517ae2"},{"checkpointId":"2eeafe32-81fb-4e45-9896-d871286a79d5","requestId":"request_ae32375e-6848-4961-bee0-5b7eecb7bdd3","undoStopId":"be5594f8-6197-419f-97b4-f6bc25d90cff","epoch":11,"label":"Request request_ae32375e-6848-4961-bee0-5b7eecb7bdd3 - Stop be5594f8-6197-419f-97b4-f6bc25d90cff"},{"checkpointId":"72de8da5-9b9d-4d4c-9275-6af2a551d279","requestId":"request_ccc081c3-59fd-4348-adcc-5549a47f8c7e","epoch":13,"label":"Request request_ccc081c3-59fd-4348-adcc-5549a47f8c7e"},{"checkpointId":"e000e80f-f51c-4260-814b-488e8b2b999a","requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","epoch":14,"label":"Request request_49043e35-303e-4ac3-91d7-e0f94ee08aba"},{"checkpointId":"f75c228f-2e5a-4937-be5c-76027c6f8c78","requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","undoStopId":"9ebb222d-adfd-4e3c-9424-65f6bf73554e","epoch":15,"label":"Request request_49043e35-303e-4ac3-91d7-e0f94ee08aba - Stop 9ebb222d-adfd-4e3c-9424-65f6bf73554e"},{"checkpointId":"bb4a3ab1-850b-4cd4-9a11-43a6e92749e1","requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","undoStopId":"cce8a16b-2dd2-4430-af25-37b842966c4d","epoch":16,"label":"Request request_49043e35-303e-4ac3-91d7-e0f94ee08aba - Stop cce8a16b-2dd2-4430-af25-37b842966c4d"},{"checkpointId":"98cfb960-2089-4f91-8148-cb770464461e","requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","undoStopId":"9f2d3c67-2f20-4728-b4a5-751d951e01ee","epoch":17,"label":"Request request_49043e35-303e-4ac3-91d7-e0f94ee08aba - Stop 9f2d3c67-2f20-4728-b4a5-751d951e01ee"},{"checkpointId":"818e1b91-a61c-4a9b-a488-b6be60d1828f","requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","undoStopId":"d101dcb6-3ab2-4a62-941a-7cd0fb6953a9","epoch":24,"label":"Request request_49043e35-303e-4ac3-91d7-e0f94ee08aba - Stop d101dcb6-3ab2-4a62-941a-7cd0fb6953a9"},{"checkpointId":"e15423b0-d989-4f16-a6b6-11045daf4cbd","requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","undoStopId":"98b0e4a2-6d5f-4a1c-9881-3cf46ea8e8e8","epoch":25,"label":"Request request_49043e35-303e-4ac3-91d7-e0f94ee08aba - Stop 98b0e4a2-6d5f-4a1c-9881-3cf46ea8e8e8"},{"checkpointId":"a7cc70db-2165-4d4b-8e19-152fb3d41b2e","requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","undoStopId":"dd6d0200-46fc-4569-898e-94e1d1ad3963","epoch":30,"label":"Request request_49043e35-303e-4ac3-91d7-e0f94ee08aba - Stop dd6d0200-46fc-4569-898e-94e1d1ad3963"},{"checkpointId":"2b67b20d-fada-4310-87a0-f1af1bff6c82","requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","undoStopId":"d408b51a-c5b1-469d-95f2-393fe1c3aba9","epoch":34,"label":"Request request_49043e35-303e-4ac3-91d7-e0f94ee08aba - Stop d408b51a-c5b1-469d-95f2-393fe1c3aba9"},{"checkpointId":"2952e52a-157b-46ea-9da4-bd89a9be2b39","requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","undoStopId":"bb58b6a2-1b8a-42ea-8b96-5d50a80ce0c5","epoch":37,"label":"Request request_49043e35-303e-4ac3-91d7-e0f94ee08aba - Stop bb58b6a2-1b8a-42ea-8b96-5d50a80ce0c5"},{"checkpointId":"040d44c0-b5c6-4b21-a9ba-32dabe54de60","requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","undoStopId":"b2f6f79f-fc84-477d-9f45-461975c55253","epoch":39,"label":"Request request_49043e35-303e-4ac3-91d7-e0f94ee08aba - Stop b2f6f79f-fc84-477d-9f45-461975c55253"},{"checkpointId":"623e5b7a-c761-42f4-9dcd-39d8d3f11a1f","requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","undoStopId":"8b969b36-5a55-4ed2-b7e0-44d3597d3186","epoch":41,"label":"Request request_49043e35-303e-4ac3-91d7-e0f94ee08aba - Stop 8b969b36-5a55-4ed2-b7e0-44d3597d3186"},{"checkpointId":"74da032a-efde-4d8c-a721-17eb602568d2","requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","undoStopId":"659b63ab-cd80-48c5-9360-52b3a8a84788","epoch":43,"label":"Request request_49043e35-303e-4ac3-91d7-e0f94ee08aba - Stop 659b63ab-cd80-48c5-9360-52b3a8a84788"},{"checkpointId":"e972e797-4b55-4fcf-8f72-55dfe459aa67","requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","undoStopId":"b78c0f6f-5cc8-4dd7-b7f3-54574585f65a","epoch":45,"label":"Request request_49043e35-303e-4ac3-91d7-e0f94ee08aba - Stop b78c0f6f-5cc8-4dd7-b7f3-54574585f65a"},{"checkpointId":"7863424d-fc3a-47bd-aafe-117b362f7729","requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","epoch":54,"label":"Request request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9"},{"checkpointId":"46dafeb7-3c32-4644-9ab7-6f923a8e4e56","requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","undoStopId":"ed5773de-c211-4f2c-ab3f-3a8214798e62","epoch":55,"label":"Request request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9 - Stop ed5773de-c211-4f2c-ab3f-3a8214798e62"},{"checkpointId":"9e7fe143-6f26-4e5d-b0f5-8c65a6a9c5ca","requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","undoStopId":"c646bfc0-1e02-41e9-94f2-0a88990e16f7","epoch":56,"label":"Request request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9 - Stop c646bfc0-1e02-41e9-94f2-0a88990e16f7"},{"checkpointId":"db9feb6d-5c27-4c76-96eb-c328b3854b3b","requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","undoStopId":"7071a0b2-5812-4aea-8dac-e8a4b71fb953","epoch":57,"label":"Request request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9 - Stop 7071a0b2-5812-4aea-8dac-e8a4b71fb953"},{"checkpointId":"65212dce-a342-452b-97cd-c27a26b7e805","requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","undoStopId":"60721cf7-d047-443d-90cb-dfae8c6bedc8","epoch":66,"label":"Request request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9 - Stop 60721cf7-d047-443d-90cb-dfae8c6bedc8"},{"checkpointId":"bed5c25d-a2fc-4899-924d-0111e41ff5af","requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","epoch":75,"label":"Request request_7940bb37-9bec-489b-9854-972e458844d6"},{"checkpointId":"b1c45946-b22b-4359-a8d8-5178eb2e8d19","requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","undoStopId":"e38dcc44-39ca-4c2e-b81c-c9f7d43ba0e0","epoch":76,"label":"Request request_7940bb37-9bec-489b-9854-972e458844d6 - Stop e38dcc44-39ca-4c2e-b81c-c9f7d43ba0e0"},{"checkpointId":"fa0f7110-f58a-44df-87ee-ad6aae27c6aa","requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","undoStopId":"5481034d-366e-4c34-bc69-ee07c4e698a8","epoch":77,"label":"Request request_7940bb37-9bec-489b-9854-972e458844d6 - Stop 5481034d-366e-4c34-bc69-ee07c4e698a8"},{"checkpointId":"467c772f-760a-4c74-83ef-96b3be3bbae7","requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","undoStopId":"782947c8-bc8a-4dc7-9955-8fe9adbc2a41","epoch":78,"label":"Request request_7940bb37-9bec-489b-9854-972e458844d6 - Stop 782947c8-bc8a-4dc7-9955-8fe9adbc2a41"},{"checkpointId":"a0f7b583-982f-4eb2-8d9a-d46f71469e55","requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","undoStopId":"39a2f885-1526-427e-9979-97d4eb303834","epoch":79,"label":"Request request_7940bb37-9bec-489b-9854-972e458844d6 - Stop 39a2f885-1526-427e-9979-97d4eb303834"},{"checkpointId":"6cb22d4a-e7bd-4a5c-9f82-3b34f7dd46eb","requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","undoStopId":"fd600212-46ba-48f1-816d-0e503b55be69","epoch":80,"label":"Request request_7940bb37-9bec-489b-9854-972e458844d6 - Stop fd600212-46ba-48f1-816d-0e503b55be69"},{"checkpointId":"e2d14f34-f47e-4c31-9676-fe0d33c7b530","requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","undoStopId":"07ae00c5-88b7-42ac-a1b4-b310c00bf840","epoch":95,"label":"Request request_7940bb37-9bec-489b-9854-972e458844d6 - Stop 07ae00c5-88b7-42ac-a1b4-b310c00bf840"},{"checkpointId":"0ad70c34-88a9-4b31-9c69-6c24908aaa4a","requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":100,"label":"Request request_c461a1a3-4de4-4857-825f-ce170dca8e15"},{"checkpointId":"4d882089-500c-4823-b88d-087c2e8866ff","requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","undoStopId":"6e648831-fe9f-4ff6-97a7-c8217f880eba","epoch":101,"label":"Request request_c461a1a3-4de4-4857-825f-ce170dca8e15 - Stop 6e648831-fe9f-4ff6-97a7-c8217f880eba"},{"checkpointId":"a3f47ea3-3aca-4803-9e42-96f32fea9035","requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","undoStopId":"a2a584d2-06c4-457b-b260-415daef444a6","epoch":102,"label":"Request request_c461a1a3-4de4-4857-825f-ce170dca8e15 - Stop a2a584d2-06c4-457b-b260-415daef444a6"},{"checkpointId":"27331343-bf04-4e9e-970f-b4f4de43550d","requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","undoStopId":"45a67ce1-86bc-4dcb-b6bb-d232a5c87715","epoch":103,"label":"Request request_c461a1a3-4de4-4857-825f-ce170dca8e15 - Stop 45a67ce1-86bc-4dcb-b6bb-d232a5c87715"},{"checkpointId":"43d86ba9-ed10-4c54-a3b1-a605e95c56a1","requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","undoStopId":"5178ac45-5568-4a1c-884d-bd4e4fa18a15","epoch":104,"label":"Request request_c461a1a3-4de4-4857-825f-ce170dca8e15 - Stop 5178ac45-5568-4a1c-884d-bd4e4fa18a15"},{"checkpointId":"747c66fe-bb05-4e33-a542-8b094a098cf7","requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","undoStopId":"55da70c8-719a-4c94-9efd-7ca5e57dd1c0","epoch":105,"label":"Request request_c461a1a3-4de4-4857-825f-ce170dca8e15 - Stop 55da70c8-719a-4c94-9efd-7ca5e57dd1c0"},{"checkpointId":"c68fa7d1-5787-443f-8ebc-0e1221d153e2","requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","undoStopId":"dbae0d20-a8ef-4588-afdd-931d8a854064","epoch":106,"label":"Request request_c461a1a3-4de4-4857-825f-ce170dca8e15 - Stop dbae0d20-a8ef-4588-afdd-931d8a854064"},{"checkpointId":"4fccd78c-601c-4a64-9590-5462a2184953","requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","undoStopId":"d07b10dc-8667-49eb-b394-64f5230396d5","epoch":128,"label":"Request request_c461a1a3-4de4-4857-825f-ce170dca8e15 - Stop d07b10dc-8667-49eb-b394-64f5230396d5"},{"checkpointId":"d3554f88-e469-4cd8-8c30-68b3a8b702d4","requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","undoStopId":"5ddb7f4d-f6c7-4b74-9c16-36cdec92469f","epoch":130,"label":"Request request_c461a1a3-4de4-4857-825f-ce170dca8e15 - Stop 5ddb7f4d-f6c7-4b74-9c16-36cdec92469f"},{"checkpointId":"c2a035ae-d947-4fae-ba9a-5dc0191b939e","requestId":"request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539","epoch":133,"label":"Request request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539"},{"checkpointId":"f7d7f17e-32b1-4ff9-ba47-83102c56ddf7","requestId":"request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539","undoStopId":"8072a77f-759b-45a2-a8f0-b6785cf36599","epoch":134,"label":"Request request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539 - Stop 8072a77f-759b-45a2-a8f0-b6785cf36599"},{"checkpointId":"991da1b0-0923-4402-bd1d-b9112bdfabcf","requestId":"request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539","undoStopId":"024abe13-dbb2-49bc-9a15-7b4e21bdacd2","epoch":135,"label":"Request request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539 - Stop 024abe13-dbb2-49bc-9a15-7b4e21bdacd2"},{"checkpointId":"35437fd8-11bd-4fc1-8c56-76c7b1eed1b2","requestId":"request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539","undoStopId":"ceb4069b-7101-4c2c-b1fb-f7574ca1df35","epoch":136,"label":"Request request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539 - Stop ceb4069b-7101-4c2c-b1fb-f7574ca1df35"}],"currentEpoch":144,"fileBaselines":[["file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs::request_ae32375e-6848-4961-bee0-5b7eecb7bdd3",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_ae32375e-6848-4961-bee0-5b7eecb7bdd3","content":"namespace Sky.HubAI.Infrastructure.OpenAI.Prompts\r\n{\r\n    public static class TextClassificationPrompt\r\n    {\r\n        public static string GetSystemPrompt() =>\r\n            @\"Você é um especialista em classificação de ações e produtos a partir de descrições textuais. Possui habilidade em interpretar textos com erros de grafia, identificar intenções implícitas e extrair informações estruturadas com precisão.\r\n\r\n# Task\r\n\r\nAnalisar descrições fornecidas em texto livre e classificar:\r\n(1) a ação a ser tomada para CADA produto mencionado (adição ou remoção);\r\n(2) Identificar o código de TODOS os produtos mencionados.\r\n\r\n# Context\r\n\r\nEste sistema processa solicitações de clientes que podem conter imprecisões ortográficas, palavras escritas em conjunto ou formatação irregular. A classificação precisa alimenta fluxos de trabalho operacionais, tornando a precisão crítica para o roteamento correto de tarefas e gestão de produtos.\r\n\r\n# Instructions\r\n\r\n## 1. Identificação de Produtos\r\n\r\nAnalise a descrição e identifique TODOS os produtos mencionados.\r\n\r\n**IMPORTANTE - Produtos podem estar listados de várias formas:**\r\n- Separados por `+` : \"\"PROMO SUPER 30D + DEG HBO 30D\"\"\r\n- Separados por `,` : \"\"HBO Max, Telecine, Premiere\"\"\r\n- Separados por `e`/`ou` : \"\"HBO e Telecine\"\"\r\n- Em texto corrido: \"\"incluir recarga PROMO SUPER 30D e também DEG HBO\"\"\r\n- Com valores/preços junto: \"\"PROMO SUPER 30D - R$ 89,91\"\"\r\n\r\n**Ao encontrar múltiplos produtos, busque CADA UM separadamente usando `search_products`.**\r\n\r\nExemplo: Para \"\"PROMO SUPER 30D + DEG HBO 30D\"\", faça buscas separadas:\r\n- search_products([\"\"PROMO SUPER 30D\"\", \"\"PROMO SUPER\"\"])\r\n- search_products([\"\"DEG HBO 30D\"\", \"\"DEG HBO\"\", \"\"HBO 30D\"\", \"\"DEGUSTAÇÃO HBO\"\"])\r\n\r\n## 2. Tratamento de Abreviações e Erros\r\n\r\n**Abreviações comuns que você deve expandir ao buscar:**\r\n- DEG = DEGUSTAÇÃO\r\n- PROMO = PROMOÇÃO ou PROMOCIONAL\r\n- 30D, 7D, 15D = 30 dias, 7 dias, 15 dias (período)\r\n- DEB/DEG = pode ser erro de digitação\r\n\r\n**Ao buscar, inclua variações:**\r\n- Termo original + termo expandido\r\n- Termos parciais do nome do produto\r\n- Combinações com e sem períodos (30D, 7D)\r\n\r\n## 3. Determinação da Ação\r\n\r\nPara CADA produto identificado, determine a ação correspondente:\r\n- `product-add`: inclusão, incluir, adicionar, ativar, ativação, liberação, reativação, pedido, destino, recarga\r\n- `product-remove`: cancelar, cancelamento, excluir, exclusão, retirada, origem, correção, duplicidade, remover\r\n- `none`: quando não for possível determinar a ação\r\n\r\n**Indicadores de ação no contexto:**\r\n- \"\"por favor incluir\"\" → product-add\r\n- \"\"ativar recarga\"\" → product-add\r\n- \"\"valor ficou liberado\"\" + \"\"incluir\"\" → product-add\r\n- \"\"cancelar\"\" → product-remove\r\n- \"\"retirar da grade\"\" → product-remove\r\n\r\n## 4. Tratamento de Valores e Preços\r\n\r\n**IGNORE valores monetários ao identificar produtos:**\r\n- \"\"R$ 89,91\"\", \"\"R  89,91\"\", \"\"89,91\"\" → não fazem parte do nome do produto\r\n- \"\"valor disponível: 129,80\"\" → contexto informativo, não é produto\r\n\r\n## 5. Múltiplos Produtos com Mesma Ação\r\n\r\nUm mesmo texto pode conter MÚLTIPLOS produtos com a MESMA ação:\r\nExemplo: \"\"incluir a recarga: PROMO SUPER 30D + DEG HBO 30D\"\" → 2 produtos, ambos com action=\"\"product-add\"\"\r\n\r\n## 6. Formato de Resposta\r\n\r\nApós identificar todos os produtos e ações, retorne um objeto JSON:\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código1\"\", \"\"productName\"\": \"\"Nome do Produto 1\"\", \"\"action\"\": \"\"product-add\"\" },\r\n    { \"\"productCode\"\": \"\"código2\"\", \"\"productName\"\": \"\"Nome do Produto 2\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ],\r\n  \"\"keywords\"\": [\"\"incluir\"\", \"\"recarga\"\"],\r\n  \"\"log\"\": \"\"Explicação do raciocínio usado\"\"\r\n}\r\n```\r\n\r\n## 7. Regras Importantes\r\n\r\n- O output final deve ser APENAS o JSON sem texto adicional.\r\n- Use múltiplas chamadas a `search_products` para encontrar cada produto.\r\n- Jamais invente códigos de produtos. Use apenas os retornados pela função search_products.\r\n- keywords deve conter as palavras-chave de ação encontradas no texto.\r\n- **Se não conseguir determinar a ação, use action=\"\"none\"\".**\r\n- **Se o produto não for encontrado pelo search_products, inclua-o com productCode vazio e action=\"\"none\"\".**\r\n\r\n## 8. Retorno com Ação ou Produto Não Identificado\r\n\r\nQuando não for possível identificar a ação OU o produto, retorne action=\"\"none\"\":\r\n\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"\"\", \"\"productName\"\": \"\"Nome mencionado no texto\"\", \"\"action\"\": \"\"none\"\" }\r\n  ],\r\n  \"\"keywords\"\": [],\r\n  \"\"log\"\": \"\"Produto não encontrado no catálogo\"\" \r\n}\r\n```\r\n\r\n## 9. Se Nenhum Produto For Mencionado no Texto\r\n\r\nSe o texto não mencionar nenhum produto, retorne:\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [],\r\n  \"\"keywords\"\": [],\r\n  \"\"log\"\": \"\"Nenhum produto mencionado no texto\"\"\r\n}\r\n```\";\r\n    }\r\n}","epoch":3,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Domain/Entities/Product.cs::request_49043e35-303e-4ac3-91d7-e0f94ee08aba",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Domain\\Entities\\Product.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Domain/Entities/Product.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Domain/Entities/Product.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","content":"namespace Sky.HubAI.Domain.Entities\r\n{\r\n    public class Product(\r\n        string code,\r\n        string name)\r\n    {\r\n        public string Code { get; private set; } = code;\r\n        public string Name { get; private set; } = name;\r\n    }\r\n}","epoch":18,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Domain/Services/Interfaces/IProductMatchingService.cs::request_49043e35-303e-4ac3-91d7-e0f94ee08aba",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Domain\\Services\\Interfaces\\IProductMatchingService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Domain/Services/Interfaces/IProductMatchingService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Domain/Services/Interfaces/IProductMatchingService.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","content":"using Sky.HubAI.Domain.Entities;\r\nusing System.Collections.Generic;\r\n\r\nnamespace Sky.HubAI.Domain.Services.Interfaces\r\n{\r\n    /// <summary>\r\n    /// Domain service responsible for matching products based on text descriptions.\r\n    /// Implements business rules for product search and similarity calculation.\r\n    /// </summary>\r\n    public interface IProductMatchingService\r\n    {\r\n        /// <summary>\r\n        /// Finds the top N products that best match the given description.\r\n        /// Uses tokenization and word compatibility analysis.\r\n        /// </summary>\r\n        /// <param name=\"allProducts\">Complete list of available products.</param>\r\n        /// <param name=\"description\">Text description to match against products.</param>\r\n        /// <param name=\"topCount\">Maximum number of results to return.</param>\r\n        /// <returns>List of products ordered by match quality (best matches first).</returns>\r\n        IReadOnlyList<Product> FindTopMatchingProducts(\r\n            IReadOnlyList<Product> allProducts,\r\n            string description,\r\n            int topCount);\r\n    }\r\n}","epoch":19,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Domain/Services/Implementations/ProductMatchingService.cs::request_49043e35-303e-4ac3-91d7-e0f94ee08aba",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Domain\\Services\\Implementations\\ProductMatchingService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Domain/Services/Implementations/ProductMatchingService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Domain/Services/Implementations/ProductMatchingService.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","content":"using Microsoft.Extensions.Logging;\r\nusing Sky.HubAI.Domain.Entities;\r\nusing Sky.HubAI.Domain.Services.Interfaces;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Globalization;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace Sky.HubAI.Domain.Services.Implementations\r\n{\r\n    /// <summary>\r\n    /// Domain service implementing product matching logic based on word compatibility.\r\n    /// Uses tokenization, normalization, and similarity algorithms.\r\n    /// </summary>\r\n    public class ProductMatchingService : IProductMatchingService\r\n    {\r\n        private readonly ILogger<ProductMatchingService> _logger;\r\n\r\n        public ProductMatchingService(ILogger<ProductMatchingService> logger)\r\n        {\r\n            _logger = logger;\r\n        }\r\n\r\n        public IReadOnlyList<Product> FindTopMatchingProducts(\r\n            IReadOnlyList<Product> allProducts,\r\n            string description,\r\n            int topCount)\r\n        {\r\n            if (allProducts == null || allProducts.Count == 0)\r\n            {\r\n                _logger.LogWarning(\"FindTopMatchingProducts chamado com lista de produtos vazia\");\r\n                return Array.Empty<Product>();\r\n            }\r\n\r\n            if (string.IsNullOrWhiteSpace(description))\r\n            {\r\n                _logger.LogWarning(\"FindTopMatchingProducts chamado com descrição vazia\");\r\n                return Array.Empty<Product>();\r\n            }\r\n\r\n            _logger.LogInformation(\r\n                \"Iniciando busca de produtos compatíveis. Total de produtos: {ProductCount}, Top: {TopCount}\",\r\n                allProducts.Count,\r\n                topCount);\r\n\r\n            var descTokens = Tokenize(description)\r\n                .Select(t => t.ToLowerInvariant())\r\n                .ToHashSet();\r\n\r\n            var scored = allProducts\r\n                .Select(product =>\r\n                {\r\n                    var nameTokens = Tokenize(product.Name)\r\n                        .Select(t => t.ToLowerInvariant())\r\n                        .ToArray();\r\n\r\n                    if (nameTokens.Length == 0)\r\n                        return (product, score: 0.0, matchCount: 0, wordCount: 0);\r\n\r\n                    int matchCount = nameTokens.Count(t => descTokens.Contains(t));\r\n                    int wordCount = nameTokens.Length;\r\n                    double score = wordCount == 0 ? 0.0 : (double)matchCount / wordCount;\r\n\r\n                    return (product, score, matchCount, wordCount);\r\n                })\r\n                .Where(x => x.matchCount > 0)\r\n                .OrderByDescending(x => x.score)\r\n                .ThenByDescending(x => x.matchCount)\r\n                .ThenBy(x => x.wordCount)\r\n                .Take(topCount)\r\n                .Select(x => x.product)\r\n                .ToList();\r\n\r\n            _logger.LogInformation(\r\n                \"Busca concluída. Produtos encontrados com match: {MatchCount}\",\r\n                scored.Count);\r\n\r\n            return scored;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Tokenizes text by removing diacritics, splitting by separators, and filtering short tokens.\r\n        /// </summary>\r\n        private static IEnumerable<string> Tokenize(string text)\r\n        {\r\n            if (string.IsNullOrWhiteSpace(text))\r\n                return Enumerable.Empty<string>();\r\n\r\n            // Remove diacritics (acentos)\r\n            text = text.Normalize(NormalizationForm.FormD);\r\n            var sb = new StringBuilder();\r\n            foreach (var c in text)\r\n            {\r\n                var uc = CharUnicodeInfo.GetUnicodeCategory(c);\r\n                if (uc != UnicodeCategory.NonSpacingMark)\r\n                    sb.Append(c);\r\n            }\r\n            text = sb.ToString().Normalize(NormalizationForm.FormC);\r\n\r\n            // Split por separadores comuns\r\n            var separators = new[] { ' ', ',', ';', '.', ':', '\\n', '\\r', '\\t', '-', '/', '+', '(', ')', '[', ']' };\r\n            return text.Split(separators, StringSplitOptions.RemoveEmptyEntries)\r\n                .Select(s => s.Trim().ToLowerInvariant())\r\n                .Where(s => s.Length > 1)\r\n                .Distinct();\r\n        }\r\n\r\n        /// <summary>\r\n        /// Calculates similarity ratio between two strings using Levenshtein distance.\r\n        /// Returns value between 0.0 (completely different) and 1.0 (identical).\r\n        /// </summary>\r\n        private static double SimilarityRatio(string a, string b)\r\n        {\r\n            int distance = LevenshteinDistance(a, b);\r\n            int maxLen = Math.Max(a.Length, b.Length);\r\n            if (maxLen == 0) return 0;\r\n            return 1.0 - (double)distance / maxLen;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Calculates Levenshtein distance (edit distance) between two strings.\r\n        /// </summary>\r\n        private static int LevenshteinDistance(string s, string t)\r\n        {\r\n            int n = s.Length;\r\n            int m = t.Length;\r\n            if (n == 0) return m;\r\n            if (m == 0) return n;\r\n\r\n            var d = new int[n + 1, m + 1];\r\n\r\n            for (int i = 0; i <= n; i++)\r\n                d[i, 0] = i;\r\n\r\n            for (int j = 0; j <= m; j++)\r\n                d[0, j] = j;\r\n\r\n            for (int i = 1; i <= n; i++)\r\n            {\r\n                for (int j = 1; j <= m; j++)\r\n                {\r\n                    int cost = s[i - 1] == t[j - 1] ? 0 : 1;\r\n                    d[i, j] = Math.Min(\r\n                        Math.Min(d[i - 1, j] + 1, d[i, j - 1] + 1),\r\n                        d[i - 1, j - 1] + cost);\r\n                }\r\n            }\r\n\r\n            return d[n, m];\r\n        }\r\n    }\r\n}","epoch":20,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs::request_49043e35-303e-4ac3-91d7-e0f94ee08aba",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\UseCases\\Intent\\ClassifyIntent\\ClassifyIntentQueryHandler.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","content":"using MediatR;\r\nusing Microsoft.Extensions.Logging;\r\nusing Sky.HubAI.Application.Abstractions;\r\nusing Sky.HubAI.Application.Models;\r\nusing Sky.HubAI.Domain.Services.Interfaces;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Sky.HubAI.Application.UseCases.Intent.ClassifyIntent\r\n{\r\n    /// <summary>\r\n    /// Use case handler for classifying user intent from text descriptions.\r\n    /// Orchestrates: product search via function calling, calling AI service, normalizing results.\r\n    /// </summary>\r\n    public class ClassifyIntentQueryHandler : IRequestHandler<ClassifyIntentQuery, ClassifyIntentResult>\r\n    {\r\n        private readonly IOpenAiIntentClassifyService _openAiService;\r\n        private readonly IProductMemoryCacheService _productCache;\r\n        private readonly IProductMatchingService _productMatching;\r\n        private readonly ILogger<ClassifyIntentQueryHandler> _logger;\r\n\r\n        private const int TopCandidatesPerKeyword = 10;\r\n\r\n        public ClassifyIntentQueryHandler(\r\n            IOpenAiIntentClassifyService openAiService,\r\n            IProductMemoryCacheService productCache,\r\n            IProductMatchingService productMatching,\r\n            ILogger<ClassifyIntentQueryHandler> logger)\r\n        {\r\n            _openAiService = openAiService;\r\n            _productCache = productCache;\r\n            _productMatching = productMatching;\r\n            _logger = logger;\r\n        }\r\n\r\n        public async Task<ClassifyIntentResult> Handle(ClassifyIntentQuery request, CancellationToken cancellationToken)\r\n        {\r\n            _logger.LogInformation(\r\n                \"Iniciando análise de intenção. Descrição: {DescriptionLength} caracteres\",\r\n                request.Description?.Length ?? 0);\r\n\r\n            // 1. Buscar todos os produtos do cache (para uso na função de busca)\r\n            var allProducts = _productCache.GetAllProducts();\r\n            _logger.LogInformation(\"Produtos carregados do cache: {ProductCount}\", allProducts.Count);\r\n\r\n            // 2. Criar função de busca para function calling\r\n            // Esta função será chamada pela LLM quando precisar buscar produtos\r\n            IReadOnlyList<Domain.Entities.Product> SearchProducts(string[] keywords)\r\n            {\r\n                _logger.LogInformation(\"Function calling: buscando produtos com keywords: {Keywords}\", \r\n                    string.Join(\", \", keywords));\r\n\r\n                var results = new List<Domain.Entities.Product>();\r\n                foreach (var keyword in keywords)\r\n                {\r\n                    var matches = _productMatching.FindTopMatchingProducts(\r\n                        allProducts,\r\n                        keyword,\r\n                        TopCandidatesPerKeyword);\r\n                    \r\n                    // Adicionar apenas produtos não duplicados\r\n                    foreach (var product in matches)\r\n                    {\r\n                        if (!results.Any(p => p.Code == product.Code))\r\n                        {\r\n                            results.Add(product);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                _logger.LogInformation(\"Function calling: encontrados {Count} produtos únicos\", results.Count);\r\n                return results;\r\n            }\r\n\r\n            // 3. Chamar serviço de IA com function calling\r\n            var classificationResult = await _openAiService.ClassifyIntentAsync(\r\n                request.Description,\r\n                SearchProducts,\r\n                cancellationToken);\r\n\r\n            // 4. Normalizar ações de todos os produtos classificados (regra de aplicação)\r\n            var normalizedProducts = classificationResult.ClassifiedProducts\r\n                .Select(p => new ClassifiedProduct(\r\n                    p.ProductCode,\r\n                    p.ProductName,\r\n                    NormalizeAction(p.Action)))\r\n                .ToList();\r\n\r\n            // 5. Construir resultado final\r\n            var result = new ClassifyIntentResult(new IntentClassificationResult\r\n            {\r\n                Description = classificationResult.Description,\r\n                ClassifiedProducts = normalizedProducts,\r\n                Keywords = classificationResult.Keywords,\r\n                Log = classificationResult.Log,\r\n                PossibleProducts = classificationResult.PossibleProducts,\r\n                UnmatchedProducts = classificationResult.UnmatchedProducts,\r\n                SearchQueries = classificationResult.SearchQueries\r\n            });\r\n\r\n            _logger.LogInformation(\r\n                \"Classificação concluída. {ProductCount} produtos classificados. Primeiro: Action={Action}, ProductCode={ProductCode}\",\r\n                result.Data.ClassifiedProducts.Count,\r\n                result.Data.Action,\r\n                result.Data.ProductCode);\r\n\r\n            return result;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Normalizes action names to standardized values.\r\n        /// Application-level business rule for consistency.\r\n        /// </summary>\r\n        private static string NormalizeAction(string action)\r\n        {\r\n            if (string.IsNullOrWhiteSpace(action))\r\n                return string.Empty;\r\n\r\n            var normalized = action.Trim().ToLowerInvariant();\r\n\r\n            // Mapeia ações conhecidas\r\n            return normalized switch\r\n            {\r\n                \"product-add\" or \"inclusão\" or \"incluir\" or \"adicionar\" or \"ativação\" or \"liberação\" => \"product-add\",\r\n                \"product-remove\" or \"cancelamento\" or \"cancelar\" or \"retirada\" or \"excluir\" or \"exclusão\" => \"product-remove\",\r\n                \"none\" => \"none\",\r\n                _ => string.Empty\r\n            };\r\n        }\r\n    }\r\n}","epoch":26,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Abstractions/IOpenAiIntentClassifyService.cs::request_49043e35-303e-4ac3-91d7-e0f94ee08aba",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\Abstractions\\IOpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Abstractions/IOpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/Abstractions/IOpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","content":"using Sky.HubAI.Application.Models;\r\nusing Sky.HubAI.Domain.Entities;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Sky.HubAI.Application.Abstractions\r\n{\r\n    /// <summary>\r\n    /// Service for classifying user intent and identifying products using Azure OpenAI.\r\n    /// Supports function calling for dynamic product search.\r\n    /// </summary>\r\n    public interface IOpenAiIntentClassifyService\r\n    {\r\n        /// <summary>\r\n        /// Classifies the intent from a text description, using function calling to search for products.\r\n        /// The LLM extracts keywords and calls the product search function to find matching products.\r\n        /// </summary>\r\n        /// <param name=\"description\">User's text description to analyze.</param>\r\n        /// <param name=\"productSearchFunction\">Function to search products by keywords. Called by the LLM via function calling.</param>\r\n        /// <param name=\"cancellationToken\">Cancellation token.</param>\r\n        /// <returns>Strongly-typed classification result with multiple classified products.</returns>\r\n        Task<IntentClassificationResult> ClassifyIntentAsync(\r\n            string description,\r\n            Func<string[], IReadOnlyList<Product>> productSearchFunction,\r\n            CancellationToken cancellationToken = default);\r\n    }\r\n}","epoch":27,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs::request_49043e35-303e-4ac3-91d7-e0f94ee08aba",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","content":"using Azure;\r\nusing Azure.AI.OpenAI;\r\nusing Microsoft.Extensions.Logging;\r\nusing Microsoft.Extensions.Options;\r\nusing OpenAI.Chat;\r\nusing Sky.HubAI.Application.Abstractions;\r\nusing Sky.HubAI.Application.Models;\r\nusing Sky.HubAI.Domain.Entities;\r\nusing Sky.HubAI.Infrastructure.OpenAI.Prompts;\r\nusing Sky.HubAI.Infrastructure.OpenAI.Settings;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Sky.HubAI.Infrastructure.OpenAI.Services\r\n{\r\n    public class OpenAiIntentClassifyService : IOpenAiIntentClassifyService\r\n    {\r\n        private readonly AzureOpenAiSettings _settings;\r\n        private readonly AzureOpenAIClient _client;\r\n        private readonly ILogger<OpenAiIntentClassifyService> _logger;\r\n\r\n        private const string SearchProductsToolName = \"search_products\";\r\n        private const int MaxFunctionCallingIterations = 5;\r\n\r\n        public OpenAiIntentClassifyService(\r\n            IOptions<AzureOpenAiSettings> settings,\r\n            ILogger<OpenAiIntentClassifyService> logger)\r\n        {\r\n            _settings = settings.Value;\r\n            _client = new AzureOpenAIClient(new Uri(_settings.Endpoint), new AzureKeyCredential(_settings.ApiKey));\r\n            _logger = logger;\r\n        }\r\n\r\n        public async Task<IntentClassificationResult> ClassifyIntentAsync(\r\n            string description,\r\n            Func<string[], IReadOnlyList<Product>> productSearchFunction,\r\n            CancellationToken cancellationToken = default)\r\n        {\r\n            _logger.LogInformation(\"Iniciando classificação de intenção com function calling\");\r\n\r\n            var chatClient = _client.GetChatClient(_settings.DeploymentName);\r\n            var systemPrompt = TextClassificationPrompt.GetSystemPrompt();\r\n            var allFoundProducts = new List<Product>();\r\n            var searchQueries = new List<ProductSearchQuery>();\r\n            var functionCallLogs = new List<FunctionCallLogEntry>();\r\n\r\n            var messages = new List<ChatMessage>\r\n            {\r\n                new SystemChatMessage(systemPrompt),\r\n                new UserChatMessage(description)\r\n            };\r\n\r\n            var tools = new List<ChatTool> { CreateSearchProductsTool() };\r\n            var chatOptions = new ChatCompletionOptions\r\n            {\r\n                Tools = { tools[0] }\r\n            };\r\n\r\n            // Function calling loop\r\n            for (int iteration = 0; iteration < MaxFunctionCallingIterations; iteration++)\r\n            {\r\n                var response = await chatClient.CompleteChatAsync(messages, chatOptions, cancellationToken);\r\n                var chatCompletion = response?.Value;\r\n\r\n                if (chatCompletion == null)\r\n                {\r\n                    _logger.LogWarning(\"Modelo OpenAI retornou resposta vazia na iteração {Iteration}\", iteration);\r\n                    break;\r\n                }\r\n\r\n                // Check if the model wants to call a tool\r\n                if (chatCompletion.FinishReason == ChatFinishReason.ToolCalls)\r\n                {\r\n                    _logger.LogInformation(\"LLM solicitou chamada de ferramenta na iteração {Iteration}\", iteration);\r\n\r\n                    // Add assistant message with tool calls\r\n                    messages.Add(new AssistantChatMessage(chatCompletion));\r\n\r\n                    // Process each tool call\r\n                    foreach (var toolCall in chatCompletion.ToolCalls)\r\n                    {\r\n                        if (toolCall.FunctionName == SearchProductsToolName)\r\n                        {\r\n                            var toolResult = ProcessSearchProductsCall(toolCall, productSearchFunction, allFoundProducts, searchQueries);\r\n                            messages.Add(new ToolChatMessage(toolCall.Id, toolResult));\r\n\r\n                            functionCallLogs.Add(new FunctionCallLogEntry\r\n                            {\r\n                                Iteration = iteration + 1,\r\n                                FunctionName = toolCall.FunctionName,\r\n                                Parameters = toolCall.FunctionArguments.ToString(),\r\n                                Result = toolResult\r\n                            });\r\n                        }\r\n                        else\r\n                        {\r\n                            _logger.LogWarning(\"Ferramenta desconhecida solicitada: {ToolName}\", toolCall.FunctionName);\r\n                            messages.Add(new ToolChatMessage(toolCall.Id, \"Ferramenta não reconhecida.\"));\r\n\r\n                            functionCallLogs.Add(new FunctionCallLogEntry\r\n                            {\r\n                                Iteration = iteration + 1,\r\n                                FunctionName = toolCall.FunctionName,\r\n                                Parameters = toolCall.FunctionArguments.ToString(),\r\n                                Result = \"Ferramenta não reconhecida.\"\r\n                            });\r\n                        }\r\n                    }\r\n\r\n                    continue; // Continue loop to get final response\r\n                }\r\n\r\n                // Final response - parse classification\r\n                if (chatCompletion.FinishReason == ChatFinishReason.Stop)\r\n                {\r\n                    var contentItems = chatCompletion.Content;\r\n                    if (contentItems == null || contentItems.Count == 0)\r\n                    {\r\n                        _logger.LogWarning(\"Resposta final sem conteúdo\");\r\n                        break;\r\n                    }\r\n\r\n                    var content = contentItems[0].Text;\r\n                    _logger.LogDebug(\"Resposta final da OpenAI: {ContentLength} caracteres\", content?.Length ?? 0);\r\n\r\n                    return ParseFinalResponse(description, content, allFoundProducts, searchQueries, functionCallLogs);\r\n                }\r\n\r\n                _logger.LogWarning(\"Finish reason inesperado: {FinishReason}\", chatCompletion.FinishReason);\r\n                break;\r\n            }\r\n\r\n            // Fallback if loop exhausted\r\n            _logger.LogWarning(\"Loop de function calling esgotado sem resposta final\");\r\n            return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Não foi possível obter classificação após múltiplas tentativas.\");\r\n        }\r\n\r\n        private ChatTool CreateSearchProductsTool()\r\n        {\r\n            return ChatTool.CreateFunctionTool(\r\n                functionName: SearchProductsToolName,\r\n                functionDescription: \"Busca produtos no catálogo por palavras-chave. Use esta ferramenta para encontrar produtos mencionados no texto do usuário. IMPORTANTE: Faça buscas separadas para cada produto quando houver múltiplos produtos no texto (separados por +, vírgula, etc). Inclua variações e abreviações expandidas nas keywords (ex: DEG → DEGUSTAÇÃO).\",\r\n                functionParameters: BinaryData.FromString(\"\"\"\r\n                {\r\n                    \"type\": \"object\",\r\n                    \"properties\": {\r\n                        \"keywords\": {\r\n                            \"type\": \"array\",\r\n                            \"items\": { \"type\": \"string\" },\r\n                            \"description\": \"Lista de palavras-chave ou termos para buscar produtos. Para melhores resultados: use o nome completo do produto, variações com abreviações expandidas (DEG→DEGUSTAÇÃO, PROMO→PROMOÇÃO), e termos parciais. Exemplo: para 'DEG HBO 30D' use ['DEG HBO 30D', 'DEGUSTAÇÃO HBO', 'HBO 30D']\"\r\n                        }\r\n                    },\r\n                    \"required\": [\"keywords\"]\r\n                }\r\n                \"\"\"));\r\n        }\r\n\r\n        private string ProcessSearchProductsCall(\r\n            ChatToolCall toolCall,\r\n            Func<string[], IReadOnlyList<Product>> productSearchFunction,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries)\r\n        {\r\n            try\r\n            {\r\n                var arguments = JsonSerializer.Deserialize<SearchProductsArguments>(toolCall.FunctionArguments);\r\n                var keywords = arguments?.Keywords ?? Array.Empty<string>();\r\n\r\n                _logger.LogInformation(\"Buscando produtos com keywords: {Keywords}\", string.Join(\", \", keywords));\r\n\r\n                var foundProducts = productSearchFunction(keywords);\r\n                allFoundProducts.AddRange(foundProducts.Where(p => !allFoundProducts.Any(ap => ap.Code == p.Code)));\r\n\r\n                // Registrar a busca realizada (keywords + produtos retornados)\r\n                var productsReturned = foundProducts\r\n                    .Select(p => new ProductCandidate(p.Code, p.Name))\r\n                    .ToList();\r\n                searchQueries.Add(new ProductSearchQuery(keywords, productsReturned));\r\n\r\n                _logger.LogInformation(\"Encontrados {Count} produtos para as keywords\", foundProducts.Count);\r\n\r\n                if (foundProducts.Count == 0)\r\n                {\r\n                    return \"Nenhum produto encontrado para as palavras-chave fornecidas.\";\r\n                }\r\n\r\n                var sb = new StringBuilder();\r\n                sb.AppendLine($\"Encontrados {foundProducts.Count} produtos:\");\r\n                foreach (var product in foundProducts)\r\n                {\r\n                    sb.AppendLine($\"- Código: {product.Code} | Nome: {product.Name}\");\r\n                }\r\n                return sb.ToString();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                _logger.LogError(ex, \"Erro ao processar chamada search_products\");\r\n                return \"Erro ao buscar produtos.\";\r\n            }\r\n        }\r\n\r\n        private IntentClassificationResult ParseFinalResponse(\r\n            string description,\r\n            string? content,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries,\r\n            List<FunctionCallLogEntry> functionCallLogs)\r\n        {\r\n            var possibleProducts = allFoundProducts\r\n                .Select(p => new ProductCandidate(p.Code, p.Name))\r\n                .ToList();\r\n\r\n            if (string.IsNullOrWhiteSpace(content))\r\n            {\r\n                return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Resposta vazia do modelo.\");\r\n            }\r\n\r\n            var parsed = ParseResponseToDictionary(content);\r\n            if (parsed == null)\r\n            {\r\n                _logger.LogWarning(\"Falha ao interpretar JSON da resposta final\");\r\n                return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Falha ao interpretar JSON da resposta.\");\r\n            }\r\n\r\n            var keywords = ExtractKeywords(parsed);\r\n            var classifiedProducts = ExtractClassifiedProducts(parsed, allFoundProducts);\r\n            var unmatchedProducts = ExtractUnmatchedProducts(parsed);\r\n            var thinking = parsed.TryGetValue(\"log\", out var logVal) ? logVal?.ToString() ?? string.Empty : string.Empty;\r\n            var callings = functionCallLogs\r\n                .Select(e => new FunctionCallLog(e.FunctionName, e.Parameters, e.Result))\r\n                .ToList();\r\n\r\n            var result = new IntentClassificationResult\r\n            {\r\n                Description = description,\r\n                ClassifiedProducts = classifiedProducts,\r\n                Keywords = keywords,\r\n                Log = new ClassificationLog\r\n                {\r\n                    Thinking = thinking,\r\n                    Callings = callings\r\n                },\r\n                PossibleProducts = possibleProducts,\r\n                UnmatchedProducts = unmatchedProducts,\r\n                SearchQueries = searchQueries\r\n            };\r\n\r\n            _logger.LogInformation(\r\n                \"Classificação concluída. {ProductCount} produtos classificados\",\r\n                classifiedProducts.Count);\r\n\r\n            return result;\r\n        }\r\n\r\n        private IReadOnlyList<ClassifiedProduct> ExtractClassifiedProducts(\r\n            Dictionary<string, object>? parsed,\r\n            List<Product> allFoundProducts)\r\n        {\r\n            if (parsed == null) return Array.Empty<ClassifiedProduct>();\r\n\r\n            var result = new List<ClassifiedProduct>();\r\n\r\n            // Try to extract \"classifiedProducts\" array\r\n            if (parsed.TryGetValue(\"classifiedProducts\", out var productsVal) && productsVal is JsonElement jsonArray)\r\n            {\r\n                if (jsonArray.ValueKind == JsonValueKind.Array)\r\n                {\r\n                    foreach (var item in jsonArray.EnumerateArray())\r\n                    {\r\n                        var productCode = item.TryGetProperty(\"productCode\", out var codeEl) ? codeEl.GetString() ?? string.Empty : string.Empty;\r\n                        var productName = item.TryGetProperty(\"productName\", out var nameEl) ? nameEl.GetString() ?? string.Empty : string.Empty;\r\n                        var action = item.TryGetProperty(\"action\", out var actionEl) ? actionEl.GetString() ?? string.Empty : string.Empty;\r\n\r\n                        // If productName is empty, try to get from found products\r\n                        if (string.IsNullOrEmpty(productName) && !string.IsNullOrEmpty(productCode))\r\n                        {\r\n                            productName = allFoundProducts.FirstOrDefault(p => p.Code == productCode)?.Name ?? string.Empty;\r\n                        }\r\n\r\n                        if (!string.IsNullOrEmpty(productCode) || !string.IsNullOrEmpty(productName))\r\n                        {\r\n                            result.Add(new ClassifiedProduct(productCode, productName, action));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Fallback: try legacy single product format\r\n            if (result.Count == 0)\r\n            {\r\n                var action = parsed.TryGetValue(\"action\", out var actionVal) ? actionVal?.ToString() ?? string.Empty : string.Empty;\r\n                var productCode = parsed.TryGetValue(\"product_code\", out var codeVal) ? codeVal?.ToString() ?? string.Empty : string.Empty;\r\n                var productDescription = parsed.TryGetValue(\"productDescription\", out var descVal) ? descVal?.ToString() ?? string.Empty : string.Empty;\r\n\r\n                if (!string.IsNullOrEmpty(productCode) || !string.IsNullOrEmpty(productDescription))\r\n                {\r\n                    result.Add(new ClassifiedProduct(productCode, productDescription, action));\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private IntentClassificationResult CreateEmptyResult(\r\n            string description,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries,\r\n            string logMessage)\r\n        {\r\n            return new IntentClassificationResult\r\n            {\r\n                Description = description,\r\n                ClassifiedProducts = Array.Empty<ClassifiedProduct>(),\r\n                Keywords = Array.Empty<string>(),\r\n                Log = new ClassificationLog\r\n                {\r\n                    Thinking = logMessage,\r\n                    Callings = Array.Empty<FunctionCallLog>()\r\n                },\r\n                PossibleProducts = allFoundProducts\r\n                    .Select(p => new ProductCandidate(p.Code, p.Name))\r\n                    .ToList(),\r\n                SearchQueries = searchQueries\r\n            };\r\n        }\r\n\r\n        private IReadOnlyList<string> ExtractUnmatchedProducts(Dictionary<string, object>? parsed)\r\n        {\r\n            if (parsed == null) return Array.Empty<string>();\r\n\r\n            if (parsed.TryGetValue(\"unmatchedProducts\", out var val) && val is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.Array)\r\n            {\r\n                return jsonElement.EnumerateArray()\r\n                    .Select(e => e.GetString() ?? string.Empty)\r\n                    .Where(s => !string.IsNullOrWhiteSpace(s))\r\n                    .ToList();\r\n            }\r\n\r\n            return Array.Empty<string>();\r\n        }\r\n\r\n        private IReadOnlyList<string> ExtractKeywords(Dictionary<string, object>? parsed)\r\n        {\r\n            if (parsed == null) return Array.Empty<string>();\r\n\r\n            if (parsed.TryGetValue(\"keywords\", out var keyVal) && keyVal != null)\r\n            {\r\n                if (keyVal is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.Array)\r\n                {\r\n                    return jsonElement.EnumerateArray()\r\n                        .Select(e => e.GetString() ?? string.Empty)\r\n                        .Where(s => !string.IsNullOrWhiteSpace(s))\r\n                        .ToList();\r\n                }\r\n\r\n                var str = keyVal.ToString() ?? string.Empty;\r\n                if (!string.IsNullOrWhiteSpace(str))\r\n                {\r\n                    return str.Split(new[] { ',', ';' }, StringSplitOptions.RemoveEmptyEntries)\r\n                        .Select(s => s.Trim())\r\n                        .Where(s => !string.IsNullOrWhiteSpace(s))\r\n                        .ToList();\r\n                }\r\n            }\r\n\r\n            return Array.Empty<string>();\r\n        }\r\n\r\n        private static Dictionary<string, object>? ParseResponseToDictionary(string content)\r\n        {\r\n            if (string.IsNullOrWhiteSpace(content))\r\n                return null;\r\n            try\r\n            {\r\n                content = content.Replace(\"```json\", \"\", StringComparison.OrdinalIgnoreCase)\r\n                                 .Replace(\"```\", \"\", StringComparison.OrdinalIgnoreCase)\r\n                                 .Trim();\r\n                var extractedData = JsonSerializer.Deserialize<Dictionary<string, object>>(content, new JsonSerializerOptions\r\n                {\r\n                    NumberHandling = JsonNumberHandling.AllowReadingFromString\r\n                });\r\n                return extractedData;\r\n            }\r\n            catch { return null; }\r\n        }\r\n\r\n        private class SearchProductsArguments\r\n        {\r\n            [JsonPropertyName(\"keywords\")]\r\n            public string[] Keywords { get; set; } = Array.Empty<string>();\r\n        }\r\n\r\n        private class FunctionCallLogEntry\r\n        {\r\n            public int Iteration { get; set; }\r\n            public string FunctionName { get; set; } = string.Empty;\r\n            public string Parameters { get; set; } = string.Empty;\r\n            public string Result { get; set; } = string.Empty;\r\n        }\r\n    }\r\n}","epoch":31,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs::request_49043e35-303e-4ac3-91d7-e0f94ee08aba",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","content":"namespace Sky.HubAI.Infrastructure.OpenAI.Prompts\r\n{\r\n    public static class TextClassificationPrompt\r\n    {\r\n        public static string GetSystemPrompt() =>\r\n            @\"Você é um especialista em classificação de ações e produtos a partir de descrições textuais. Possui habilidade em interpretar textos com erros de grafia, identificar intenções implícitas e extrair informações estruturadas com precisão.\r\n\r\n# Task\r\n\r\nAnalisar descrições fornecidas em texto livre e classificar:\r\n(1) a ação a ser tomada para CADA produto mencionado (adição ou remoção);\r\n(2) Identificar o código de TODOS os produtos mencionados.\r\n\r\n# Context\r\n\r\nEste sistema processa solicitações de clientes que podem conter imprecisões ortográficas, palavras escritas em conjunto ou formatação irregular. A classificação precisa alimenta fluxos de trabalho operacionais, tornando a precisão crítica para o roteamento correto de tarefas e gestão de produtos.\r\n\r\n# Instructions\r\n\r\n## 1. Identificação de Produtos\r\n\r\nAnalise a descrição e identifique TODOS os produtos mencionados.\r\n\r\n**IMPORTANTE - Produtos podem estar listados de várias formas:**\r\n- Separados por `+` : \"\"PROMO SUPER 30D + DEG HBO 30D\"\"\r\n- Separados por `,` : \"\"HBO Max, Telecine, Premiere\"\"\r\n- Separados por `e`/`ou` : \"\"HBO e Telecine\"\"\r\n- Em texto corrido: \"\"incluir recarga PROMO SUPER 30D e também DEG HBO\"\"\r\n- Com valores/preços junto: \"\"PROMO SUPER 30D - R$ 89,91\"\"\r\n\r\n**Ao encontrar múltiplos produtos, busque CADA UM separadamente usando `search_products`.**\r\n\r\nExemplo: Para \"\"PROMO SUPER 30D + DEG HBO 30D\"\", faça buscas separadas:\r\n- search_products([\"\"PROMO SUPER 30D\"\", \"\"PROMO SUPER\"\"])\r\n- search_products([\"\"DEG HBO 30D\"\", \"\"DEG HBO\"\", \"\"HBO 30D\"\", \"\"DEGUSTAÇÃO HBO\"\"])\r\n\r\n**REGRA CRÍTICA - Sempre dividir produtos separados:**\r\n- Quando o texto contém produtos separados por `+`, `,`, `e`, `ou`, ou listados sequencialmente, CADA produto DEVE ser retornado como uma entrada SEPARADA em `classifiedProducts`.\r\n- **NUNCA** retorne um produto combinado/pacote como uma única entrada quando o texto menciona múltiplos produtos.\r\n- Mesmo que o catálogo tenha um produto combinado (ex: \"\"PROMO SUPER 30D + DEG HBO 30D\"\" como um único código), você DEVE retornar cada componente separadamente.\r\n- Para cada componente, busque o melhor código individual. Se não existir código individual, use o código do produto combinado para cada componente.\r\n- Exemplo: \"\"PROMO SUPER 30D + DEG HBO 30D\"\" → dois produtos em classifiedProducts, NUNCA um único.\r\n\r\n## 2. Tratamento de Abreviações e Erros\r\n\r\n**Abreviações comuns que você deve expandir ao buscar:**\r\n- DEG = DEGUSTAÇÃO\r\n- PROMO = PROMOÇÃO ou PROMOCIONAL\r\n- 30D, 7D, 15D = 30 dias, 7 dias, 15 dias (período)\r\n- DEB/DEG = pode ser erro de digitação\r\n\r\n**Ao buscar, inclua variações:**\r\n- Termo original + termo expandido\r\n- Termos parciais do nome do produto\r\n- Combinações com e sem períodos (30D, 7D)\r\n\r\n## 3. Determinação da Ação\r\n\r\nPara CADA produto identificado, determine a ação correspondente:\r\n- `product-add`: inclusão, incluir, adicionar, ativar, ativação, liberação, reativação, pedido, destino, recarga\r\n- `product-remove`: cancelar, cancelamento, excluir, exclusão, retirada, origem, correção, duplicidade, remover\r\n- `none`: quando não for possível determinar a ação\r\n\r\n**Indicadores de ação no contexto:**\r\n- \"\"por favor incluir\"\" → product-add\r\n- \"\"ativar recarga\"\" → product-add\r\n- \"\"valor ficou liberado\"\" + \"\"incluir\"\" → product-add\r\n- \"\"cancelar\"\" → product-remove\r\n- \"\"retirar da grade\"\" → product-remove\r\n\r\n## 4. Tratamento de Valores e Preços\r\n\r\n**IGNORE valores monetários ao identificar produtos:**\r\n- \"\"R$ 89,91\"\", \"\"R  89,91\"\", \"\"89,91\"\" → não fazem parte do nome do produto\r\n- \"\"valor disponível: 129,80\"\" → contexto informativo, não é produto\r\n\r\n## 5. Múltiplos Produtos com Mesma Ação\r\n\r\nUm mesmo texto pode conter MÚLTIPLOS produtos com a MESMA ação:\r\nExemplo: \"\"incluir a recarga: PROMO SUPER 30D + DEG HBO 30D\"\" → 2 produtos separados, ambos com action=\"\"product-add\"\"\r\n\r\n**Cada produto DEVE ter sua própria entrada em classifiedProducts:**\r\n- `productName` deve conter o nome INDIVIDUAL do produto como mencionado no texto, NÃO o nome do produto combinado do catálogo.\r\n- `productCode` deve ser o código do melhor match individual. Se não existir individual, use o código do combinado.\r\n\r\n**CORRETO:**\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código-promo-super\"\", \"\"productName\"\": \"\"PROMO SUPER 30D\"\", \"\"action\"\": \"\"product-add\"\" },\r\n    { \"\"productCode\"\": \"\"código-deg-hbo\"\", \"\"productName\"\": \"\"DEG HBO 30D\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ]\r\n}\r\n```\r\n\r\n**ERRADO** (nunca faça isso - produto combinado como uma única entrada):\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código-combo\"\", \"\"productName\"\": \"\"PROMO SUPER 30D + DEG HBO 30D\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ]\r\n}\r\n```\r\n\r\n**ERRADO** (nunca faça isso - nome do combinado repetido em cada entrada):\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código-combo\"\", \"\"productName\"\": \"\"PROMO SUPER 30D + DEG HBO 30D\"\", \"\"action\"\": \"\"product-add\"\" },\r\n    { \"\"productCode\"\": \"\"código-combo\"\", \"\"productName\"\": \"\"PROMO SUPER 30D + DEG HBO 30D\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ]\r\n}\r\n```\r\n\r\n## 6. Formato de Resposta\r\n\r\nApós identificar todos os produtos e ações, retorne um objeto JSON.\r\n**Cada produto mencionado DEVE ter sua própria entrada em classifiedProducts, mesmo que o catálogo tenha apenas um produto combinado.**\r\n**Produtos mencionados no texto mas NÃO encontrados pelo search_products devem ser listados em unmatchedProducts.**\r\n\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código1\"\", \"\"productName\"\": \"\"Nome do Produto 1\"\", \"\"action\"\": \"\"product-add\"\" },\r\n    { \"\"productCode\"\": \"\"código2\"\", \"\"productName\"\": \"\"Nome do Produto 2\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ],\r\n  \"\"unmatchedProducts\"\": [\"\"Nome do Produto Não Encontrado\"\"],\r\n  \"\"keywords\"\": [\"\"incluir\"\", \"\"recarga\"\"],\r\n  \"\"log\"\": \"\"Explicação do raciocínio usado\"\"\r\n}\r\n```\r\n\r\n## 7. Regras Importantes\r\n\r\n- O output final deve ser APENAS o JSON sem texto adicional.\r\n- Use múltiplas chamadas a `search_products` para encontrar cada produto.\r\n- Jamais invente códigos de produtos. Use apenas os retornados pela função search_products.\r\n- keywords deve conter as palavras-chave de ação encontradas no texto.\r\n- **Se não conseguir determinar a ação, use action=\"\"none\"\".**\r\n- **Se o produto não for encontrado pelo search_products, adicione-o em `unmatchedProducts` (apenas o nome) e NÃO o inclua em `classifiedProducts`.**\r\n- **NUNCA agrupe múltiplos produtos em uma única entrada de classifiedProducts.**\r\n- **Se o catálogo retornar um produto combinado (ex: \"\"A + B\"\"), busque os códigos individuais de A e de B separadamente. Se não existirem códigos individuais, use o código do combinado para cada componente, mas SEMPRE retorne entradas separadas.**\r\n\r\n## 8. Retorno com Ação ou Produto Não Identificado\r\n\r\nQuando não for possível identificar a ação OU o produto:\r\n- Se o produto foi buscado via search_products e NÃO foi encontrado, adicione o nome do produto em `unmatchedProducts` e NÃO o inclua em `classifiedProducts`.\r\n- Se a ação não puder ser determinada mas o produto existe, use action=\"\"none\"\" em `classifiedProducts`.\r\n\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [],\r\n  \"\"unmatchedProducts\"\": [\"\"Nome mencionado no texto\"\"],\r\n  \"\"keywords\"\": [],\r\n  \"\"log\"\": \"\"Produto não encontrado no catálogo\"\" \r\n}\r\n```\r\n\r\n## 9. Se Nenhum Produto For Mencionado no Texto\r\n\r\nSe o texto não mencionar nenhum produto, retorne:\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [],\r\n  \"\"unmatchedProducts\"\": [],\r\n  \"\"keywords\"\": [],\r\n  \"\"log\"\": \"\"Nenhum produto mencionado no texto\"\"\r\n}\r\n```\";\r\n    }\r\n}","epoch":35,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs::request_afa0841e-74ce-4e1c-90f2-f3a304fdc38b",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\Contracts\\IntentClassifications\\IntentClassificationsResponse.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","scheme":"file"},"requestId":"request_afa0841e-74ce-4e1c-90f2-f3a304fdc38b","content":"using System.Collections.Generic;\r\n\r\nnamespace Sky.HubAI.Api.Contracts.IntentClassifications\r\n{\r\n    /// <summary>\r\n    /// Response contract for intent classification operations.\r\n    /// Contains analyzed intents for multiple products and supporting metadata.\r\n    /// </summary>\r\n    public record IntentClassificationsResponse\r\n    {\r\n        /// <summary>\r\n        /// Original description text that was analyzed.\r\n        /// </summary>\r\n        public string Description { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of classified products with their respective actions.\r\n        /// Each product identified in the description has its own action (product-add, product-remove, none).\r\n        /// </summary>\r\n        public IReadOnlyList<ClassifiedProductResponse> ClassifiedProducts { get; init; } = new List<ClassifiedProductResponse>();\r\n\r\n        /// <summary>\r\n        /// Identified action/intent for the first product (e.g., \"product-add\", \"product-remove\").\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string Action { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// Natural language description of the first identified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string ProductDescription { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// Product code of the first identified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string ProductCode { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of keywords extracted from the description.\r\n        /// </summary>\r\n        public IReadOnlyList<string> Keywords { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// Diagnostic log or reasoning from the AI analysis.\r\n        /// </summary>\r\n        public ClassificationLogResponse Log { get; init; } = new ClassificationLogResponse();\r\n\r\n        /// <summary>\r\n        /// List of product names mentioned in the description that could not be matched to any product in the catalog.\r\n        /// </summary>\r\n        public IReadOnlyList<string> UnmatchedProducts { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// List of product search queries made by the LLM during function calling.\r\n        /// Contains the keywords searched and the products returned for each query.\r\n        /// </summary>\r\n        public IReadOnlyList<ProductSearchQueryResponse> SearchQueries { get; init; } = new List<ProductSearchQueryResponse>();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Represents a classified product with its identified action.\r\n    /// </summary>\r\n    public record ClassifiedProductResponse(\r\n        string ProductCode,\r\n        string ProductName,\r\n        string Action);\r\n\r\n    /// <summary>\r\n    /// Represents a product search query made by the LLM.\r\n    /// </summary>\r\n    public record ProductSearchQueryResponse(\r\n        IReadOnlyList<string> Keywords,\r\n        IReadOnlyList<ProductCandidateResponse> ProductsReturned);\r\n\r\n    /// <summary>\r\n    /// Represents a candidate product.\r\n    /// </summary>\r\n    public record ProductCandidateResponse(\r\n        string ProductCode,\r\n        string ProductName);\r\n\r\n    /// <summary>\r\n    /// Structured log from the AI classification process.\r\n    /// </summary>\r\n    public record ClassificationLogResponse\r\n    {\r\n        /// <summary>\r\n        /// The LLM's reasoning/thinking about the classification.\r\n        /// </summary>\r\n        public string Thinking { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of function calls made during the classification process.\r\n        /// </summary>\r\n        public IReadOnlyList<FunctionCallLogResponse> Callings { get; init; } = new List<FunctionCallLogResponse>();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Represents a single function call made by the LLM.\r\n    /// </summary>\r\n    public record FunctionCallLogResponse(\r\n        string Function,\r\n        string Input,\r\n        string Output);\r\n}","epoch":50,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Mappings/IntentClassificationMappingExtensions.cs::request_afa0841e-74ce-4e1c-90f2-f3a304fdc38b",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\Mappings\\IntentClassificationMappingExtensions.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Mappings/IntentClassificationMappingExtensions.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/Mappings/IntentClassificationMappingExtensions.cs","scheme":"file"},"requestId":"request_afa0841e-74ce-4e1c-90f2-f3a304fdc38b","content":"using Sky.HubAI.Api.Contracts.IntentClassifications;\r\nusing Sky.HubAI.Application.Models;\r\nusing System.Linq;\r\n\r\nnamespace Sky.HubAI.Api.Mappings\r\n{\r\n    public static class IntentClassificationMappingExtensions\r\n    {\r\n        /// <summary>\r\n        /// Maps IntentClassificationResult (Application layer) to IntentClassificationsResponse (API contract).\r\n        /// </summary>\r\n        public static IntentClassificationsResponse ToResponse(this IntentClassificationResult result)\r\n        {\r\n            return new IntentClassificationsResponse\r\n            {\r\n                Description = result.Description,\r\n                ClassifiedProducts = result.ClassifiedProducts\r\n                    .Select(p => new ClassifiedProductResponse(p.ProductCode, p.ProductName, p.Action))\r\n                    .ToList(),\r\n                Action = result.Action,\r\n                ProductDescription = result.ProductDescription,\r\n                ProductCode = result.ProductCode,\r\n                Keywords = result.Keywords,\r\n                Log = new ClassificationLogResponse\r\n                {\r\n                    Thinking = result.Log.Thinking,\r\n                    Callings = result.Log.Callings\r\n                        .Select(c => new FunctionCallLogResponse(c.Function, c.Input, c.Output))\r\n                        .ToList()\r\n                },\r\n                UnmatchedProducts = result.UnmatchedProducts,\r\n                SearchQueries = result.SearchQueries\r\n                    .Select(q => new ProductSearchQueryResponse(\r\n                        q.Keywords,\r\n                        q.ProductsReturned\r\n                            .Select(p => new ProductCandidateResponse(p.ProductCode, p.ProductName))\r\n                            .ToList()))\r\n                    .ToList()\r\n            };\r\n        }\r\n    }\r\n}","epoch":51,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs::request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\Contracts\\IntentClassifications\\IntentClassificationsResponse.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","scheme":"file"},"requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","content":"using System.Collections.Generic;\r\n\r\nnamespace Sky.HubAI.Api.Contracts.IntentClassifications\r\n{\r\n    /// <summary>\r\n    /// Response contract for intent classification operations.\r\n    /// Contains analyzed intents for multiple products and supporting metadata.\r\n    /// </summary>\r\n    public record IntentClassificationsResponse\r\n    {\r\n        /// <summary>\r\n        /// Original description text that was analyzed.\r\n        /// </summary>\r\n        public string Description { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of classified products with their respective actions.\r\n        /// Each product identified in the description has its own action (product-add, product-remove, none).\r\n        /// </summary>\r\n        public IReadOnlyList<ClassifiedProductResponse> ClassifiedProducts { get; init; } = new List<ClassifiedProductResponse>();\r\n\r\n        /// <summary>\r\n        /// Identified action/intent for the first product (e.g., \"product-add\", \"product-remove\").\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string Action { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// Natural language description of the first identified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string ProductDescription { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// Product code of the first identified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string ProductCode { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of keywords extracted from the description.\r\n        /// </summary>\r\n        public IReadOnlyList<string> Keywords { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// Diagnostic log or reasoning from the AI analysis.\r\n        /// </summary>\r\n        public ClassificationLogResponse Log { get; init; } = new ClassificationLogResponse();\r\n\r\n        /// <summary>\r\n        /// List of product names mentioned in the description that could not be matched to any product in the catalog.\r\n        /// </summary>\r\n        public IReadOnlyList<string> UnmatchedProducts { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// List of product search queries made by the LLM during function calling.\r\n        /// Contains the keywords searched and the products returned for each query.\r\n        /// </summary>\r\n        public IReadOnlyList<ProductSearchQueryResponse> SearchQueries { get; init; } = new List<ProductSearchQueryResponse>();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Represents a classified product with its identified action.\r\n    /// </summary>\r\n    public record ClassifiedProductResponse(\r\n        string ProductCode,\r\n        string ProductName,\r\n        string Action);\r\n\r\n    /// <summary>\r\n    /// Represents a product search query made by the LLM.\r\n    /// </summary>\r\n    public record ProductSearchQueryResponse(\r\n        IReadOnlyList<string> Keywords,\r\n        IReadOnlyList<ProductCandidateResponse> ProductsReturned);\r\n\r\n    /// <summary>\r\n    /// Represents a candidate product.\r\n    /// </summary>\r\n    public record ProductCandidateResponse(\r\n        string ProductCode,\r\n        string ProductName);\r\n\r\n    /// <summary>\r\n    /// Structured log from the AI classification process.\r\n    /// </summary>\r\n    public record ClassificationLogResponse\r\n    {\r\n        /// <summary>\r\n        /// The LLM's reasoning/thinking about the classification.\r\n        /// </summary>\r\n        public string Thinking { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of function calls made during the classification process.\r\n        /// </summary>\r\n        public IReadOnlyList<FunctionCallLogResponse> Callings { get; init; } = new List<FunctionCallLogResponse>();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Represents a single function call made by the LLM.\r\n    /// </summary>\r\n    public record FunctionCallLogResponse(\r\n        string Function,\r\n        string Input,\r\n        string Output);\r\n}","epoch":58,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Mappings/IntentClassificationMappingExtensions.cs::request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\Mappings\\IntentClassificationMappingExtensions.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Mappings/IntentClassificationMappingExtensions.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/Mappings/IntentClassificationMappingExtensions.cs","scheme":"file"},"requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","content":"using Sky.HubAI.Api.Contracts.IntentClassifications;\r\nusing Sky.HubAI.Application.Models;\r\nusing System.Linq;\r\n\r\nnamespace Sky.HubAI.Api.Mappings\r\n{\r\n    public static class IntentClassificationMappingExtensions\r\n    {\r\n        /// <summary>\r\n        /// Maps IntentClassificationResult (Application layer) to IntentClassificationsResponse (API contract).\r\n        /// </summary>\r\n        public static IntentClassificationsResponse ToResponse(this IntentClassificationResult result)\r\n        {\r\n            return new IntentClassificationsResponse\r\n            {\r\n                Description = result.Description,\r\n                ClassifiedProducts = result.ClassifiedProducts\r\n                    .Select(p => new ClassifiedProductResponse(p.ProductCode, p.ProductName, p.Action))\r\n                    .ToList(),\r\n                Action = result.Action,\r\n                ProductDescription = result.ProductDescription,\r\n                ProductCode = result.ProductCode,\r\n                Keywords = result.Keywords,\r\n                Log = new ClassificationLogResponse\r\n                {\r\n                    Thinking = result.Log.Thinking,\r\n                    Callings = result.Log.Callings\r\n                        .Select(c => new FunctionCallLogResponse(c.Function, c.Input, c.Output))\r\n                        .ToList()\r\n                },\r\n                UnmatchedProducts = result.UnmatchedProducts,\r\n                SearchQueries = result.SearchQueries\r\n                    .Select(q => new ProductSearchQueryResponse(\r\n                        q.Keywords,\r\n                        q.ProductsReturned\r\n                            .Select(p => new ProductCandidateResponse(p.ProductCode, p.ProductName))\r\n                            .ToList()))\r\n                    .ToList()\r\n            };\r\n        }\r\n    }\r\n}","epoch":59,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs::request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\Models\\IntentClassificationResult.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","scheme":"file"},"requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","content":"using System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace Sky.HubAI.Application.Models\r\n{\r\n    /// <summary>\r\n    /// Strongly-typed result from intent classification operation.\r\n    /// Represents the analyzed intents for multiple products and supporting metadata.\r\n    /// </summary>\r\n    public record IntentClassificationResult\r\n    {\r\n        /// <summary>\r\n        /// Original description text that was analyzed.\r\n        /// </summary>\r\n        public string Description { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of classified products with their respective actions.\r\n        /// Each product identified in the description has its own action (product-add, product-remove, none).\r\n        /// </summary>\r\n        public IReadOnlyList<ClassifiedProduct> ClassifiedProducts { get; init; } = new List<ClassifiedProduct>();\r\n\r\n        /// <summary>\r\n        /// Identified action/intent for the first classified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string Action => ClassifiedProducts.FirstOrDefault()?.Action ?? string.Empty;\r\n\r\n        /// <summary>\r\n        /// Natural language description of the first identified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string ProductDescription => ClassifiedProducts.FirstOrDefault()?.ProductName ?? string.Empty;\r\n\r\n        /// <summary>\r\n        /// Product code of the first identified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string ProductCode => ClassifiedProducts.FirstOrDefault()?.ProductCode ?? string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of keywords extracted from the description.\r\n        /// </summary>\r\n        public IReadOnlyList<string> Keywords { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// Diagnostic log or reasoning from the AI analysis.\r\n        /// </summary>\r\n        public ClassificationLog Log { get; init; } = new ClassificationLog();\r\n\r\n        /// <summary>\r\n        /// List of candidate products that were considered during matching.\r\n        /// Each entry contains product code and name.\r\n        /// </summary>\r\n        public IReadOnlyList<ProductCandidate> PossibleProducts { get; init; } = new List<ProductCandidate>();\r\n\r\n        /// <summary>\r\n        /// List of product names mentioned in the description that could not be matched to any product in the catalog.\r\n        /// </summary>\r\n        public IReadOnlyList<string> UnmatchedProducts { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// List of product search queries made by the LLM during function calling.\r\n        /// Contains the keywords searched and the products returned for each query.\r\n        /// </summary>\r\n        public IReadOnlyList<ProductSearchQuery> SearchQueries { get; init; } = new List<ProductSearchQuery>();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Represents a product that was classified with its identified action.\r\n    /// </summary>\r\n    public record ClassifiedProduct(\r\n        string ProductCode,\r\n        string ProductName,\r\n        string Action);\r\n\r\n    /// <summary>\r\n    /// Represents a candidate product during matching.\r\n    /// </summary>\r\n    public record ProductCandidate(\r\n        string ProductCode,\r\n        string ProductName);\r\n\r\n    /// <summary>\r\n    /// Represents a product search query made by the LLM.\r\n    /// Contains the keywords that were searched and the products that were returned.\r\n    /// </summary>\r\n    public record ProductSearchQuery(\r\n        IReadOnlyList<string> Keywords,\r\n        IReadOnlyList<ProductCandidate> ProductsReturned);\r\n\r\n    /// <summary>\r\n    /// Structured log from the AI classification process.\r\n    /// </summary>\r\n    public record ClassificationLog\r\n    {\r\n        /// <summary>\r\n        /// The LLM's reasoning/thinking about the classification.\r\n        /// </summary>\r\n        public string Thinking { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of function calls made during the classification process.\r\n        /// </summary>\r\n        public IReadOnlyList<FunctionCallLog> Callings { get; init; } = new List<FunctionCallLog>();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Represents a single function call made by the LLM during classification.\r\n    /// </summary>\r\n    public record FunctionCallLog(\r\n        string Function,\r\n        string Input,\r\n        string Output);\r\n}","epoch":60,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs::request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","content":"using Azure;\r\nusing Azure.AI.OpenAI;\r\nusing Microsoft.Extensions.Logging;\r\nusing Microsoft.Extensions.Options;\r\nusing OpenAI.Chat;\r\nusing Sky.HubAI.Application.Abstractions;\r\nusing Sky.HubAI.Application.Models;\r\nusing Sky.HubAI.Domain.Entities;\r\nusing Sky.HubAI.Infrastructure.OpenAI.Prompts;\r\nusing Sky.HubAI.Infrastructure.OpenAI.Settings;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Sky.HubAI.Infrastructure.OpenAI.Services\r\n{\r\n    public class OpenAiIntentClassifyService : IOpenAiIntentClassifyService\r\n    {\r\n        private readonly AzureOpenAiSettings _settings;\r\n        private readonly AzureOpenAIClient _client;\r\n        private readonly ILogger<OpenAiIntentClassifyService> _logger;\r\n\r\n        private const string SearchProductsToolName = \"search_products\";\r\n        private const int MaxFunctionCallingIterations = 5;\r\n\r\n        public OpenAiIntentClassifyService(\r\n            IOptions<AzureOpenAiSettings> settings,\r\n            ILogger<OpenAiIntentClassifyService> logger)\r\n        {\r\n            _settings = settings.Value;\r\n            _client = new AzureOpenAIClient(new Uri(_settings.Endpoint), new AzureKeyCredential(_settings.ApiKey));\r\n            _logger = logger;\r\n        }\r\n\r\n        public async Task<IntentClassificationResult> ClassifyIntentAsync(\r\n            string description,\r\n            Func<string[], IReadOnlyList<ProductMatchResult>> productSearchFunction,\r\n            CancellationToken cancellationToken = default)\r\n        {\r\n            _logger.LogInformation(\"Iniciando classificação de intenção com function calling\");\r\n\r\n            var chatClient = _client.GetChatClient(_settings.DeploymentName);\r\n            var systemPrompt = TextClassificationPrompt.GetSystemPrompt();\r\n            var allFoundProducts = new List<Product>();\r\n            var searchQueries = new List<ProductSearchQuery>();\r\n            var functionCallLogs = new List<FunctionCallLogEntry>();\r\n\r\n            var messages = new List<ChatMessage>\r\n            {\r\n                new SystemChatMessage(systemPrompt),\r\n                new UserChatMessage(description)\r\n            };\r\n\r\n            var tools = new List<ChatTool> { CreateSearchProductsTool() };\r\n            var chatOptions = new ChatCompletionOptions\r\n            {\r\n                Tools = { tools[0] }\r\n            };\r\n\r\n            // Function calling loop\r\n            for (int iteration = 0; iteration < MaxFunctionCallingIterations; iteration++)\r\n            {\r\n                var response = await chatClient.CompleteChatAsync(messages, chatOptions, cancellationToken);\r\n                var chatCompletion = response?.Value;\r\n\r\n                if (chatCompletion == null)\r\n                {\r\n                    _logger.LogWarning(\"Modelo OpenAI retornou resposta vazia na iteração {Iteration}\", iteration);\r\n                    break;\r\n                }\r\n\r\n                // Check if the model wants to call a tool\r\n                if (chatCompletion.FinishReason == ChatFinishReason.ToolCalls)\r\n                {\r\n                    _logger.LogInformation(\"LLM solicitou chamada de ferramenta na iteração {Iteration}\", iteration);\r\n\r\n                    // Add assistant message with tool calls\r\n                    messages.Add(new AssistantChatMessage(chatCompletion));\r\n\r\n                    // Process each tool call\r\n                    foreach (var toolCall in chatCompletion.ToolCalls)\r\n                    {\r\n                        if (toolCall.FunctionName == SearchProductsToolName)\r\n                        {\r\n                            var toolResult = ProcessSearchProductsCall(toolCall, productSearchFunction, allFoundProducts, searchQueries);\r\n                            messages.Add(new ToolChatMessage(toolCall.Id, toolResult));\r\n\r\n                            functionCallLogs.Add(new FunctionCallLogEntry\r\n                            {\r\n                                Iteration = iteration + 1,\r\n                                FunctionName = toolCall.FunctionName,\r\n                                Parameters = toolCall.FunctionArguments.ToString(),\r\n                                Result = toolResult\r\n                            });\r\n                        }\r\n                        else\r\n                        {\r\n                            _logger.LogWarning(\"Ferramenta desconhecida solicitada: {ToolName}\", toolCall.FunctionName);\r\n                            messages.Add(new ToolChatMessage(toolCall.Id, \"Ferramenta não reconhecida.\"));\r\n\r\n                            functionCallLogs.Add(new FunctionCallLogEntry\r\n                            {\r\n                                Iteration = iteration + 1,\r\n                                FunctionName = toolCall.FunctionName,\r\n                                Parameters = toolCall.FunctionArguments.ToString(),\r\n                                Result = \"Ferramenta não reconhecida.\"\r\n                            });\r\n                        }\r\n                    }\r\n\r\n                    continue; // Continue loop to get final response\r\n                }\r\n\r\n                // Final response - parse classification\r\n                if (chatCompletion.FinishReason == ChatFinishReason.Stop)\r\n                {\r\n                    var contentItems = chatCompletion.Content;\r\n                    if (contentItems == null || contentItems.Count == 0)\r\n                    {\r\n                        _logger.LogWarning(\"Resposta final sem conteúdo\");\r\n                        break;\r\n                    }\r\n\r\n                    var content = contentItems[0].Text;\r\n                    _logger.LogDebug(\"Resposta final da OpenAI: {ContentLength} caracteres\", content?.Length ?? 0);\r\n\r\n                    return ParseFinalResponse(description, content, allFoundProducts, searchQueries, functionCallLogs);\r\n                }\r\n\r\n                _logger.LogWarning(\"Finish reason inesperado: {FinishReason}\", chatCompletion.FinishReason);\r\n                break;\r\n            }\r\n\r\n            // Fallback if loop exhausted\r\n            _logger.LogWarning(\"Loop de function calling esgotado sem resposta final\");\r\n            return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Não foi possível obter classificação após múltiplas tentativas.\");\r\n        }\r\n\r\n        private ChatTool CreateSearchProductsTool()\r\n        {\r\n            return ChatTool.CreateFunctionTool(\r\n                functionName: SearchProductsToolName,\r\n                functionDescription: \"Busca produtos no catálogo por palavras-chave. Retorna produtos com percentual de acerto (%). Use esta ferramenta para encontrar produtos mencionados no texto do usuário. IMPORTANTE: Primeiro busque o nome completo/combinado. Se nenhum resultado tiver acerto >= 80%, busque cada produto separadamente. Inclua variações e abreviações expandidas nas keywords (ex: DEG → DEGUSTAÇÃO).\",\r\n                functionParameters: BinaryData.FromString(\"\"\"\r\n                {\r\n                    \"type\": \"object\",\r\n                    \"properties\": {\r\n                        \"keywords\": {\r\n                            \"type\": \"array\",\r\n                            \"items\": { \"type\": \"string\" },\r\n                            \"description\": \"Lista de palavras-chave ou termos para buscar produtos. Para melhores resultados: use o nome completo do produto, variações com abreviações expandidas (DEG→DEGUSTAÇÃO, PROMO→PROMOÇÃO), e termos parciais. Pode incluir nomes combinados (ex: 'PROMO SUPER 30D + DEG HBO 30D') para verificar se existe como produto único. Os resultados incluem percentual de acerto (%).\"\r\n                        }\r\n                    },\r\n                    \"required\": [\"keywords\"]\r\n                }\r\n                \"\"\"));\r\n        }\r\n\r\n        private string ProcessSearchProductsCall(\r\n            ChatToolCall toolCall,\r\n            Func<string[], IReadOnlyList<ProductMatchResult>> productSearchFunction,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries)\r\n        {\r\n            try\r\n            {\r\n                var arguments = JsonSerializer.Deserialize<SearchProductsArguments>(toolCall.FunctionArguments);\r\n                var keywords = arguments?.Keywords ?? Array.Empty<string>();\r\n\r\n                _logger.LogInformation(\"Buscando produtos com keywords: {Keywords}\", string.Join(\", \", keywords));\r\n\r\n                var foundMatches = productSearchFunction(keywords);\r\n                allFoundProducts.AddRange(foundMatches\r\n                    .Where(m => !allFoundProducts.Any(ap => ap.Code == m.Product.Code))\r\n                    .Select(m => m.Product));\r\n\r\n                // Registrar a busca realizada (keywords + produtos retornados)\r\n                var productsReturned = foundMatches\r\n                    .Select(m => new ProductCandidate(m.Product.Code, m.Product.Name))\r\n                    .ToList();\r\n                searchQueries.Add(new ProductSearchQuery(keywords, productsReturned));\r\n\r\n                _logger.LogInformation(\"Encontrados {Count} produtos para as keywords\", foundMatches.Count);\r\n\r\n                if (foundMatches.Count == 0)\r\n                {\r\n                    return \"Nenhum produto encontrado para as palavras-chave fornecidas.\";\r\n                }\r\n\r\n                var sb = new StringBuilder();\r\n                sb.AppendLine($\"Encontrados {foundMatches.Count} produtos (ordenados por percentual de acerto):\");\r\n                foreach (var match in foundMatches)\r\n                {\r\n                    sb.AppendLine($\"- Código: {match.Product.Code} | Nome: {match.Product.Name} | Acerto: {match.MatchPercentage}%\");\r\n                }\r\n                return sb.ToString();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                _logger.LogError(ex, \"Erro ao processar chamada search_products\");\r\n                return \"Erro ao buscar produtos.\";\r\n            }\r\n        }\r\n\r\n        private IntentClassificationResult ParseFinalResponse(\r\n            string description,\r\n            string? content,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries,\r\n            List<FunctionCallLogEntry> functionCallLogs)\r\n        {\r\n            var possibleProducts = allFoundProducts\r\n                .Select(p => new ProductCandidate(p.Code, p.Name))\r\n                .ToList();\r\n\r\n            if (string.IsNullOrWhiteSpace(content))\r\n            {\r\n                return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Resposta vazia do modelo.\");\r\n            }\r\n\r\n            var parsed = ParseResponseToDictionary(content);\r\n            if (parsed == null)\r\n            {\r\n                _logger.LogWarning(\"Falha ao interpretar JSON da resposta final\");\r\n                return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Falha ao interpretar JSON da resposta.\");\r\n            }\r\n\r\n            var keywords = ExtractKeywords(parsed);\r\n            var classifiedProducts = ExtractClassifiedProducts(parsed, allFoundProducts);\r\n            var unmatchedProducts = ExtractUnmatchedProducts(parsed);\r\n            var thinking = parsed.TryGetValue(\"log\", out var logVal) ? logVal?.ToString() ?? string.Empty : string.Empty;\r\n            var callings = functionCallLogs\r\n                .Select(e => new FunctionCallLog(e.FunctionName, e.Parameters, e.Result))\r\n                .ToList();\r\n\r\n            var result = new IntentClassificationResult\r\n            {\r\n                Description = description,\r\n                ClassifiedProducts = classifiedProducts,\r\n                Keywords = keywords,\r\n                Log = new ClassificationLog\r\n                {\r\n                    Thinking = thinking,\r\n                    Callings = callings\r\n                },\r\n                PossibleProducts = possibleProducts,\r\n                UnmatchedProducts = unmatchedProducts,\r\n                SearchQueries = searchQueries\r\n            };\r\n\r\n            _logger.LogInformation(\r\n                \"Classificação concluída. {ProductCount} produtos classificados\",\r\n                classifiedProducts.Count);\r\n\r\n            return result;\r\n        }\r\n\r\n        private IReadOnlyList<ClassifiedProduct> ExtractClassifiedProducts(\r\n            Dictionary<string, object>? parsed,\r\n            List<Product> allFoundProducts)\r\n        {\r\n            if (parsed == null) return Array.Empty<ClassifiedProduct>();\r\n\r\n            var result = new List<ClassifiedProduct>();\r\n\r\n            // Try to extract \"classifiedProducts\" array\r\n            if (parsed.TryGetValue(\"classifiedProducts\", out var productsVal) && productsVal is JsonElement jsonArray)\r\n            {\r\n                if (jsonArray.ValueKind == JsonValueKind.Array)\r\n                {\r\n                    foreach (var item in jsonArray.EnumerateArray())\r\n                    {\r\n                        var productCode = item.TryGetProperty(\"productCode\", out var codeEl) ? codeEl.GetString() ?? string.Empty : string.Empty;\r\n                        var productName = item.TryGetProperty(\"productName\", out var nameEl) ? nameEl.GetString() ?? string.Empty : string.Empty;\r\n                        var action = item.TryGetProperty(\"action\", out var actionEl) ? actionEl.GetString() ?? string.Empty : string.Empty;\r\n\r\n                        // If productName is empty, try to get from found products\r\n                        if (string.IsNullOrEmpty(productName) && !string.IsNullOrEmpty(productCode))\r\n                        {\r\n                            productName = allFoundProducts.FirstOrDefault(p => p.Code == productCode)?.Name ?? string.Empty;\r\n                        }\r\n\r\n                        if (!string.IsNullOrEmpty(productCode) || !string.IsNullOrEmpty(productName))\r\n                        {\r\n                            result.Add(new ClassifiedProduct(productCode, productName, action));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Fallback: try legacy single product format\r\n            if (result.Count == 0)\r\n            {\r\n                var action = parsed.TryGetValue(\"action\", out var actionVal) ? actionVal?.ToString() ?? string.Empty : string.Empty;\r\n                var productCode = parsed.TryGetValue(\"product_code\", out var codeVal) ? codeVal?.ToString() ?? string.Empty : string.Empty;\r\n                var productDescription = parsed.TryGetValue(\"productDescription\", out var descVal) ? descVal?.ToString() ?? string.Empty : string.Empty;\r\n\r\n                if (!string.IsNullOrEmpty(productCode) || !string.IsNullOrEmpty(productDescription))\r\n                {\r\n                    result.Add(new ClassifiedProduct(productCode, productDescription, action));\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private IntentClassificationResult CreateEmptyResult(\r\n            string description,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries,\r\n            string logMessage)\r\n        {\r\n            return new IntentClassificationResult\r\n            {\r\n                Description = description,\r\n                ClassifiedProducts = Array.Empty<ClassifiedProduct>(),\r\n                Keywords = Array.Empty<string>(),\r\n                Log = new ClassificationLog\r\n                {\r\n                    Thinking = logMessage,\r\n                    Callings = Array.Empty<FunctionCallLog>()\r\n                },\r\n                PossibleProducts = allFoundProducts\r\n                    .Select(p => new ProductCandidate(p.Code, p.Name))\r\n                    .ToList(),\r\n                SearchQueries = searchQueries\r\n            };\r\n        }\r\n\r\n        private IReadOnlyList<string> ExtractUnmatchedProducts(Dictionary<string, object>? parsed)\r\n        {\r\n            if (parsed == null) return Array.Empty<string>();\r\n\r\n            if (parsed.TryGetValue(\"unmatchedProducts\", out var val) && val is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.Array)\r\n            {\r\n                return jsonElement.EnumerateArray()\r\n                    .Select(e => e.GetString() ?? string.Empty)\r\n                    .Where(s => !string.IsNullOrWhiteSpace(s))\r\n                    .ToList();\r\n            }\r\n\r\n            return Array.Empty<string>();\r\n        }\r\n\r\n        private IReadOnlyList<string> ExtractKeywords(Dictionary<string, object>? parsed)\r\n        {\r\n            if (parsed == null) return Array.Empty<string>();\r\n\r\n            if (parsed.TryGetValue(\"keywords\", out var keyVal) && keyVal != null)\r\n            {\r\n                if (keyVal is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.Array)\r\n                {\r\n                    return jsonElement.EnumerateArray()\r\n                        .Select(e => e.GetString() ?? string.Empty)\r\n                        .Where(s => !string.IsNullOrWhiteSpace(s))\r\n                        .ToList();\r\n                }\r\n\r\n                var str = keyVal.ToString() ?? string.Empty;\r\n                if (!string.IsNullOrWhiteSpace(str))\r\n                {\r\n                    return str.Split(new[] { ',', ';' }, StringSplitOptions.RemoveEmptyEntries)\r\n                        .Select(s => s.Trim())\r\n                        .Where(s => !string.IsNullOrWhiteSpace(s))\r\n                        .ToList();\r\n                }\r\n            }\r\n\r\n            return Array.Empty<string>();\r\n        }\r\n\r\n        private static Dictionary<string, object>? ParseResponseToDictionary(string content)\r\n        {\r\n            if (string.IsNullOrWhiteSpace(content))\r\n                return null;\r\n            try\r\n            {\r\n                content = content.Replace(\"```json\", \"\", StringComparison.OrdinalIgnoreCase)\r\n                                 .Replace(\"```\", \"\", StringComparison.OrdinalIgnoreCase)\r\n                                 .Trim();\r\n                var extractedData = JsonSerializer.Deserialize<Dictionary<string, object>>(content, new JsonSerializerOptions\r\n                {\r\n                    NumberHandling = JsonNumberHandling.AllowReadingFromString\r\n                });\r\n                return extractedData;\r\n            }\r\n            catch { return null; }\r\n        }\r\n\r\n        private class SearchProductsArguments\r\n        {\r\n            [JsonPropertyName(\"keywords\")]\r\n            public string[] Keywords { get; set; } = Array.Empty<string>();\r\n        }\r\n\r\n        private class FunctionCallLogEntry\r\n        {\r\n            public int Iteration { get; set; }\r\n            public string FunctionName { get; set; } = string.Empty;\r\n            public string Parameters { get; set; } = string.Empty;\r\n            public string Result { get; set; } = string.Empty;\r\n        }\r\n    }\r\n}","epoch":67,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs::request_7940bb37-9bec-489b-9854-972e458844d6",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\Models\\IntentClassificationResult.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","scheme":"file"},"requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","content":"using System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace Sky.HubAI.Application.Models\r\n{\r\n    /// <summary>\r\n    /// Strongly-typed result from intent classification operation.\r\n    /// Represents the analyzed intents for multiple products and supporting metadata.\r\n    /// </summary>\r\n    public record IntentClassificationResult\r\n    {\r\n        /// <summary>\r\n        /// Original description text that was analyzed.\r\n        /// </summary>\r\n        public string Description { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of classified products with their respective actions.\r\n        /// Each product identified in the description has its own action (product-add, product-remove, none).\r\n        /// </summary>\r\n        public IReadOnlyList<ClassifiedProduct> ClassifiedProducts { get; init; } = new List<ClassifiedProduct>();\r\n\r\n        /// <summary>\r\n        /// Identified action/intent for the first classified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string Action => ClassifiedProducts.FirstOrDefault()?.Action ?? string.Empty;\r\n\r\n        /// <summary>\r\n        /// Natural language description of the first identified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string ProductDescription => ClassifiedProducts.FirstOrDefault()?.ProductName ?? string.Empty;\r\n\r\n        /// <summary>\r\n        /// Product code of the first identified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string ProductCode => ClassifiedProducts.FirstOrDefault()?.ProductCode ?? string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of keywords extracted from the description.\r\n        /// </summary>\r\n        public IReadOnlyList<string> Keywords { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// Diagnostic log or reasoning from the AI analysis.\r\n        /// </summary>\r\n        public string Log { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of candidate products that were considered during matching.\r\n        /// Each entry contains product code and name.\r\n        /// </summary>\r\n        public IReadOnlyList<ProductCandidate> PossibleProducts { get; init; } = new List<ProductCandidate>();\r\n\r\n        /// <summary>\r\n        /// List of product names mentioned in the description that could not be matched to any product in the catalog.\r\n        /// </summary>\r\n        public IReadOnlyList<string> UnmatchedProducts { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// List of product search queries made by the LLM during function calling.\r\n        /// Contains the keywords searched and the products returned for each query.\r\n        /// </summary>\r\n        public IReadOnlyList<ProductSearchQuery> SearchQueries { get; init; } = new List<ProductSearchQuery>();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Represents a product that was classified with its identified action.\r\n    /// </summary>\r\n    public record ClassifiedProduct(\r\n        string ProductCode,\r\n        string ProductName,\r\n        string Action);\r\n\r\n    /// <summary>\r\n    /// Represents a candidate product during matching.\r\n    /// </summary>\r\n    public record ProductCandidate(\r\n        string ProductCode,\r\n        string ProductName);\r\n\r\n    /// <summary>\r\n    /// Represents a product search query made by the LLM.\r\n    /// Contains the keywords that were searched and the products that were returned.\r\n    /// </summary>\r\n    public record ProductSearchQuery(\r\n        IReadOnlyList<string> Keywords,\r\n        IReadOnlyList<ProductCandidate> ProductsReturned);\r\n\r\n}","epoch":81,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs::request_7940bb37-9bec-489b-9854-972e458844d6",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\Contracts\\IntentClassifications\\IntentClassificationsResponse.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","scheme":"file"},"requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","content":"using System.Collections.Generic;\r\n\r\nnamespace Sky.HubAI.Api.Contracts.IntentClassifications\r\n{\r\n    /// <summary>\r\n    /// Response contract for intent classification operations.\r\n    /// Contains analyzed intents for multiple products and supporting metadata.\r\n    /// </summary>\r\n    public record IntentClassificationsResponse\r\n    {\r\n        /// <summary>\r\n        /// Original description text that was analyzed.\r\n        /// </summary>\r\n        public string Description { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of classified products with their respective actions.\r\n        /// Each product identified in the description has its own action (product-add, product-remove, none).\r\n        /// </summary>\r\n        public IReadOnlyList<ClassifiedProductResponse> ClassifiedProducts { get; init; } = new List<ClassifiedProductResponse>();\r\n\r\n        /// <summary>\r\n        /// Identified action/intent for the first product (e.g., \"product-add\", \"product-remove\").\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string Action { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// Natural language description of the first identified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string ProductDescription { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// Product code of the first identified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string ProductCode { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of keywords extracted from the description.\r\n        /// </summary>\r\n        public IReadOnlyList<string> Keywords { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// Diagnostic log or reasoning from the AI analysis.\r\n        /// </summary>\r\n        public string Log { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of product names mentioned in the description that could not be matched to any product in the catalog.\r\n        /// </summary>\r\n        public IReadOnlyList<string> UnmatchedProducts { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// List of product search queries made by the LLM during function calling.\r\n        /// Contains the keywords searched and the products returned for each query.\r\n        /// </summary>\r\n        public IReadOnlyList<ProductSearchQueryResponse> SearchQueries { get; init; } = new List<ProductSearchQueryResponse>();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Represents a classified product with its identified action.\r\n    /// </summary>\r\n    public record ClassifiedProductResponse(\r\n        string ProductCode,\r\n        string ProductName,\r\n        string Action);\r\n\r\n    /// <summary>\r\n    /// Represents a product search query made by the LLM.\r\n    /// </summary>\r\n    public record ProductSearchQueryResponse(\r\n        IReadOnlyList<string> Keywords,\r\n        IReadOnlyList<ProductCandidateResponse> ProductsReturned);\r\n\r\n    /// <summary>\r\n    /// Represents a candidate product.\r\n    /// </summary>\r\n    public record ProductCandidateResponse(\r\n        string ProductCode,\r\n        string ProductName);\r\n\r\n}","epoch":82,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Mappings/IntentClassificationMappingExtensions.cs::request_7940bb37-9bec-489b-9854-972e458844d6",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\Mappings\\IntentClassificationMappingExtensions.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Mappings/IntentClassificationMappingExtensions.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/Mappings/IntentClassificationMappingExtensions.cs","scheme":"file"},"requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","content":"using Sky.HubAI.Api.Contracts.IntentClassifications;\r\nusing Sky.HubAI.Application.Models;\r\nusing System.Linq;\r\n\r\nnamespace Sky.HubAI.Api.Mappings\r\n{\r\n    public static class IntentClassificationMappingExtensions\r\n    {\r\n        /// <summary>\r\n        /// Maps IntentClassificationResult (Application layer) to IntentClassificationsResponse (API contract).\r\n        /// </summary>\r\n        public static IntentClassificationsResponse ToResponse(this IntentClassificationResult result)\r\n        {\r\n            return new IntentClassificationsResponse\r\n            {\r\n                Description = result.Description,\r\n                ClassifiedProducts = result.ClassifiedProducts\r\n                    .Select(p => new ClassifiedProductResponse(p.ProductCode, p.ProductName, p.Action))\r\n                    .ToList(),\r\n                Action = result.Action,\r\n                ProductDescription = result.ProductDescription,\r\n                ProductCode = result.ProductCode,\r\n                Keywords = result.Keywords,\r\n                Log = result.Log,\r\n                UnmatchedProducts = result.UnmatchedProducts,\r\n                SearchQueries = result.SearchQueries\r\n                    .Select(q => new ProductSearchQueryResponse(\r\n                        q.Keywords,\r\n                        q.ProductsReturned\r\n                            .Select(p => new ProductCandidateResponse(p.ProductCode, p.ProductName))\r\n                            .ToList()))\r\n                    .ToList()\r\n            };\r\n        }\r\n    }\r\n}","epoch":83,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs::request_7940bb37-9bec-489b-9854-972e458844d6",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","content":"using Azure;\r\nusing Azure.AI.OpenAI;\r\nusing Microsoft.Extensions.Logging;\r\nusing Microsoft.Extensions.Options;\r\nusing OpenAI.Chat;\r\nusing Sky.HubAI.Application.Abstractions;\r\nusing Sky.HubAI.Application.Models;\r\nusing Sky.HubAI.Domain.Entities;\r\nusing Sky.HubAI.Infrastructure.OpenAI.Prompts;\r\nusing Sky.HubAI.Infrastructure.OpenAI.Settings;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Sky.HubAI.Infrastructure.OpenAI.Services\r\n{\r\n    public class OpenAiIntentClassifyService : IOpenAiIntentClassifyService\r\n    {\r\n        private readonly AzureOpenAiSettings _settings;\r\n        private readonly AzureOpenAIClient _client;\r\n        private readonly ILogger<OpenAiIntentClassifyService> _logger;\r\n\r\n        private const string SearchProductsToolName = \"search_products\";\r\n        private const int MaxFunctionCallingIterations = 5;\r\n\r\n        public OpenAiIntentClassifyService(\r\n            IOptions<AzureOpenAiSettings> settings,\r\n            ILogger<OpenAiIntentClassifyService> logger)\r\n        {\r\n            _settings = settings.Value;\r\n            _client = new AzureOpenAIClient(new Uri(_settings.Endpoint), new AzureKeyCredential(_settings.ApiKey));\r\n            _logger = logger;\r\n        }\r\n\r\n        public async Task<IntentClassificationResult> ClassifyIntentAsync(\r\n            string description,\r\n            Func<string[], IReadOnlyList<ProductMatchResult>> productSearchFunction,\r\n            CancellationToken cancellationToken = default)\r\n        {\r\n            _logger.LogInformation(\"Iniciando classificação de intenção com function calling\");\r\n\r\n            var chatClient = _client.GetChatClient(_settings.DeploymentName);\r\n            var systemPrompt = TextClassificationPrompt.GetSystemPrompt();\r\n            var allFoundProducts = new List<Product>();\r\n            var searchQueries = new List<ProductSearchQuery>();\r\n\r\n            var messages = new List<ChatMessage>\r\n            {\r\n                new SystemChatMessage(systemPrompt),\r\n                new UserChatMessage(description)\r\n            };\r\n\r\n            var tools = new List<ChatTool> { CreateSearchProductsTool() };\r\n            var chatOptions = new ChatCompletionOptions\r\n            {\r\n                Tools = { tools[0] }\r\n            };\r\n\r\n            // Function calling loop\r\n            for (int iteration = 0; iteration < MaxFunctionCallingIterations; iteration++)\r\n            {\r\n                var response = await chatClient.CompleteChatAsync(messages, chatOptions, cancellationToken);\r\n                var chatCompletion = response?.Value;\r\n\r\n                if (chatCompletion == null)\r\n                {\r\n                    _logger.LogWarning(\"Modelo OpenAI retornou resposta vazia na iteração {Iteration}\", iteration);\r\n                    break;\r\n                }\r\n\r\n                // Check if the model wants to call a tool\r\n                if (chatCompletion.FinishReason == ChatFinishReason.ToolCalls)\r\n                {\r\n                    _logger.LogInformation(\"LLM solicitou chamada de ferramenta na iteração {Iteration}\", iteration);\r\n\r\n                    // Add assistant message with tool calls\r\n                    messages.Add(new AssistantChatMessage(chatCompletion));\r\n\r\n                    // Process each tool call\r\n                    foreach (var toolCall in chatCompletion.ToolCalls)\r\n                    {\r\n                        if (toolCall.FunctionName == SearchProductsToolName)\r\n                        {\r\n                            var toolResult = ProcessSearchProductsCall(toolCall, productSearchFunction, allFoundProducts, searchQueries);\r\n                            messages.Add(new ToolChatMessage(toolCall.Id, toolResult));\r\n                        }\r\n                        else\r\n                        {\r\n                            _logger.LogWarning(\"Ferramenta desconhecida solicitada: {ToolName}\", toolCall.FunctionName);\r\n                            messages.Add(new ToolChatMessage(toolCall.Id, \"Ferramenta não reconhecida.\"));\r\n                        }\r\n                    }\r\n\r\n                    continue; // Continue loop to get final response\r\n                }\r\n\r\n                // Final response - parse classification\r\n                if (chatCompletion.FinishReason == ChatFinishReason.Stop)\r\n                {\r\n                    var contentItems = chatCompletion.Content;\r\n                    if (contentItems == null || contentItems.Count == 0)\r\n                    {\r\n                        _logger.LogWarning(\"Resposta final sem conteúdo\");\r\n                        break;\r\n                    }\r\n\r\n                    var content = contentItems[0].Text;\r\n                    _logger.LogDebug(\"Resposta final da OpenAI: {ContentLength} caracteres\", content?.Length ?? 0);\r\n\r\n                    return ParseFinalResponse(description, content, allFoundProducts, searchQueries);\r\n                }\r\n\r\n                _logger.LogWarning(\"Finish reason inesperado: {FinishReason}\", chatCompletion.FinishReason);\r\n                break;\r\n            }\r\n\r\n            // Fallback if loop exhausted\r\n            _logger.LogWarning(\"Loop de function calling esgotado sem resposta final\");\r\n            return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Não foi possível obter classificação após múltiplas tentativas.\");\r\n        }\r\n\r\n        private ChatTool CreateSearchProductsTool()\r\n        {\r\n            return ChatTool.CreateFunctionTool(\r\n                functionName: SearchProductsToolName,\r\n                functionDescription: \"Busca produtos no catálogo por palavras-chave. Retorna produtos com percentual de acerto (%). Use esta ferramenta para encontrar produtos mencionados no texto do usuário. IMPORTANTE: Primeiro busque o nome completo/combinado. Se nenhum resultado tiver acerto >= 80%, busque cada produto separadamente. Inclua variações e abreviações expandidas nas keywords (ex: DEG → DEGUSTAÇÃO).\",\r\n                functionParameters: BinaryData.FromString(\"\"\"\r\n                {\r\n                    \"type\": \"object\",\r\n                    \"properties\": {\r\n                        \"keywords\": {\r\n                            \"type\": \"array\",\r\n                            \"items\": { \"type\": \"string\" },\r\n                            \"description\": \"Lista de palavras-chave ou termos para buscar produtos. Para melhores resultados: use o nome completo do produto, variações com abreviações expandidas (DEG→DEGUSTAÇÃO, PROMO→PROMOÇÃO), e termos parciais. Pode incluir nomes combinados (ex: 'PROMO SUPER 30D + DEG HBO 30D') para verificar se existe como produto único. Os resultados incluem percentual de acerto (%).\"\r\n                        }\r\n                    },\r\n                    \"required\": [\"keywords\"]\r\n                }\r\n                \"\"\"));\r\n        }\r\n\r\n        private string ProcessSearchProductsCall(\r\n            ChatToolCall toolCall,\r\n            Func<string[], IReadOnlyList<ProductMatchResult>> productSearchFunction,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries)\r\n        {\r\n            try\r\n            {\r\n                var arguments = JsonSerializer.Deserialize<SearchProductsArguments>(toolCall.FunctionArguments);\r\n                var keywords = arguments?.Keywords ?? Array.Empty<string>();\r\n\r\n                _logger.LogInformation(\"Buscando produtos com keywords: {Keywords}\", string.Join(\", \", keywords));\r\n\r\n                var foundMatches = productSearchFunction(keywords);\r\n                allFoundProducts.AddRange(foundMatches\r\n                    .Where(m => !allFoundProducts.Any(ap => ap.Code == m.Product.Code))\r\n                    .Select(m => m.Product));\r\n\r\n                // Registrar a busca realizada (keywords + produtos retornados)\r\n                var productsReturned = foundMatches\r\n                    .Select(m => new ProductCandidate(m.Product.Code, m.Product.Name))\r\n                    .ToList();\r\n                searchQueries.Add(new ProductSearchQuery(keywords, productsReturned));\r\n\r\n                _logger.LogInformation(\"Encontrados {Count} produtos para as keywords\", foundMatches.Count);\r\n\r\n                if (foundMatches.Count == 0)\r\n                {\r\n                    return \"Nenhum produto encontrado para as palavras-chave fornecidas.\";\r\n                }\r\n\r\n                var sb = new StringBuilder();\r\n                sb.AppendLine($\"Encontrados {foundMatches.Count} produtos (ordenados por percentual de acerto):\");\r\n                foreach (var match in foundMatches)\r\n                {\r\n                    sb.AppendLine($\"- Código: {match.Product.Code} | Nome: {match.Product.Name} | Acerto: {match.MatchPercentage}%\");\r\n                }\r\n                return sb.ToString();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                _logger.LogError(ex, \"Erro ao processar chamada search_products\");\r\n                return \"Erro ao buscar produtos.\";\r\n            }\r\n        }\r\n\r\n        private IntentClassificationResult ParseFinalResponse(\r\n            string description,\r\n            string? content,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries)\r\n        {\r\n            var possibleProducts = allFoundProducts\r\n                .Select(p => new ProductCandidate(p.Code, p.Name))\r\n                .ToList();\r\n\r\n            if (string.IsNullOrWhiteSpace(content))\r\n            {\r\n                return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Resposta vazia do modelo.\");\r\n            }\r\n\r\n            var parsed = ParseResponseToDictionary(content);\r\n            if (parsed == null)\r\n            {\r\n                _logger.LogWarning(\"Falha ao interpretar JSON da resposta final\");\r\n                return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Falha ao interpretar JSON da resposta.\");\r\n            }\r\n\r\n            var keywords = ExtractKeywords(parsed);\r\n            var classifiedProducts = ExtractClassifiedProducts(parsed, allFoundProducts);\r\n            var unmatchedProducts = ExtractUnmatchedProducts(parsed);\r\n            var log = parsed.TryGetValue(\"log\", out var logVal) ? logVal?.ToString() ?? string.Empty : string.Empty;\r\n\r\n            var result = new IntentClassificationResult\r\n            {\r\n                Description = description,\r\n                ClassifiedProducts = classifiedProducts,\r\n                Keywords = keywords,\r\n                Log = log,\r\n                PossibleProducts = possibleProducts,\r\n                UnmatchedProducts = unmatchedProducts,\r\n                SearchQueries = searchQueries\r\n            };\r\n\r\n            _logger.LogInformation(\r\n                \"Classificação concluída. {ProductCount} produtos classificados\",\r\n                classifiedProducts.Count);\r\n\r\n            return result;\r\n        }\r\n\r\n        private IReadOnlyList<ClassifiedProduct> ExtractClassifiedProducts(\r\n            Dictionary<string, object>? parsed,\r\n            List<Product> allFoundProducts)\r\n        {\r\n            if (parsed == null) return Array.Empty<ClassifiedProduct>();\r\n\r\n            var result = new List<ClassifiedProduct>();\r\n\r\n            // Try to extract \"classifiedProducts\" array\r\n            if (parsed.TryGetValue(\"classifiedProducts\", out var productsVal) && productsVal is JsonElement jsonArray)\r\n            {\r\n                if (jsonArray.ValueKind == JsonValueKind.Array)\r\n                {\r\n                    foreach (var item in jsonArray.EnumerateArray())\r\n                    {\r\n                        var productCode = item.TryGetProperty(\"productCode\", out var codeEl) ? codeEl.GetString() ?? string.Empty : string.Empty;\r\n                        var productName = item.TryGetProperty(\"productName\", out var nameEl) ? nameEl.GetString() ?? string.Empty : string.Empty;\r\n                        var action = item.TryGetProperty(\"action\", out var actionEl) ? actionEl.GetString() ?? string.Empty : string.Empty;\r\n\r\n                        // If productName is empty, try to get from found products\r\n                        if (string.IsNullOrEmpty(productName) && !string.IsNullOrEmpty(productCode))\r\n                        {\r\n                            productName = allFoundProducts.FirstOrDefault(p => p.Code == productCode)?.Name ?? string.Empty;\r\n                        }\r\n\r\n                        if (!string.IsNullOrEmpty(productCode) || !string.IsNullOrEmpty(productName))\r\n                        {\r\n                            result.Add(new ClassifiedProduct(productCode, productName, action));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Fallback: try legacy single product format\r\n            if (result.Count == 0)\r\n            {\r\n                var action = parsed.TryGetValue(\"action\", out var actionVal) ? actionVal?.ToString() ?? string.Empty : string.Empty;\r\n                var productCode = parsed.TryGetValue(\"product_code\", out var codeVal) ? codeVal?.ToString() ?? string.Empty : string.Empty;\r\n                var productDescription = parsed.TryGetValue(\"productDescription\", out var descVal) ? descVal?.ToString() ?? string.Empty : string.Empty;\r\n\r\n                if (!string.IsNullOrEmpty(productCode) || !string.IsNullOrEmpty(productDescription))\r\n                {\r\n                    result.Add(new ClassifiedProduct(productCode, productDescription, action));\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private IntentClassificationResult CreateEmptyResult(\r\n            string description,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries,\r\n            string logMessage)\r\n        {\r\n            return new IntentClassificationResult\r\n            {\r\n                Description = description,\r\n                ClassifiedProducts = Array.Empty<ClassifiedProduct>(),\r\n                Keywords = Array.Empty<string>(),\r\n                Log = logMessage,\r\n                PossibleProducts = allFoundProducts\r\n                    .Select(p => new ProductCandidate(p.Code, p.Name))\r\n                    .ToList(),\r\n                SearchQueries = searchQueries\r\n            };\r\n        }\r\n\r\n        private IReadOnlyList<string> ExtractUnmatchedProducts(Dictionary<string, object>? parsed)\r\n        {\r\n            if (parsed == null) return Array.Empty<string>();\r\n\r\n            if (parsed.TryGetValue(\"unmatchedProducts\", out var val) && val is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.Array)\r\n            {\r\n                return jsonElement.EnumerateArray()\r\n                    .Select(e => e.GetString() ?? string.Empty)\r\n                    .Where(s => !string.IsNullOrWhiteSpace(s))\r\n                    .ToList();\r\n            }\r\n\r\n            return Array.Empty<string>();\r\n        }\r\n\r\n        private IReadOnlyList<string> ExtractKeywords(Dictionary<string, object>? parsed)\r\n        {\r\n            if (parsed == null) return Array.Empty<string>();\r\n\r\n            if (parsed.TryGetValue(\"keywords\", out var keyVal) && keyVal != null)\r\n            {\r\n                if (keyVal is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.Array)\r\n                {\r\n                    return jsonElement.EnumerateArray()\r\n                        .Select(e => e.GetString() ?? string.Empty)\r\n                        .Where(s => !string.IsNullOrWhiteSpace(s))\r\n                        .ToList();\r\n                }\r\n\r\n                var str = keyVal.ToString() ?? string.Empty;\r\n                if (!string.IsNullOrWhiteSpace(str))\r\n                {\r\n                    return str.Split(new[] { ',', ';' }, StringSplitOptions.RemoveEmptyEntries)\r\n                        .Select(s => s.Trim())\r\n                        .Where(s => !string.IsNullOrWhiteSpace(s))\r\n                        .ToList();\r\n                }\r\n            }\r\n\r\n            return Array.Empty<string>();\r\n        }\r\n\r\n        private static Dictionary<string, object>? ParseResponseToDictionary(string content)\r\n        {\r\n            if (string.IsNullOrWhiteSpace(content))\r\n                return null;\r\n            try\r\n            {\r\n                content = content.Replace(\"```json\", \"\", StringComparison.OrdinalIgnoreCase)\r\n                                 .Replace(\"```\", \"\", StringComparison.OrdinalIgnoreCase)\r\n                                 .Trim();\r\n                var extractedData = JsonSerializer.Deserialize<Dictionary<string, object>>(content, new JsonSerializerOptions\r\n                {\r\n                    NumberHandling = JsonNumberHandling.AllowReadingFromString\r\n                });\r\n                return extractedData;\r\n            }\r\n            catch { return null; }\r\n        }\r\n\r\n        private class SearchProductsArguments\r\n        {\r\n            [JsonPropertyName(\"keywords\")]\r\n            public string[] Keywords { get; set; } = Array.Empty<string>();\r\n        }\r\n    }\r\n}","epoch":84,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs::request_7940bb37-9bec-489b-9854-972e458844d6",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\UseCases\\Intent\\ClassifyIntent\\ClassifyIntentQueryHandler.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs","scheme":"file"},"requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","content":"using MediatR;\r\nusing Microsoft.Extensions.Logging;\r\nusing Sky.HubAI.Application.Abstractions;\r\nusing Sky.HubAI.Application.Models;\r\nusing Sky.HubAI.Domain.Services.Interfaces;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Sky.HubAI.Application.UseCases.Intent.ClassifyIntent\r\n{\r\n    /// <summary>\r\n    /// Use case handler for classifying user intent from text descriptions.\r\n    /// Orchestrates: product search via function calling, calling AI service, normalizing results.\r\n    /// </summary>\r\n    public class ClassifyIntentQueryHandler : IRequestHandler<ClassifyIntentQuery, ClassifyIntentResult>\r\n    {\r\n        private readonly IOpenAiIntentClassifyService _openAiService;\r\n        private readonly IProductMemoryCacheService _productCache;\r\n        private readonly IProductMatchingService _productMatching;\r\n        private readonly ILogger<ClassifyIntentQueryHandler> _logger;\r\n\r\n        private const int TopCandidatesPerKeyword = 10;\r\n\r\n        public ClassifyIntentQueryHandler(\r\n            IOpenAiIntentClassifyService openAiService,\r\n            IProductMemoryCacheService productCache,\r\n            IProductMatchingService productMatching,\r\n            ILogger<ClassifyIntentQueryHandler> logger)\r\n        {\r\n            _openAiService = openAiService;\r\n            _productCache = productCache;\r\n            _productMatching = productMatching;\r\n            _logger = logger;\r\n        }\r\n\r\n        public async Task<ClassifyIntentResult> Handle(ClassifyIntentQuery request, CancellationToken cancellationToken)\r\n        {\r\n            _logger.LogInformation(\r\n                \"Iniciando análise de intenção. Descrição: {DescriptionLength} caracteres\",\r\n                request.Description?.Length ?? 0);\r\n\r\n            // 1. Buscar todos os produtos do cache (para uso na função de busca)\r\n            var allProducts = _productCache.GetAllProducts();\r\n            _logger.LogInformation(\"Produtos carregados do cache: {ProductCount}\", allProducts.Count);\r\n\r\n            // 2. Criar função de busca para function calling\r\n            // Esta função será chamada pela LLM quando precisar buscar produtos\r\n            IReadOnlyList<Domain.Entities.ProductMatchResult> SearchProducts(string[] keywords)\r\n            {\r\n                _logger.LogInformation(\"Function calling: buscando produtos com keywords: {Keywords}\", \r\n                    string.Join(\", \", keywords));\r\n\r\n                var results = new List<Domain.Entities.ProductMatchResult>();\r\n                foreach (var keyword in keywords)\r\n                {\r\n                    var matches = _productMatching.FindTopMatchingProductsWithScore(\r\n                        allProducts,\r\n                        keyword,\r\n                        TopCandidatesPerKeyword);\r\n                    \r\n                    // Adicionar apenas produtos não duplicados\r\n                    foreach (var match in matches)\r\n                    {\r\n                        if (!results.Any(r => r.Product.Code == match.Product.Code))\r\n                        {\r\n                            results.Add(match);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                _logger.LogInformation(\"Function calling: encontrados {Count} produtos únicos\", results.Count);\r\n                return results;\r\n            }\r\n\r\n            // 3. Chamar serviço de IA com function calling\r\n            var classificationResult = await _openAiService.ClassifyIntentAsync(\r\n                request.Description,\r\n                SearchProducts,\r\n                cancellationToken);\r\n\r\n            // 4. Normalizar ações de todos os produtos classificados (regra de aplicação)\r\n            var normalizedProducts = classificationResult.ClassifiedProducts\r\n                .Select(p => new ClassifiedProduct(\r\n                    p.ProductCode,\r\n                    p.ProductName,\r\n                    NormalizeAction(p.Action)))\r\n                .ToList();\r\n\r\n            // 5. Construir resultado final\r\n            var result = new ClassifyIntentResult(new IntentClassificationResult\r\n            {\r\n                Description = classificationResult.Description,\r\n                ClassifiedProducts = normalizedProducts,\r\n                Keywords = classificationResult.Keywords,\r\n                Log = classificationResult.Log,\r\n                PossibleProducts = classificationResult.PossibleProducts,\r\n                UnmatchedProducts = classificationResult.UnmatchedProducts,\r\n                SearchQueries = classificationResult.SearchQueries\r\n            });\r\n\r\n            _logger.LogInformation(\r\n                \"Classificação concluída. {ProductCount} produtos classificados. Primeiro: Action={Action}, ProductCode={ProductCode}\",\r\n                result.Data.ClassifiedProducts.Count,\r\n                result.Data.Action,\r\n                result.Data.ProductCode);\r\n\r\n            return result;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Normalizes action names to standardized values.\r\n        /// Application-level business rule for consistency.\r\n        /// </summary>\r\n        private static string NormalizeAction(string action)\r\n        {\r\n            if (string.IsNullOrWhiteSpace(action))\r\n                return string.Empty;\r\n\r\n            var normalized = action.Trim().ToLowerInvariant();\r\n\r\n            // Mapeia ações conhecidas\r\n            return normalized switch\r\n            {\r\n                \"product-add\" or \"inclusão\" or \"incluir\" or \"adicionar\" or \"ativação\" or \"liberação\" => \"product-add\",\r\n                \"product-remove\" or \"cancelamento\" or \"cancelar\" or \"retirada\" or \"excluir\" or \"exclusão\" => \"product-remove\",\r\n                \"none\" => \"none\",\r\n                _ => string.Empty\r\n            };\r\n        }\r\n    }\r\n}","epoch":85,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs::request_c461a1a3-4de4-4857-825f-ce170dca8e15",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","content":"using Azure;\r\nusing Azure.AI.OpenAI;\r\nusing Microsoft.Extensions.Logging;\r\nusing Microsoft.Extensions.Options;\r\nusing OpenAI.Chat;\r\nusing Sky.HubAI.Application.Abstractions;\r\nusing Sky.HubAI.Application.Models;\r\nusing Sky.HubAI.Domain.Entities;\r\nusing Sky.HubAI.Infrastructure.OpenAI.Prompts;\r\nusing Sky.HubAI.Infrastructure.OpenAI.Settings;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Sky.HubAI.Infrastructure.OpenAI.Services\r\n{\r\n    public class OpenAiIntentClassifyService : IOpenAiIntentClassifyService\r\n    {\r\n        private readonly AzureOpenAiSettings _settings;\r\n        private readonly AzureOpenAIClient _client;\r\n        private readonly ILogger<OpenAiIntentClassifyService> _logger;\r\n\r\n        private const string SearchProductsToolName = \"search_products\";\r\n        private const int MaxFunctionCallingIterations = 5;\r\n\r\n        public OpenAiIntentClassifyService(\r\n            IOptions<AzureOpenAiSettings> settings,\r\n            ILogger<OpenAiIntentClassifyService> logger)\r\n        {\r\n            _settings = settings.Value;\r\n            _client = new AzureOpenAIClient(new Uri(_settings.Endpoint), new AzureKeyCredential(_settings.ApiKey));\r\n            _logger = logger;\r\n        }\r\n\r\n        public async Task<IntentClassificationResult> ClassifyIntentAsync(\r\n            string description,\r\n            Func<string[], IReadOnlyList<ProductMatchResult>> productSearchFunction,\r\n            CancellationToken cancellationToken = default)\r\n        {\r\n            _logger.LogInformation(\"Iniciando classificação de intenção com function calling\");\r\n\r\n            var chatClient = _client.GetChatClient(_settings.DeploymentName);\r\n            var systemPrompt = TextClassificationPrompt.GetSystemPrompt();\r\n            var allFoundProducts = new List<Product>();\r\n            var searchQueries = new List<ProductSearchQuery>();\r\n\r\n            var messages = new List<ChatMessage>\r\n            {\r\n                new SystemChatMessage(systemPrompt),\r\n                new UserChatMessage(description)\r\n            };\r\n\r\n            var tools = new List<ChatTool> { CreateSearchProductsTool() };\r\n            var chatOptions = new ChatCompletionOptions\r\n            {\r\n                Tools = { tools[0] }\r\n            };\r\n\r\n            // Function calling loop\r\n            for (int iteration = 0; iteration < MaxFunctionCallingIterations; iteration++)\r\n            {\r\n                var response = await chatClient.CompleteChatAsync(messages, chatOptions, cancellationToken);\r\n                var chatCompletion = response?.Value;\r\n\r\n                if (chatCompletion == null)\r\n                {\r\n                    _logger.LogWarning(\"Modelo OpenAI retornou resposta vazia na iteração {Iteration}\", iteration);\r\n                    break;\r\n                }\r\n\r\n                // Check if the model wants to call a tool\r\n                if (chatCompletion.FinishReason == ChatFinishReason.ToolCalls)\r\n                {\r\n                    _logger.LogInformation(\"LLM solicitou chamada de ferramenta na iteração {Iteration}\", iteration);\r\n\r\n                    // Add assistant message with tool calls\r\n                    messages.Add(new AssistantChatMessage(chatCompletion));\r\n\r\n                    // Process each tool call\r\n                    foreach (var toolCall in chatCompletion.ToolCalls)\r\n                    {\r\n                        if (toolCall.FunctionName == SearchProductsToolName)\r\n                        {\r\n                            var toolResult = ProcessSearchProductsCall(toolCall, productSearchFunction, allFoundProducts, searchQueries);\r\n                            messages.Add(new ToolChatMessage(toolCall.Id, toolResult));\r\n                        }\r\n                        else\r\n                        {\r\n                            _logger.LogWarning(\"Ferramenta desconhecida solicitada: {ToolName}\", toolCall.FunctionName);\r\n                            messages.Add(new ToolChatMessage(toolCall.Id, \"Ferramenta não reconhecida.\"));\r\n                        }\r\n                    }\r\n\r\n                    continue; // Continue loop to get final response\r\n                }\r\n\r\n                // Final response - parse classification\r\n                if (chatCompletion.FinishReason == ChatFinishReason.Stop)\r\n                {\r\n                    var contentItems = chatCompletion.Content;\r\n                    if (contentItems == null || contentItems.Count == 0)\r\n                    {\r\n                        _logger.LogWarning(\"Resposta final sem conteúdo\");\r\n                        break;\r\n                    }\r\n\r\n                    var content = contentItems[0].Text;\r\n                    _logger.LogDebug(\"Resposta final da OpenAI: {ContentLength} caracteres\", content?.Length ?? 0);\r\n\r\n                    return ParseFinalResponse(description, content, allFoundProducts, searchQueries);\r\n                }\r\n\r\n                _logger.LogWarning(\"Finish reason inesperado: {FinishReason}\", chatCompletion.FinishReason);\r\n                break;\r\n            }\r\n\r\n            // Fallback if loop exhausted\r\n            _logger.LogWarning(\"Loop de function calling esgotado sem resposta final\");\r\n            return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Não foi possível obter classificação após múltiplas tentativas.\");\r\n        }\r\n\r\n        private ChatTool CreateSearchProductsTool()\r\n        {\r\n            return ChatTool.CreateFunctionTool(\r\n                functionName: SearchProductsToolName,\r\n                functionDescription: \"Busca produtos no catálogo por palavras-chave. Retorna produtos com percentual de acerto (%). Use esta ferramenta para encontrar produtos mencionados no texto do usuário. IMPORTANTE: Primeiro busque o nome completo/combinado. Se nenhum resultado tiver acerto >= 80%, busque cada produto separadamente. Inclua variações e abreviações expandidas nas keywords (ex: DEG → DEGUSTAÇÃO).\",\r\n                functionParameters: BinaryData.FromString(\"\"\"\r\n                {\r\n                    \"type\": \"object\",\r\n                    \"properties\": {\r\n                        \"keywords\": {\r\n                            \"type\": \"array\",\r\n                            \"items\": { \"type\": \"string\" },\r\n                            \"description\": \"Lista de palavras-chave ou termos para buscar produtos. Para melhores resultados: use o nome completo do produto, variações com abreviações expandidas (DEG→DEGUSTAÇÃO, PROMO→PROMOÇÃO), e termos parciais. Pode incluir nomes combinados (ex: 'PROMO SUPER 30D + DEG HBO 30D') para verificar se existe como produto único. Os resultados incluem percentual de acerto (%).\"\r\n                        }\r\n                    },\r\n                    \"required\": [\"keywords\"]\r\n                }\r\n                \"\"\"));\r\n        }\r\n\r\n        private string ProcessSearchProductsCall(\r\n            ChatToolCall toolCall,\r\n            Func<string[], IReadOnlyList<ProductMatchResult>> productSearchFunction,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries)\r\n        {\r\n            try\r\n            {\r\n                var arguments = JsonSerializer.Deserialize<SearchProductsArguments>(toolCall.FunctionArguments);\r\n                var keywords = arguments?.Keywords ?? Array.Empty<string>();\r\n\r\n                _logger.LogInformation(\"Buscando produtos com keywords: {Keywords}\", string.Join(\", \", keywords));\r\n\r\n                var foundMatches = productSearchFunction(keywords);\r\n\r\n                // Somente considerar produtos com mais de 80% de match\r\n                var qualifiedMatches = foundMatches\r\n                    .Where(m => m.MatchPercentage > 80)\r\n                    .ToList();\r\n\r\n                allFoundProducts.AddRange(qualifiedMatches\r\n                    .Where(m => !allFoundProducts.Any(ap => ap.Code == m.Product.Code))\r\n                    .Select(m => m.Product));\r\n\r\n                // Registrar a busca realizada (keywords + TODOS os produtos retornados com percentual)\r\n                var productsReturned = foundMatches\r\n                    .Select(m => new ProductCandidate(m.Product.Code, m.Product.Name, m.MatchPercentage))\r\n                    .ToList();\r\n                searchQueries.Add(new ProductSearchQuery(keywords, productsReturned));\r\n\r\n                _logger.LogInformation(\"Encontrados {Count} produtos para as keywords\", foundMatches.Count);\r\n\r\n                if (foundMatches.Count == 0)\r\n                {\r\n                    return \"Nenhum produto encontrado para as palavras-chave fornecidas.\";\r\n                }\r\n\r\n                var sb = new StringBuilder();\r\n                sb.AppendLine($\"Encontrados {foundMatches.Count} produtos (ordenados por percentual de acerto):\");\r\n                foreach (var match in foundMatches)\r\n                {\r\n                    sb.AppendLine($\"- Código: {match.Product.Code} | Nome: {match.Product.Name} | Acerto: {match.MatchPercentage}%\");\r\n                }\r\n                return sb.ToString();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                _logger.LogError(ex, \"Erro ao processar chamada search_products\");\r\n                return \"Erro ao buscar produtos.\";\r\n            }\r\n        }\r\n\r\n        private IntentClassificationResult ParseFinalResponse(\r\n            string description,\r\n            string? content,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries)\r\n        {\r\n            var possibleProducts = allFoundProducts\r\n                .Select(p => new ProductCandidate(p.Code, p.Name, 0))\r\n                .ToList();\r\n\r\n            // Extrair nomes dos produtos com match > 80% (a partir dos searchQueries)\r\n            var matchedProducts = searchQueries\r\n                .SelectMany(q => q.ProductsReturned)\r\n                .Where(p => p.MatchPercentage > 80)\r\n                .Select(p => p.ProductName)\r\n                .Distinct()\r\n                .ToList();\r\n\r\n            if (string.IsNullOrWhiteSpace(content))\r\n            {\r\n                return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Resposta vazia do modelo.\");\r\n            }\r\n\r\n            var parsed = ParseResponseToDictionary(content);\r\n            if (parsed == null)\r\n            {\r\n                _logger.LogWarning(\"Falha ao interpretar JSON da resposta final\");\r\n                return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Falha ao interpretar JSON da resposta.\");\r\n            }\r\n\r\n            var keywords = ExtractKeywords(parsed);\r\n            var classifiedProducts = ExtractClassifiedProducts(parsed, allFoundProducts);\r\n            var unmatchedProducts = ExtractUnmatchedProducts(parsed);\r\n            var log = parsed.TryGetValue(\"log\", out var logVal) ? logVal?.ToString() ?? string.Empty : string.Empty;\r\n\r\n            var result = new IntentClassificationResult\r\n            {\r\n                Description = description,\r\n                ClassifiedProducts = classifiedProducts,\r\n                Keywords = keywords,\r\n                Log = log,\r\n                PossibleProducts = possibleProducts,\r\n                MatchedProducts = matchedProducts,\r\n                UnmatchedProducts = unmatchedProducts,\r\n                SearchQueries = searchQueries\r\n            };\r\n\r\n            _logger.LogInformation(\r\n                \"Classificação concluída. {ProductCount} produtos classificados\",\r\n                classifiedProducts.Count);\r\n\r\n            return result;\r\n        }\r\n\r\n        private IReadOnlyList<ClassifiedProduct> ExtractClassifiedProducts(\r\n            Dictionary<string, object>? parsed,\r\n            List<Product> allFoundProducts)\r\n        {\r\n            if (parsed == null) return Array.Empty<ClassifiedProduct>();\r\n\r\n            var result = new List<ClassifiedProduct>();\r\n\r\n            // Try to extract \"classifiedProducts\" array\r\n            if (parsed.TryGetValue(\"classifiedProducts\", out var productsVal) && productsVal is JsonElement jsonArray)\r\n            {\r\n                if (jsonArray.ValueKind == JsonValueKind.Array)\r\n                {\r\n                    foreach (var item in jsonArray.EnumerateArray())\r\n                    {\r\n                        var productCode = item.TryGetProperty(\"productCode\", out var codeEl) ? codeEl.GetString() ?? string.Empty : string.Empty;\r\n                        var productName = item.TryGetProperty(\"productName\", out var nameEl) ? nameEl.GetString() ?? string.Empty : string.Empty;\r\n                        var action = item.TryGetProperty(\"action\", out var actionEl) ? actionEl.GetString() ?? string.Empty : string.Empty;\r\n\r\n                        // If productName is empty, try to get from found products\r\n                        if (string.IsNullOrEmpty(productName) && !string.IsNullOrEmpty(productCode))\r\n                        {\r\n                            productName = allFoundProducts.FirstOrDefault(p => p.Code == productCode)?.Name ?? string.Empty;\r\n                        }\r\n\r\n                        if (!string.IsNullOrEmpty(productCode) || !string.IsNullOrEmpty(productName))\r\n                        {\r\n                            result.Add(new ClassifiedProduct(productCode, productName, action));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Fallback: try legacy single product format\r\n            if (result.Count == 0)\r\n            {\r\n                var action = parsed.TryGetValue(\"action\", out var actionVal) ? actionVal?.ToString() ?? string.Empty : string.Empty;\r\n                var productCode = parsed.TryGetValue(\"product_code\", out var codeVal) ? codeVal?.ToString() ?? string.Empty : string.Empty;\r\n                var productDescription = parsed.TryGetValue(\"productDescription\", out var descVal) ? descVal?.ToString() ?? string.Empty : string.Empty;\r\n\r\n                if (!string.IsNullOrEmpty(productCode) || !string.IsNullOrEmpty(productDescription))\r\n                {\r\n                    result.Add(new ClassifiedProduct(productCode, productDescription, action));\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private IntentClassificationResult CreateEmptyResult(\r\n            string description,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries,\r\n            string logMessage)\r\n        {\r\n            return new IntentClassificationResult\r\n            {\r\n                Description = description,\r\n                ClassifiedProducts = Array.Empty<ClassifiedProduct>(),\r\n                Keywords = Array.Empty<string>(),\r\n                Log = logMessage,\r\n                PossibleProducts = allFoundProducts\r\n                    .Select(p => new ProductCandidate(p.Code, p.Name, 0))\r\n                    .ToList(),\r\n                SearchQueries = searchQueries\r\n            };\r\n        }\r\n\r\n        private IReadOnlyList<string> ExtractUnmatchedProducts(Dictionary<string, object>? parsed)\r\n        {\r\n            if (parsed == null) return Array.Empty<string>();\r\n\r\n            if (parsed.TryGetValue(\"unmatchedProducts\", out var val) && val is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.Array)\r\n            {\r\n                return jsonElement.EnumerateArray()\r\n                    .Select(e => e.GetString() ?? string.Empty)\r\n                    .Where(s => !string.IsNullOrWhiteSpace(s))\r\n                    .ToList();\r\n            }\r\n\r\n            return Array.Empty<string>();\r\n        }\r\n\r\n        private IReadOnlyList<string> ExtractKeywords(Dictionary<string, object>? parsed)\r\n        {\r\n            if (parsed == null) return Array.Empty<string>();\r\n\r\n            if (parsed.TryGetValue(\"keywords\", out var keyVal) && keyVal != null)\r\n            {\r\n                if (keyVal is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.Array)\r\n                {\r\n                    return jsonElement.EnumerateArray()\r\n                        .Select(e => e.GetString() ?? string.Empty)\r\n                        .Where(s => !string.IsNullOrWhiteSpace(s))\r\n                        .ToList();\r\n                }\r\n\r\n                var str = keyVal.ToString() ?? string.Empty;\r\n                if (!string.IsNullOrWhiteSpace(str))\r\n                {\r\n                    return str.Split(new[] { ',', ';' }, StringSplitOptions.RemoveEmptyEntries)\r\n                        .Select(s => s.Trim())\r\n                        .Where(s => !string.IsNullOrWhiteSpace(s))\r\n                        .ToList();\r\n                }\r\n            }\r\n\r\n            return Array.Empty<string>();\r\n        }\r\n\r\n        private static Dictionary<string, object>? ParseResponseToDictionary(string content)\r\n        {\r\n            if (string.IsNullOrWhiteSpace(content))\r\n                return null;\r\n            try\r\n            {\r\n                content = content.Replace(\"```json\", \"\", StringComparison.OrdinalIgnoreCase)\r\n                                 .Replace(\"```\", \"\", StringComparison.OrdinalIgnoreCase)\r\n                                 .Trim();\r\n                var extractedData = JsonSerializer.Deserialize<Dictionary<string, object>>(content, new JsonSerializerOptions\r\n                {\r\n                    NumberHandling = JsonNumberHandling.AllowReadingFromString\r\n                });\r\n                return extractedData;\r\n            }\r\n            catch { return null; }\r\n        }\r\n\r\n        private class SearchProductsArguments\r\n        {\r\n            [JsonPropertyName(\"keywords\")]\r\n            public string[] Keywords { get; set; } = Array.Empty<string>();\r\n        }\r\n    }\r\n}","epoch":107,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs::request_c461a1a3-4de4-4857-825f-ce170dca8e15",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","content":"namespace Sky.HubAI.Infrastructure.OpenAI.Prompts\r\n{\r\n    public static class TextClassificationPrompt\r\n    {\r\n        public static string GetSystemPrompt() =>\r\n            @\"Você é um especialista em classificação de ações e produtos a partir de descrições textuais. Possui habilidade em interpretar textos com erros de grafia, identificar intenções implícitas e extrair informações estruturadas com precisão.\r\n\r\n# Task\r\n\r\nAnalisar descrições fornecidas em texto livre e classificar:\r\n(1) a ação a ser tomada para CADA produto mencionado (adição ou remoção);\r\n(2) Identificar o código de TODOS os produtos mencionados.\r\n\r\n# Context\r\n\r\nEste sistema processa solicitações de clientes que podem conter imprecisões ortográficas, palavras escritas em conjunto ou formatação irregular. A classificação precisa alimenta fluxos de trabalho operacionais, tornando a precisão crítica para o roteamento correto de tarefas e gestão de produtos.\r\n\r\n# Instructions\r\n\r\n## 1. Identificação de Produtos\r\n\r\nAnalise a descrição e identifique TODOS os produtos mencionados.\r\n\r\n**IMPORTANTE - Produtos podem estar listados de várias formas:**\r\n- Separados por `+` : \"\"PROMO SUPER 30D + DEG HBO 30D\"\"\r\n- Separados por `,` : \"\"HBO Max, Telecine, Premiere\"\"\r\n- Separados por `e`/`ou` : \"\"HBO e Telecine\"\"\r\n- Em texto corrido: \"\"incluir recarga PROMO SUPER 30D e também DEG HBO\"\"\r\n- Com valores/preços junto: \"\"PROMO SUPER 30D - R$ 89,91\"\"\r\n\r\n### Estratégia de Busca (OBRIGATÓRIA):\r\n\r\nQuando o texto contém termos que PODEM ser um produto único OU múltiplos produtos (ex: \"\"PROMO SUPER 30D + DEG HBO 30D\"\"), siga esta ordem:\r\n\r\n**Passo 1 - Buscar o texto completo/combinado primeiro:**\r\n- Faça `search_products` com o nome completo: ex: [\"\"PROMO SUPER 30D + DEG HBO 30D\"\", \"\"PROMO SUPER 30D DEG HBO 30D\"\"]\r\n- Avalie o percentual de acerto (%) retornado para cada resultado.\r\n\r\n**Passo 2 - Avaliar os resultados:**\r\n- Se encontrou um produto com acerto >= 80%, use-o como produto ÚNICO (é um pacote/combo real no catálogo).\r\n- Se NÃO encontrou nenhum produto com acerto >= 80%, trate como MÚLTIPLOS produtos separados.\r\n\r\n**Passo 3 - Se for múltiplos produtos, buscar cada um separadamente:**\r\n- Faça buscas separadas para cada componente:\r\n  - search_products([\"\"PROMO SUPER 30D\"\", \"\"PROMO SUPER\"\"])\r\n  - search_products([\"\"DEG HBO 30D\"\", \"\"DEG HBO\"\", \"\"DEGUSTAÇÃO HBO\"\"])\r\n- Para cada componente, escolha o produto com MAIOR percentual de acerto.\r\n\r\n### Uso do Percentual de Acerto (%)\r\n\r\nOs resultados de `search_products` incluem o percentual de acerto para cada produto.\r\n- **Sempre prefira o produto com maior percentual de acerto.**\r\n- Se dois produtos têm acerto similar (diferença < 5%), prefira o que tem nome mais próximo ao texto original.\r\n- O percentual indica quantas palavras do nome do produto foram encontradas na busca.\r\n\r\nExemplo de resultado:\r\n```\r\n- Código: 1-21D3Z3E | Nome: PROMO SUPER 30D + DEG HBO 30D | Acerto: 100%\r\n- Código: 1-20XSM69 | Nome: SUPER 30D FAIXA 3 | Acerto: 40%\r\n```\r\n→ Escolha o produto com 100% de acerto.\r\n\r\n## 2. Tratamento de Abreviações e Erros\r\n\r\n**Abreviações comuns que você deve expandir ao buscar:**\r\n- DEG = DEGUSTAÇÃO\r\n- PROMO = PROMOÇÃO ou PROMOCIONAL\r\n- 30D, 7D, 15D = 30 dias, 7 dias, 15 dias (período)\r\n- DEB/DEG = pode ser erro de digitação\r\n\r\n**Ao buscar, inclua variações:**\r\n- Termo original + termo expandido\r\n- Termos parciais do nome do produto\r\n- Combinações com e sem períodos (30D, 7D)\r\n\r\n## 3. Determinação da Ação\r\n\r\nPara CADA produto identificado, determine a ação correspondente:\r\n- `product-add`: inclusão, incluir, adicionar, ativar, ativação, liberação, reativação, pedido, destino, recarga\r\n- `product-remove`: cancelar, cancelamento, excluir, exclusão, retirada, origem, correção, duplicidade, remover\r\n- `none`: quando não for possível determinar a ação\r\n\r\n**Indicadores de ação no contexto:**\r\n- \"\"por favor incluir\"\" → product-add\r\n- \"\"ativar recarga\"\" → product-add\r\n- \"\"valor ficou liberado\"\" + \"\"incluir\"\" → product-add\r\n- \"\"cancelar\"\" → product-remove\r\n- \"\"retirar da grade\"\" → product-remove\r\n\r\n## 4. Tratamento de Valores e Preços\r\n\r\n**IGNORE valores monetários ao identificar produtos:**\r\n- \"\"R$ 89,91\"\", \"\"R  89,91\"\", \"\"89,91\"\" → não fazem parte do nome do produto\r\n- \"\"valor disponível: 129,80\"\" → contexto informativo, não é produto\r\n\r\n## 5. Múltiplos Produtos com Mesma Ação\r\n\r\nUm mesmo texto pode conter MÚLTIPLOS produtos com a MESMA ação.\r\n\r\n**Se a busca combinada NÃO encontrou match >= 80%, retorne cada produto separadamente:**\r\nExemplo: \"\"incluir a recarga: PROMO SUPER 30D + DEG HBO 30D\"\" → busca combinada não encontrou match >= 80% → 2 produtos separados, ambos com action=\"\"product-add\"\"\r\n\r\n**Cada produto separado DEVE ter sua própria entrada em classifiedProducts:**\r\n- `productName` deve conter o nome INDIVIDUAL do produto como mencionado no texto.\r\n- `productCode` deve ser o código do produto com MAIOR percentual de acerto na busca individual.\r\n\r\n**Se a busca combinada encontrou match >= 80%, retorne como produto ÚNICO:**\r\nExemplo: \"\"PROMO SUPER 30D + DEG HBO 30D\"\" existe no catálogo com 100% → 1 produto com o código do catálogo.\r\n\r\n**CORRETO (quando separados - sem match combinado >= 80%):**\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código-promo-super\"\", \"\"productName\"\": \"\"PROMO SUPER 30D\"\", \"\"action\"\": \"\"product-add\"\" },\r\n    { \"\"productCode\"\": \"\"código-deg-hbo\"\", \"\"productName\"\": \"\"DEG HBO 30D\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ]\r\n}\r\n```\r\n\r\n**CORRETO (quando combinado - match combinado >= 80%):**\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código-combo\"\", \"\"productName\"\": \"\"PROMO SUPER 30D + DEG HBO 30D\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ]\r\n}\r\n```\r\n\r\n## 6. Formato de Resposta\r\n\r\nApós identificar todos os produtos e ações, retorne um objeto JSON.\r\n**Use o percentual de acerto (%) para decidir se o produto é combinado (>= 80%) ou deve ser separado (< 80%).**\r\n**Produtos mencionados no texto mas NÃO encontrados pelo search_products devem ser listados em unmatchedProducts.**\r\n\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código1\"\", \"\"productName\"\": \"\"Nome do Produto 1\"\", \"\"action\"\": \"\"product-add\"\" },\r\n    { \"\"productCode\"\": \"\"código2\"\", \"\"productName\"\": \"\"Nome do Produto 2\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ],\r\n  \"\"unmatchedProducts\"\": [\"\"Nome do Produto Não Encontrado\"\"],\r\n  \"\"keywords\"\": [\"\"incluir\"\", \"\"recarga\"\"],\r\n  \"\"log\"\": \"\"Explicação do raciocínio usado\"\"\r\n}\r\n```\r\n\r\n## 7. Regras Importantes\r\n\r\n- O output final deve ser APENAS o JSON sem texto adicional.\r\n- Use múltiplas chamadas a `search_products` para encontrar cada produto.\r\n- Jamais invente códigos de produtos. Use apenas os retornados pela função search_products.\r\n- keywords deve conter as palavras-chave de ação encontradas no texto.\r\n- **Se não conseguir determinar a ação, use action=\"\"none\"\".**\r\n- **Se o produto não for encontrado pelo search_products, adicione-o em `unmatchedProducts` (apenas o nome) e NÃO o inclua em `classifiedProducts`.**\r\n- **Sempre use o produto com MAIOR percentual de acerto (%) na busca.**\r\n- **Para textos com `+`, `,`, `e`, `ou`: busque PRIMEIRO o texto combinado. Se acerto >= 80%, retorne como produto único. Caso contrário, busque cada componente separadamente.**\r\n\r\n## 8. Retorno com Ação ou Produto Não Identificado\r\n\r\nQuando não for possível identificar a ação OU o produto:\r\n- Se o produto foi buscado via search_products e NÃO foi encontrado, adicione o nome do produto em `unmatchedProducts` e NÃO o inclua em `classifiedProducts`.\r\n- Se a ação não puder ser determinada mas o produto existe, use action=\"\"none\"\" em `classifiedProducts`.\r\n\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [],\r\n  \"\"unmatchedProducts\"\": [\"\"Nome mencionado no texto\"\"],\r\n  \"\"keywords\"\": [],\r\n  \"\"log\"\": \"\"Produto não encontrado no catálogo\"\" \r\n}\r\n```\r\n\r\n## 9. Se Nenhum Produto For Mencionado no Texto\r\n\r\nSe o texto não mencionar nenhum produto, retorne:\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [],\r\n  \"\"unmatchedProducts\"\": [],\r\n  \"\"keywords\"\": [],\r\n  \"\"log\"\": \"\"Nenhum produto mencionado no texto\"\"\r\n}\r\n```\";\r\n    }\r\n}","epoch":108,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs::request_c461a1a3-4de4-4857-825f-ce170dca8e15",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\Models\\IntentClassificationResult.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","content":"using System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace Sky.HubAI.Application.Models\r\n{\r\n    /// <summary>\r\n    /// Strongly-typed result from intent classification operation.\r\n    /// Represents the analyzed intents for multiple products and supporting metadata.\r\n    /// </summary>\r\n    public record IntentClassificationResult\r\n    {\r\n        /// <summary>\r\n        /// Original description text that was analyzed.\r\n        /// </summary>\r\n        public string Description { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of classified products with their respective actions.\r\n        /// Each product identified in the description has its own action (product-add, product-remove, none).\r\n        /// </summary>\r\n        public IReadOnlyList<ClassifiedProduct> ClassifiedProducts { get; init; } = new List<ClassifiedProduct>();\r\n\r\n        /// <summary>\r\n        /// Identified action/intent for the first classified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string Action => ClassifiedProducts.FirstOrDefault()?.Action ?? string.Empty;\r\n\r\n        /// <summary>\r\n        /// Natural language description of the first identified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string ProductDescription => ClassifiedProducts.FirstOrDefault()?.ProductName ?? string.Empty;\r\n\r\n        /// <summary>\r\n        /// Product code of the first identified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string ProductCode => ClassifiedProducts.FirstOrDefault()?.ProductCode ?? string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of keywords extracted from the description.\r\n        /// </summary>\r\n        public IReadOnlyList<string> Keywords { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// Diagnostic log or reasoning from the AI analysis.\r\n        /// </summary>\r\n        public string Log { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of candidate products that were considered during matching.\r\n        /// Each entry contains product code and name.\r\n        /// </summary>\r\n        public IReadOnlyList<ProductCandidate> PossibleProducts { get; init; } = new List<ProductCandidate>();\r\n\r\n        /// <summary>\r\n        /// List of product names that were successfully matched in the catalog (match >= 80%).\r\n        /// </summary>\r\n        public IReadOnlyList<string> MatchedProducts { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// List of product names mentioned in the description that could not be matched to any product in the catalog.\r\n        /// </summary>\r\n        public IReadOnlyList<string> UnmatchedProducts { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// List of product search queries made by the LLM during function calling.\r\n        /// Contains the keywords searched and the products returned for each query.\r\n        /// </summary>\r\n        public IReadOnlyList<ProductSearchQuery> SearchQueries { get; init; } = new List<ProductSearchQuery>();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Represents a product that was classified with its identified action.\r\n    /// </summary>\r\n    public record ClassifiedProduct(\r\n        string ProductCode,\r\n        string ProductName,\r\n        string Action);\r\n\r\n    /// <summary>\r\n    /// Represents a candidate product during matching.\r\n    /// </summary>\r\n    public record ProductCandidate(\r\n        string ProductCode,\r\n        string ProductName,\r\n        double MatchPercentage);\r\n\r\n    /// <summary>\r\n    /// Represents a product search query made by the LLM.\r\n    /// Contains the keywords that were searched and the products that were returned.\r\n    /// </summary>\r\n    public record ProductSearchQuery(\r\n        IReadOnlyList<string> Keywords,\r\n        IReadOnlyList<ProductCandidate> ProductsReturned);\r\n\r\n}","epoch":109,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs::request_c461a1a3-4de4-4857-825f-ce170dca8e15",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\Contracts\\IntentClassifications\\IntentClassificationsResponse.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","content":"using System.Collections.Generic;\r\n\r\nnamespace Sky.HubAI.Api.Contracts.IntentClassifications\r\n{\r\n    /// <summary>\r\n    /// Response contract for intent classification operations.\r\n    /// Contains analyzed intents for multiple products and supporting metadata.\r\n    /// </summary>\r\n    public record IntentClassificationsResponse\r\n    {\r\n        /// <summary>\r\n        /// Original description text that was analyzed.\r\n        /// </summary>\r\n        public string Description { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of classified products with their respective actions.\r\n        /// Each product identified in the description has its own action (product-add, product-remove, none).\r\n        /// </summary>\r\n        public IReadOnlyList<ClassifiedProductResponse> ClassifiedProducts { get; init; } = new List<ClassifiedProductResponse>();\r\n\r\n        /// <summary>\r\n        /// Identified action/intent for the first product (e.g., \"product-add\", \"product-remove\").\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string Action { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// Natural language description of the first identified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string ProductDescription { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// Product code of the first identified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string ProductCode { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of keywords extracted from the description.\r\n        /// </summary>\r\n        public IReadOnlyList<string> Keywords { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// Diagnostic log or reasoning from the AI analysis.\r\n        /// </summary>\r\n        public string Log { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of product names that were successfully matched in the catalog (match >= 80%).\r\n        /// </summary>\r\n        public IReadOnlyList<string> MatchedProducts { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// List of product names mentioned in the description that could not be matched to any product in the catalog.\r\n        /// </summary>\r\n        public IReadOnlyList<string> UnmatchedProducts { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// List of product search queries made by the LLM during function calling.\r\n        /// Contains the keywords searched and the products returned for each query.\r\n        /// </summary>\r\n        public IReadOnlyList<ProductSearchQueryResponse> SearchQueries { get; init; } = new List<ProductSearchQueryResponse>();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Represents a classified product with its identified action.\r\n    /// </summary>\r\n    public record ClassifiedProductResponse(\r\n        string ProductCode,\r\n        string ProductName,\r\n        string Action);\r\n\r\n    /// <summary>\r\n    /// Represents a product search query made by the LLM.\r\n    /// </summary>\r\n    public record ProductSearchQueryResponse(\r\n        IReadOnlyList<string> Keywords,\r\n        IReadOnlyList<ProductCandidateResponse> ProductsReturned);\r\n\r\n    /// <summary>\r\n    /// Represents a candidate product.\r\n    /// </summary>\r\n    public record ProductCandidateResponse(\r\n        string ProductCode,\r\n        string ProductName,\r\n        double MatchPercentage);\r\n\r\n}","epoch":110,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Settings/AzureOpenAiSettings.cs::request_c461a1a3-4de4-4857-825f-ce170dca8e15",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Settings\\AzureOpenAiSettings.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Settings/AzureOpenAiSettings.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Settings/AzureOpenAiSettings.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","content":"namespace Sky.HubAI.Infrastructure.OpenAI.Settings\r\n{\r\n    public class AzureOpenAiSettings\r\n    {\r\n        public string Endpoint { get; set; } = string.Empty;\r\n        public string ApiKey { get; set; } = string.Empty;\r\n        public string DeploymentName { get; set; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// Number of top candidate products to consider for intent classification.\r\n        /// Default: 10\r\n        /// </summary>\r\n        public int TopCandidatesCount { get; set; } = 10;\r\n    }\r\n}","epoch":111,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/appsettings.json::request_c461a1a3-4de4-4857-825f-ce170dca8e15",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\appsettings.json","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/appsettings.json","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/appsettings.json","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","content":"{\r\n  \"AllowedHosts\": \"*\",\r\n  \"AzureOpenAi\": {\r\n    \"Endpoint\": \"\",\r\n    \"ApiKey\": \"\",\r\n    \"DeploymentName\": \"gpt-4o\"\r\n  },\r\n  \"FileStorage\": {\r\n    \"ProductCsvPath\": \"./products.csv\",\r\n\t\"BlockedKeywordsPath\": \"./blocked_keywords.txt\"\r\n  },\r\n  \"Auth\": {\r\n    \"EnableClientToken\": false,\r\n    \"ClientToken\": \"\"\r\n  },\r\n  \"Logging\": {\r\n    \"LogLevel\": {\r\n      \"Default\": \"Information\",\r\n      \"Microsoft.AspNetCore\": \"Warning\"\r\n    }\r\n  }\r\n}","epoch":112,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/appsettings.Development.json::request_c461a1a3-4de4-4857-825f-ce170dca8e15",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\appsettings.Development.json","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/appsettings.Development.json","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/appsettings.Development.json","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","content":"{\r\n  \"AllowedHosts\": \"*\",\r\n  \"AzureOpenAi\": {\r\n    \"Endpoint\": \"https://sk-sky-hubai.openai.azure.com/\",\r\n    \"ApiKey\": \"5HkFKNtvkI9cxeZwhsYZUVXRUWWya7T9J6CGQH3ayVvlPk6e1SvWJQQJ99CBACYeBjFXJ3w3AAABACOG31Cu\",\r\n    \"DeploymentName\": \"gpt-4o\"\r\n  },\r\n  \"FileStorage\": {\r\n    \"ProductCsvPath\": \"./products.csv\",\r\n\t\"BlockedKeywordsPath\": \"./blocked_keywords.txt\"\r\n  },\r\n  \"Auth\": {\r\n    \"EnableClientToken\": false,\r\n    \"ClientToken\": \"\"\r\n  },\r\n  \"Logging\": {\r\n    \"LogLevel\": {\r\n      \"Default\": \"Information\",\r\n      \"Microsoft.AspNetCore\": \"Warning\"\r\n    }\r\n  }\r\n}","epoch":131,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs::request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\Models\\IntentClassificationResult.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","scheme":"file"},"requestId":"request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539","content":"using System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace Sky.HubAI.Application.Models\r\n{\r\n    /// <summary>\r\n    /// Strongly-typed result from intent classification operation.\r\n    /// Represents the analyzed intents for multiple products and supporting metadata.\r\n    /// </summary>\r\n    public record IntentClassificationResult\r\n    {\r\n        /// <summary>\r\n        /// Original description text that was analyzed.\r\n        /// </summary>\r\n        public string Description { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of classified products with their respective actions.\r\n        /// Each product identified in the description has its own action (product-add, product-remove, none).\r\n        /// </summary>\r\n        public IReadOnlyList<ClassifiedProduct> ClassifiedProducts { get; init; } = new List<ClassifiedProduct>();\r\n\r\n        /// <summary>\r\n        /// Identified action/intent for the first classified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string Action => ClassifiedProducts.FirstOrDefault()?.Action ?? string.Empty;\r\n\r\n        /// <summary>\r\n        /// Natural language description of the first identified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string ProductDescription => ClassifiedProducts.FirstOrDefault()?.ProductName ?? string.Empty;\r\n\r\n        /// <summary>\r\n        /// Product code of the first identified product.\r\n        /// Maintained for backward compatibility. Use ClassifiedProducts for multiple products.\r\n        /// </summary>\r\n        public string ProductCode => ClassifiedProducts.FirstOrDefault()?.ProductCode ?? string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of keywords extracted from the description.\r\n        /// </summary>\r\n        public IReadOnlyList<string> Keywords { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// Diagnostic log or reasoning from the AI analysis.\r\n        /// </summary>\r\n        public string Log { get; init; } = string.Empty;\r\n\r\n        /// <summary>\r\n        /// List of candidate products that were considered during matching.\r\n        /// Each entry contains product code and name.\r\n        /// </summary>\r\n        public IReadOnlyList<ProductCandidate> PossibleProducts { get; init; } = new List<ProductCandidate>();\r\n\r\n        /// <summary>\r\n        /// List of product names that were successfully matched in the catalog (match above configured MinMatchPercentage).\r\n        /// </summary>\r\n        public IReadOnlyList<string> MatchedProducts { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// List of product names mentioned in the description that could not be matched to any product in the catalog.\r\n        /// </summary>\r\n        public IReadOnlyList<string> UnmatchedProducts { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// List of product search queries made by the LLM during function calling.\r\n        /// Contains the keywords searched and the products returned for each query.\r\n        /// </summary>\r\n        public IReadOnlyList<ProductSearchQuery> SearchQueries { get; init; } = new List<ProductSearchQuery>();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Represents a product that was classified with its identified action.\r\n    /// </summary>\r\n    public record ClassifiedProduct(\r\n        string ProductCode,\r\n        string ProductName,\r\n        string Action);\r\n\r\n    /// <summary>\r\n    /// Represents a candidate product during matching.\r\n    /// </summary>\r\n    public record ProductCandidate(\r\n        string ProductCode,\r\n        string ProductName,\r\n        double MatchPercentage);\r\n\r\n    /// <summary>\r\n    /// Represents a product search query made by the LLM.\r\n    /// Contains the keywords that were searched and the products that were returned.\r\n    /// </summary>\r\n    public record ProductSearchQuery(\r\n        IReadOnlyList<string> Keywords,\r\n        IReadOnlyList<ProductCandidate> ProductsReturned);\r\n\r\n}","epoch":137,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs::request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539","content":"using Azure;\r\nusing Azure.AI.OpenAI;\r\nusing Microsoft.Extensions.Logging;\r\nusing Microsoft.Extensions.Options;\r\nusing OpenAI.Chat;\r\nusing Sky.HubAI.Application.Abstractions;\r\nusing Sky.HubAI.Application.Models;\r\nusing Sky.HubAI.Domain.Entities;\r\nusing Sky.HubAI.Infrastructure.OpenAI.Prompts;\r\nusing Sky.HubAI.Infrastructure.OpenAI.Settings;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Sky.HubAI.Infrastructure.OpenAI.Services\r\n{\r\n    public class OpenAiIntentClassifyService : IOpenAiIntentClassifyService\r\n    {\r\n        private readonly AzureOpenAiSettings _settings;\r\n        private readonly AzureOpenAIClient _client;\r\n        private readonly ILogger<OpenAiIntentClassifyService> _logger;\r\n\r\n        private const string SearchProductsToolName = \"search_products\";\r\n        private const int MaxFunctionCallingIterations = 5;\r\n\r\n        public OpenAiIntentClassifyService(\r\n            IOptions<AzureOpenAiSettings> settings,\r\n            ILogger<OpenAiIntentClassifyService> logger)\r\n        {\r\n            _settings = settings.Value;\r\n            _client = new AzureOpenAIClient(new Uri(_settings.Endpoint), new AzureKeyCredential(_settings.ApiKey));\r\n            _logger = logger;\r\n        }\r\n\r\n        public async Task<IntentClassificationResult> ClassifyIntentAsync(\r\n            string description,\r\n            Func<string[], IReadOnlyList<ProductMatchResult>> productSearchFunction,\r\n            CancellationToken cancellationToken = default)\r\n        {\r\n            _logger.LogInformation(\"Iniciando classificação de intenção com function calling\");\r\n\r\n            var chatClient = _client.GetChatClient(_settings.DeploymentName);\r\n            var systemPrompt = TextClassificationPrompt.GetSystemPrompt(_settings.MinMatchPercentage);\r\n            var allFoundProducts = new List<Product>();\r\n            var searchQueries = new List<ProductSearchQuery>();\r\n\r\n            var messages = new List<ChatMessage>\r\n            {\r\n                new SystemChatMessage(systemPrompt),\r\n                new UserChatMessage(description)\r\n            };\r\n\r\n            var tools = new List<ChatTool> { CreateSearchProductsTool() };\r\n            var chatOptions = new ChatCompletionOptions\r\n            {\r\n                Tools = { tools[0] }\r\n            };\r\n\r\n            // Function calling loop\r\n            for (int iteration = 0; iteration < MaxFunctionCallingIterations; iteration++)\r\n            {\r\n                var response = await chatClient.CompleteChatAsync(messages, chatOptions, cancellationToken);\r\n                var chatCompletion = response?.Value;\r\n\r\n                if (chatCompletion == null)\r\n                {\r\n                    _logger.LogWarning(\"Modelo OpenAI retornou resposta vazia na iteração {Iteration}\", iteration);\r\n                    break;\r\n                }\r\n\r\n                // Check if the model wants to call a tool\r\n                if (chatCompletion.FinishReason == ChatFinishReason.ToolCalls)\r\n                {\r\n                    _logger.LogInformation(\"LLM solicitou chamada de ferramenta na iteração {Iteration}\", iteration);\r\n\r\n                    // Add assistant message with tool calls\r\n                    messages.Add(new AssistantChatMessage(chatCompletion));\r\n\r\n                    // Process each tool call\r\n                    foreach (var toolCall in chatCompletion.ToolCalls)\r\n                    {\r\n                        if (toolCall.FunctionName == SearchProductsToolName)\r\n                        {\r\n                            var toolResult = ProcessSearchProductsCall(toolCall, productSearchFunction, allFoundProducts, searchQueries);\r\n                            messages.Add(new ToolChatMessage(toolCall.Id, toolResult));\r\n                        }\r\n                        else\r\n                        {\r\n                            _logger.LogWarning(\"Ferramenta desconhecida solicitada: {ToolName}\", toolCall.FunctionName);\r\n                            messages.Add(new ToolChatMessage(toolCall.Id, \"Ferramenta não reconhecida.\"));\r\n                        }\r\n                    }\r\n\r\n                    continue; // Continue loop to get final response\r\n                }\r\n\r\n                // Final response - parse classification\r\n                if (chatCompletion.FinishReason == ChatFinishReason.Stop)\r\n                {\r\n                    var contentItems = chatCompletion.Content;\r\n                    if (contentItems == null || contentItems.Count == 0)\r\n                    {\r\n                        _logger.LogWarning(\"Resposta final sem conteúdo\");\r\n                        break;\r\n                    }\r\n\r\n                    var content = contentItems[0].Text;\r\n                    _logger.LogDebug(\"Resposta final da OpenAI: {ContentLength} caracteres\", content?.Length ?? 0);\r\n\r\n                    return ParseFinalResponse(description, content, allFoundProducts, searchQueries);\r\n                }\r\n\r\n                _logger.LogWarning(\"Finish reason inesperado: {FinishReason}\", chatCompletion.FinishReason);\r\n                break;\r\n            }\r\n\r\n            // Fallback if loop exhausted\r\n            _logger.LogWarning(\"Loop de function calling esgotado sem resposta final\");\r\n            return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Não foi possível obter classificação após múltiplas tentativas.\");\r\n        }\r\n\r\n        private ChatTool CreateSearchProductsTool()\r\n        {\r\n            return ChatTool.CreateFunctionTool(\r\n                functionName: SearchProductsToolName,\r\n                functionDescription: $\"Busca produtos no catálogo por palavras-chave. Retorna produtos com percentual de acerto (%). Use esta ferramenta para encontrar produtos mencionados no texto do usuário. IMPORTANTE: Primeiro busque o nome completo/combinado. Se nenhum resultado tiver acerto >= {_settings.MinMatchPercentage}%, busque cada produto separadamente. Inclua variações e abreviações expandidas nas keywords (ex: DEG → DEGUSTAÇÃO).\",\r\n                functionParameters: BinaryData.FromString(\"\"\"\r\n                {\r\n                    \"type\": \"object\",\r\n                    \"properties\": {\r\n                        \"keywords\": {\r\n                            \"type\": \"array\",\r\n                            \"items\": { \"type\": \"string\" },\r\n                            \"description\": \"Lista de palavras-chave ou termos para buscar produtos. Para melhores resultados: use o nome completo do produto, variações com abreviações expandidas (DEG→DEGUSTAÇÃO, PROMO→PROMOÇÃO), e termos parciais. Pode incluir nomes combinados (ex: 'PROMO SUPER 30D + DEG HBO 30D') para verificar se existe como produto único. Os resultados incluem percentual de acerto (%).\"\r\n                        }\r\n                    },\r\n                    \"required\": [\"keywords\"]\r\n                }\r\n                \"\"\"));\r\n        }\r\n\r\n        private string ProcessSearchProductsCall(\r\n            ChatToolCall toolCall,\r\n            Func<string[], IReadOnlyList<ProductMatchResult>> productSearchFunction,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries)\r\n        {\r\n            try\r\n            {\r\n                var arguments = JsonSerializer.Deserialize<SearchProductsArguments>(toolCall.FunctionArguments);\r\n                var keywords = arguments?.Keywords ?? Array.Empty<string>();\r\n\r\n                _logger.LogInformation(\"Buscando produtos com keywords: {Keywords}\", string.Join(\", \", keywords));\r\n\r\n                var foundMatches = productSearchFunction(keywords);\r\n\r\n                // Somente considerar produtos com mais de MinMatchPercentage% de match\r\n                var qualifiedMatches = foundMatches\r\n                    .Where(m => m.MatchPercentage > _settings.MinMatchPercentage)\r\n                    .ToList();\r\n\r\n                allFoundProducts.AddRange(qualifiedMatches\r\n                    .Where(m => !allFoundProducts.Any(ap => ap.Code == m.Product.Code))\r\n                    .Select(m => m.Product));\r\n\r\n                // Registrar a busca realizada (keywords + TODOS os produtos retornados com percentual)\r\n                var productsReturned = foundMatches\r\n                    .Select(m => new ProductCandidate(m.Product.Code, m.Product.Name, m.MatchPercentage))\r\n                    .ToList();\r\n                searchQueries.Add(new ProductSearchQuery(keywords, productsReturned));\r\n\r\n                _logger.LogInformation(\"Encontrados {Count} produtos para as keywords\", foundMatches.Count);\r\n\r\n                if (foundMatches.Count == 0)\r\n                {\r\n                    return \"Nenhum produto encontrado para as palavras-chave fornecidas.\";\r\n                }\r\n\r\n                var sb = new StringBuilder();\r\n                sb.AppendLine($\"Encontrados {foundMatches.Count} produtos (ordenados por percentual de acerto):\");\r\n                foreach (var match in foundMatches)\r\n                {\r\n                    sb.AppendLine($\"- Código: {match.Product.Code} | Nome: {match.Product.Name} | Acerto: {match.MatchPercentage}%\");\r\n                }\r\n                return sb.ToString();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                _logger.LogError(ex, \"Erro ao processar chamada search_products\");\r\n                return \"Erro ao buscar produtos.\";\r\n            }\r\n        }\r\n\r\n        private IntentClassificationResult ParseFinalResponse(\r\n            string description,\r\n            string? content,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries)\r\n        {\r\n            var possibleProducts = allFoundProducts\r\n                .Select(p => new ProductCandidate(p.Code, p.Name, 0))\r\n                .ToList();\r\n\r\n            // Extrair nomes dos produtos com match > MinMatchPercentage% (a partir dos searchQueries)\r\n            var matchedProducts = searchQueries\r\n                .SelectMany(q => q.ProductsReturned)\r\n                .Where(p => p.MatchPercentage > _settings.MinMatchPercentage)\r\n                .Select(p => p.ProductName)\r\n                .Distinct()\r\n                .ToList();\r\n\r\n            if (string.IsNullOrWhiteSpace(content))\r\n            {\r\n                return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Resposta vazia do modelo.\");\r\n            }\r\n\r\n            var parsed = ParseResponseToDictionary(content);\r\n            if (parsed == null)\r\n            {\r\n                _logger.LogWarning(\"Falha ao interpretar JSON da resposta final\");\r\n                return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Falha ao interpretar JSON da resposta.\");\r\n            }\r\n\r\n            var keywords = ExtractKeywords(parsed);\r\n            var classifiedProducts = ExtractClassifiedProducts(parsed, allFoundProducts);\r\n            var unmatchedProducts = ExtractUnmatchedProducts(parsed);\r\n            var log = parsed.TryGetValue(\"log\", out var logVal) ? logVal?.ToString() ?? string.Empty : string.Empty;\r\n\r\n            var result = new IntentClassificationResult\r\n            {\r\n                Description = description,\r\n                ClassifiedProducts = classifiedProducts,\r\n                Keywords = keywords,\r\n                Log = log,\r\n                PossibleProducts = possibleProducts,\r\n                MatchedProducts = matchedProducts,\r\n                UnmatchedProducts = unmatchedProducts,\r\n                SearchQueries = searchQueries\r\n            };\r\n\r\n            _logger.LogInformation(\r\n                \"Classificação concluída. {ProductCount} produtos classificados\",\r\n                classifiedProducts.Count);\r\n\r\n            return result;\r\n        }\r\n\r\n        private IReadOnlyList<ClassifiedProduct> ExtractClassifiedProducts(\r\n            Dictionary<string, object>? parsed,\r\n            List<Product> allFoundProducts)\r\n        {\r\n            if (parsed == null) return Array.Empty<ClassifiedProduct>();\r\n\r\n            var result = new List<ClassifiedProduct>();\r\n\r\n            // Try to extract \"classifiedProducts\" array\r\n            if (parsed.TryGetValue(\"classifiedProducts\", out var productsVal) && productsVal is JsonElement jsonArray)\r\n            {\r\n                if (jsonArray.ValueKind == JsonValueKind.Array)\r\n                {\r\n                    foreach (var item in jsonArray.EnumerateArray())\r\n                    {\r\n                        var productCode = item.TryGetProperty(\"productCode\", out var codeEl) ? codeEl.GetString() ?? string.Empty : string.Empty;\r\n                        var productName = item.TryGetProperty(\"productName\", out var nameEl) ? nameEl.GetString() ?? string.Empty : string.Empty;\r\n                        var action = item.TryGetProperty(\"action\", out var actionEl) ? actionEl.GetString() ?? string.Empty : string.Empty;\r\n\r\n                        // If productName is empty, try to get from found products\r\n                        if (string.IsNullOrEmpty(productName) && !string.IsNullOrEmpty(productCode))\r\n                        {\r\n                            productName = allFoundProducts.FirstOrDefault(p => p.Code == productCode)?.Name ?? string.Empty;\r\n                        }\r\n\r\n                        if (!string.IsNullOrEmpty(productCode) || !string.IsNullOrEmpty(productName))\r\n                        {\r\n                            result.Add(new ClassifiedProduct(productCode, productName, action));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Fallback: try legacy single product format\r\n            if (result.Count == 0)\r\n            {\r\n                var action = parsed.TryGetValue(\"action\", out var actionVal) ? actionVal?.ToString() ?? string.Empty : string.Empty;\r\n                var productCode = parsed.TryGetValue(\"product_code\", out var codeVal) ? codeVal?.ToString() ?? string.Empty : string.Empty;\r\n                var productDescription = parsed.TryGetValue(\"productDescription\", out var descVal) ? descVal?.ToString() ?? string.Empty : string.Empty;\r\n\r\n                if (!string.IsNullOrEmpty(productCode) || !string.IsNullOrEmpty(productDescription))\r\n                {\r\n                    result.Add(new ClassifiedProduct(productCode, productDescription, action));\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private IntentClassificationResult CreateEmptyResult(\r\n            string description,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries,\r\n            string logMessage)\r\n        {\r\n            return new IntentClassificationResult\r\n            {\r\n                Description = description,\r\n                ClassifiedProducts = Array.Empty<ClassifiedProduct>(),\r\n                Keywords = Array.Empty<string>(),\r\n                Log = logMessage,\r\n                PossibleProducts = allFoundProducts\r\n                    .Select(p => new ProductCandidate(p.Code, p.Name, 0))\r\n                    .ToList(),\r\n                SearchQueries = searchQueries\r\n            };\r\n        }\r\n\r\n        private IReadOnlyList<string> ExtractUnmatchedProducts(Dictionary<string, object>? parsed)\r\n        {\r\n            if (parsed == null) return Array.Empty<string>();\r\n\r\n            if (parsed.TryGetValue(\"unmatchedProducts\", out var val) && val is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.Array)\r\n            {\r\n                return jsonElement.EnumerateArray()\r\n                    .Select(e => e.GetString() ?? string.Empty)\r\n                    .Where(s => !string.IsNullOrWhiteSpace(s))\r\n                    .ToList();\r\n            }\r\n\r\n            return Array.Empty<string>();\r\n        }\r\n\r\n        private IReadOnlyList<string> ExtractKeywords(Dictionary<string, object>? parsed)\r\n        {\r\n            if (parsed == null) return Array.Empty<string>();\r\n\r\n            if (parsed.TryGetValue(\"keywords\", out var keyVal) && keyVal != null)\r\n            {\r\n                if (keyVal is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.Array)\r\n                {\r\n                    return jsonElement.EnumerateArray()\r\n                        .Select(e => e.GetString() ?? string.Empty)\r\n                        .Where(s => !string.IsNullOrWhiteSpace(s))\r\n                        .ToList();\r\n                }\r\n\r\n                var str = keyVal.ToString() ?? string.Empty;\r\n                if (!string.IsNullOrWhiteSpace(str))\r\n                {\r\n                    return str.Split(new[] { ',', ';' }, StringSplitOptions.RemoveEmptyEntries)\r\n                        .Select(s => s.Trim())\r\n                        .Where(s => !string.IsNullOrWhiteSpace(s))\r\n                        .ToList();\r\n                }\r\n            }\r\n\r\n            return Array.Empty<string>();\r\n        }\r\n\r\n        private static Dictionary<string, object>? ParseResponseToDictionary(string content)\r\n        {\r\n            if (string.IsNullOrWhiteSpace(content))\r\n                return null;\r\n            try\r\n            {\r\n                content = content.Replace(\"```json\", \"\", StringComparison.OrdinalIgnoreCase)\r\n                                 .Replace(\"```\", \"\", StringComparison.OrdinalIgnoreCase)\r\n                                 .Trim();\r\n                var extractedData = JsonSerializer.Deserialize<Dictionary<string, object>>(content, new JsonSerializerOptions\r\n                {\r\n                    NumberHandling = JsonNumberHandling.AllowReadingFromString\r\n                });\r\n                return extractedData;\r\n            }\r\n            catch { return null; }\r\n        }\r\n\r\n        private class SearchProductsArguments\r\n        {\r\n            [JsonPropertyName(\"keywords\")]\r\n            public string[] Keywords { get; set; } = Array.Empty<string>();\r\n        }\r\n    }\r\n}","epoch":138,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs::request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\UseCases\\Intent\\ClassifyIntent\\ClassifyIntentQueryHandler.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs","scheme":"file"},"requestId":"request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539","content":"using MediatR;\r\nusing Microsoft.Extensions.Logging;\r\nusing Sky.HubAI.Application.Abstractions;\r\nusing Sky.HubAI.Application.Models;\r\nusing Sky.HubAI.Domain.Services.Interfaces;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Sky.HubAI.Application.UseCases.Intent.ClassifyIntent\r\n{\r\n    /// <summary>\r\n    /// Use case handler for classifying user intent from text descriptions.\r\n    /// Orchestrates: product search via function calling, calling AI service, normalizing results.\r\n    /// </summary>\r\n    public class ClassifyIntentQueryHandler : IRequestHandler<ClassifyIntentQuery, ClassifyIntentResult>\r\n    {\r\n        private readonly IOpenAiIntentClassifyService _openAiService;\r\n        private readonly IProductMemoryCacheService _productCache;\r\n        private readonly IProductMatchingService _productMatching;\r\n        private readonly ILogger<ClassifyIntentQueryHandler> _logger;\r\n\r\n        private const int TopCandidatesPerKeyword = 10;\r\n\r\n        public ClassifyIntentQueryHandler(\r\n            IOpenAiIntentClassifyService openAiService,\r\n            IProductMemoryCacheService productCache,\r\n            IProductMatchingService productMatching,\r\n            ILogger<ClassifyIntentQueryHandler> logger)\r\n        {\r\n            _openAiService = openAiService;\r\n            _productCache = productCache;\r\n            _productMatching = productMatching;\r\n            _logger = logger;\r\n        }\r\n\r\n        public async Task<ClassifyIntentResult> Handle(ClassifyIntentQuery request, CancellationToken cancellationToken)\r\n        {\r\n            _logger.LogInformation(\r\n                \"Iniciando análise de intenção. Descrição: {DescriptionLength} caracteres\",\r\n                request.Description?.Length ?? 0);\r\n\r\n            // 1. Buscar todos os produtos do cache (para uso na função de busca)\r\n            var allProducts = _productCache.GetAllProducts();\r\n            _logger.LogInformation(\"Produtos carregados do cache: {ProductCount}\", allProducts.Count);\r\n\r\n            // 2. Criar função de busca para function calling\r\n            // Esta função será chamada pela LLM quando precisar buscar produtos\r\n            IReadOnlyList<Domain.Entities.ProductMatchResult> SearchProducts(string[] keywords)\r\n            {\r\n                _logger.LogInformation(\"Function calling: buscando produtos com keywords: {Keywords}\", \r\n                    string.Join(\", \", keywords));\r\n\r\n                var results = new List<Domain.Entities.ProductMatchResult>();\r\n                foreach (var keyword in keywords)\r\n                {\r\n                    var matches = _productMatching.FindTopMatchingProductsWithScore(\r\n                        allProducts,\r\n                        keyword,\r\n                        TopCandidatesPerKeyword);\r\n                    \r\n                    // Adicionar apenas produtos não duplicados\r\n                    foreach (var match in matches)\r\n                    {\r\n                        if (!results.Any(r => r.Product.Code == match.Product.Code))\r\n                        {\r\n                            results.Add(match);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                _logger.LogInformation(\"Function calling: encontrados {Count} produtos únicos\", results.Count);\r\n                return results;\r\n            }\r\n\r\n            // 3. Chamar serviço de IA com function calling\r\n            var classificationResult = await _openAiService.ClassifyIntentAsync(\r\n                request.Description,\r\n                SearchProducts,\r\n                cancellationToken);\r\n\r\n            // 4. Normalizar ações de todos os produtos classificados (regra de aplicação)\r\n            var normalizedProducts = classificationResult.ClassifiedProducts\r\n                .Select(p => new ClassifiedProduct(\r\n                    p.ProductCode,\r\n                    p.ProductName,\r\n                    NormalizeAction(p.Action)))\r\n                .ToList();\r\n\r\n            // 5. Construir resultado final\r\n            var result = new ClassifyIntentResult(new IntentClassificationResult\r\n            {\r\n                Description = classificationResult.Description,\r\n                ClassifiedProducts = normalizedProducts,\r\n                Keywords = classificationResult.Keywords,\r\n                Log = classificationResult.Log,\r\n                PossibleProducts = classificationResult.PossibleProducts,\r\n                MatchedProducts = classificationResult.MatchedProducts,\r\n                UnmatchedProducts = classificationResult.UnmatchedProducts,\r\n                SearchQueries = classificationResult.SearchQueries\r\n            });\r\n\r\n            _logger.LogInformation(\r\n                \"Classificação concluída. {ProductCount} produtos classificados. Primeiro: Action={Action}, ProductCode={ProductCode}\",\r\n                result.Data.ClassifiedProducts.Count,\r\n                result.Data.Action,\r\n                result.Data.ProductCode);\r\n\r\n            return result;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Normalizes action names to standardized values.\r\n        /// Application-level business rule for consistency.\r\n        /// </summary>\r\n        private static string NormalizeAction(string action)\r\n        {\r\n            if (string.IsNullOrWhiteSpace(action))\r\n                return string.Empty;\r\n\r\n            var normalized = action.Trim().ToLowerInvariant();\r\n\r\n            // Mapeia ações conhecidas\r\n            return normalized switch\r\n            {\r\n                \"product-add\" or \"inclusão\" or \"incluir\" or \"adicionar\" or \"ativação\" or \"liberação\" => \"product-add\",\r\n                \"product-remove\" or \"cancelamento\" or \"cancelar\" or \"retirada\" or \"excluir\" or \"exclusão\" => \"product-remove\",\r\n                \"none\" => \"none\",\r\n                _ => string.Empty\r\n            };\r\n        }\r\n    }\r\n}","epoch":139,"telemetryInfo":{}}]],"operations":[{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_ae32375e-6848-4961-bee0-5b7eecb7bdd3","epoch":4,"edits":[{"text":"\r\n\r\n**REGRA CRÍTICA - Sempre dividir produtos separados:**\r\n- Quando o texto contém produtos separados por `+`, `,`, `e`, `ou`, ou listados sequencialmente, CADA produto DEVE ser retornado como uma entrada SEPARADA em `classifiedProducts`.\r\n- **NUNCA** retorne um produto combinado/pacote como uma única entrada quando o texto menciona múltiplos produtos.\r\n- Mesmo que o catálogo tenha um produto combinado (ex: \"\"PROMO SUPER 30D + DEG HBO 30D\"\" como um único código), você DEVE retornar cada componente separadamente.\r\n- Para cada componente, busque o melhor código individual. Se não existir código individual, use o código do produto combinado para cada componente.\r\n- Exemplo: \"\"PROMO SUPER 30D + DEG HBO 30D\"\" → dois produtos em classifiedProducts, NUNCA um único.","range":{"startLineNumber":35,"startColumn":83,"endLineNumber":35,"endColumn":83}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_ae32375e-6848-4961-bee0-5b7eecb7bdd3","epoch":6,"edits":[{"text":" separados, ambos com action=\"\"product-add\"\"\r\n\r\n**Cada produto DEVE ter sua própria entrada em classifiedProducts:**\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código-promo-super\"\", \"\"productName\"\": \"\"PROMO SUPER 30D\"\", \"\"action\"\": \"\"product-add\"\" },\r\n    { \"\"productCode\"\": \"\"código-deg-hbo\"\", \"\"productName\"\": \"\"DEG HBO 30D\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ]\r\n}\r\n```\r\n\r\n**ERRADO** (nunca faça isso):\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código-combo\"\", \"\"productName\"\": \"\"PROMO SUPER 30D + DEG HBO 30D\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ]\r\n}\r\n```","range":{"startLineNumber":80,"startColumn":75,"endLineNumber":80,"endColumn":109}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_ae32375e-6848-4961-bee0-5b7eecb7bdd3","epoch":8,"edits":[{"text":".\r\n**Cada produto mencionado DEVE ter sua própria entrada em classifiedProducts, mesmo que o catálogo tenha apenas um produto combinado.**\r\n","range":{"startLineNumber":103,"startColumn":67,"endLineNumber":103,"endColumn":68}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_ae32375e-6848-4961-bee0-5b7eecb7bdd3","epoch":10,"edits":[{"text":"\r\n- **NUNCA agrupe múltiplos produtos em uma única entrada de classifiedProducts.**\r\n- **Se o catálogo retornar um produto combinado (ex: \"\"A + B\"\"), busque os códigos individuais de A e de B separadamente. Se não existirem códigos individuais, use o código do combinado para cada componente, mas SEMPRE retorne entradas separadas.**","range":{"startLineNumber":124,"startColumn":110,"endLineNumber":124,"endColumn":110}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_ae32375e-6848-4961-bee0-5b7eecb7bdd3","epoch":12,"edits":[{"text":"- `productName` deve conter o nome INDIVIDUAL do produto como mencionado no texto, NÃO o nome do produto combinado do catálogo.\r\n- `productCode` deve ser o código do melhor match individual. Se não existir individual, use o código do combinado.\r\n\r\n**CORRETO:**\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código-promo-super\"\", \"\"productName\"\": \"\"PROMO SUPER 30D\"\", \"\"action\"\": \"\"product-add\"\" },\r\n    { \"\"productCode\"\": \"\"código-deg-hbo\"\", \"\"productName\"\": \"\"DEG HBO 30D\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ]\r\n}\r\n```\r\n\r\n**ERRADO** (nunca faça isso - produto combinado como uma única entrada):\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código-combo\"\", \"\"productName\"\": \"\"PROMO SUPER 30D + DEG HBO 30D\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ]\r\n}\r\n```\r\n\r\n**ERRADO** (nunca faça isso - nome do combinado repetido em cada entrada):\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código-combo\"\", \"\"productName\"\": \"\"PROMO SUPER 30D + DEG HBO 30D\"\", \"\"action\"\": \"\"product-add\"\" },","range":{"startLineNumber":83,"startColumn":1,"endLineNumber":95,"endColumn":28}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Domain\\Entities\\Product.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Domain/Entities/Product.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Domain/Entities/Product.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","epoch":21,"edits":[{"text":"\r\n    /// <summary>\r\n    /// Represents a product match result with its compatibility score.\r\n    /// </summary>\r\n    public class ProductMatchResult(\r\n        Product product,\r\n        double score)\r\n    {\r\n        /// <summary>\r\n        /// The matched product.\r\n        /// </summary>\r\n        public Product Product { get; } = product;\r\n\r\n        /// <summary>\r\n        /// Match score as a percentage (0-100).\r\n        /// Represents how many words from the product name were found in the search description.\r\n        /// </summary>\r\n        public double MatchPercentage { get; } = System.Math.Round(score * 100, 1);\r\n    }\r\n","range":{"startLineNumber":10,"startColumn":1,"endLineNumber":10,"endColumn":1}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Domain\\Services\\Interfaces\\IProductMatchingService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Domain/Services/Interfaces/IProductMatchingService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Domain/Services/Interfaces/IProductMatchingService.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","epoch":22,"edits":[{"text":"\r\n        /// <summary>\r\n        /// Finds the top N products that best match the given description, including match score.\r\n        /// Uses tokenization and word compatibility analysis.\r\n        /// </summary>\r\n        /// <param name=\"allProducts\">Complete list of available products.</param>\r\n        /// <param name=\"description\">Text description to match against products.</param>\r\n        /// <param name=\"topCount\">Maximum number of results to return.</param>\r\n        /// <returns>List of product match results with scores, ordered by match quality (best matches first).</returns>\r\n        IReadOnlyList<ProductMatchResult> FindTopMatchingProductsWithScore(\r\n            IReadOnlyList<Product> allProducts,\r\n            string description,\r\n            int topCount);\r\n","range":{"startLineNumber":24,"startColumn":1,"endLineNumber":24,"endColumn":1}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Domain\\Services\\Implementations\\ProductMatchingService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Domain/Services/Implementations/ProductMatchingService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Domain/Services/Implementations/ProductMatchingService.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","epoch":23,"edits":[{"text":"return FindTopMatchingProductsWithScore(allProducts, description, topCount)\r\n                .Select(r => r.Product)\r\n                .ToList();\r\n        }\r\n\r\n        public IReadOnlyList<ProductMatchResult> FindTopMatchingProductsWithScore(\r\n            IReadOnlyList<Product> allProducts,\r\n            string description,\r\n            int topCount)\r\n        {\r\n            if (allProducts == null || allProducts.Count == 0)\r\n            {\r\n                _logger.LogWarning(\"FindTopMatchingProducts chamado com lista de produtos vazia\");\r\n                return Array.Empty<ProductMatchResult>();\r\n            }\r\n\r\n            if (string.IsNullOrWhiteSpace(description))\r\n            {\r\n                _logger.LogWarning(\"FindTopMatchingProducts chamado com descrição vazia\");\r\n                return Array.Empty<ProductMatchResult>();\r\n            }\r\n\r\n            _logger.LogInformation(\r\n                \"Iniciando busca de produtos compatíveis. Total de produtos: {ProductCount}, Top: {TopCount}\",\r\n                allProducts.Count,\r\n                topCount);\r\n\r\n            var descTokens = Tokenize(description)\r\n                .Select(t => t.ToLowerInvariant())\r\n                .ToHashSet();\r\n\r\n            var scored = allProducts\r\n                .Select(product =>\r\n                {\r\n                    var nameTokens = Tokenize(product.Name)\r\n                        .Select(t => t.ToLowerInvariant())\r\n                        .ToArray();\r\n\r\n                    if (nameTokens.Length == 0)\r\n                        return (product, score: 0.0, matchCount: 0, wordCount: 0);\r\n\r\n                    int matchCount = nameTokens.Count(t => descTokens.Contains(t));\r\n                    int wordCount = nameTokens.Length;\r\n                    double score = wordCount == 0 ? 0.0 : (double)matchCount / wordCount;\r\n\r\n                    return (product, score, matchCount, wordCount);\r\n                })\r\n                .Where(x => x.matchCount > 0)\r\n                .OrderByDescending(x => x.score)\r\n                .ThenByDescending(x => x.matchCount)\r\n                .ThenBy(x => x.wordCount)\r\n                .Take(topCount)\r\n                .Select(x => new ProductMatchResult(x.product, x.score)","range":{"startLineNumber":30,"startColumn":13,"endLineNumber":72,"endColumn":39}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\Abstractions\\IOpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Abstractions/IOpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/Abstractions/IOpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","epoch":28,"edits":[{"text":"MatchResult","range":{"startLineNumber":26,"startColumn":49,"endLineNumber":26,"endColumn":49}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\UseCases\\Intent\\ClassifyIntent\\ClassifyIntentQueryHandler.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","epoch":29,"edits":[{"text":"MatchResult> SearchProducts(string[] keywords)\r\n            {\r\n                _logger.LogInformation(\"Function calling: buscando produtos com keywords: {Keywords}\", \r\n                    string.Join(\", \", keywords));\r\n\r\n                var results = new List<Domain.Entities.ProductMatchResult>();\r\n                foreach (var keyword in keywords)\r\n                {\r\n                    var matches = _productMatching.FindTopMatchingProductsWithScore(\r\n                        allProducts,\r\n                        keyword,\r\n                        TopCandidatesPerKeyword);\r\n                    \r\n                    // Adicionar apenas produtos não duplicados\r\n                    foreach (var match in matches)\r\n                    {\r\n                        if (!results.Any(r => r.Product.Code == match.Product.Code))\r\n                        {\r\n                            results.Add(match","range":{"startLineNumber":50,"startColumn":50,"endLineNumber":68,"endColumn":48}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","epoch":32,"edits":[{"text":"MatchResult>> productSearchFunction,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries)\r\n        {\r\n            try\r\n            {\r\n                var arguments = JsonSerializer.Deserialize<SearchProductsArguments>(toolCall.FunctionArguments);\r\n                var keywords = arguments?.Keywords ?? Array.Empty<string>();\r\n\r\n                _logger.LogInformation(\"Buscando produtos com keywords: {Keywords}\", string.Join(\", \", keywords));\r\n\r\n                var foundMatches = productSearchFunction(keywords);\r\n                allFoundProducts.AddRange(foundMatches\r\n                    .Where(m => !allFoundProducts.Any(ap => ap.Code == m.Product.Code))\r\n                    .Select(m => m.Product));\r\n\r\n                // Registrar a busca realizada (keywords + produtos retornados)\r\n                var productsReturned = foundMatches\r\n                    .Select(m => new ProductCandidate(m.Product.Code, m.Product.Name))\r\n                    .ToList();\r\n                searchQueries.Add(new ProductSearchQuery(keywords, productsReturned));\r\n\r\n                _logger.LogInformation(\"Encontrados {Count} produtos para as keywords\", foundMatches.Count);\r\n\r\n                if (foundMatches.Count == 0)\r\n                {\r\n                    return \"Nenhum produto encontrado para as palavras-chave fornecidas.\";\r\n                }\r\n\r\n                var sb = new StringBuilder();\r\n                sb.AppendLine($\"Encontrados {foundMatches.Count} produtos (ordenados por percentual de acerto):\");\r\n                foreach (var match in foundMatches)\r\n                {\r\n                    sb.AppendLine($\"- Código: {match.Product.Code} | Nome: {match.Product.Name} | Acerto: {match.MatchPercentage}%","range":{"startLineNumber":166,"startColumn":49,"endLineNumber":197,"endColumn":84}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","epoch":33,"edits":[{"text":"MatchResult","range":{"startLineNumber":42,"startColumn":49,"endLineNumber":42,"endColumn":49}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","epoch":36,"edits":[{"text":"### Estratégia de Busca (OBRIGATÓRIA):\r\n\r\nQuando o texto contém termos que PODEM ser um produto único OU múltiplos produtos (ex: \"\"PROMO SUPER 30D + DEG HBO 30D\"\"), siga esta ordem:\r\n\r\n**Passo 1 - Buscar o texto completo/combinado primeiro:**\r\n- Faça `search_products` com o nome completo: ex: [\"\"PROMO SUPER 30D + DEG HBO 30D\"\", \"\"PROMO SUPER 30D DEG HBO 30D\"\"]\r\n- Avalie o percentual de acerto (%) retornado para cada resultado.\r\n\r\n**Passo 2 - Avaliar os resultados:**\r\n- Se encontrou um produto com acerto >= 80%, use-o como produto ÚNICO (é um pacote/combo real no catálogo).\r\n- Se NÃO encontrou nenhum produto com acerto >= 80%, trate como MÚLTIPLOS produtos separados.\r\n\r\n**Passo 3 - Se for múltiplos produtos, buscar cada um separadamente:**\r\n- Faça buscas separadas para cada componente:\r\n  - search_products([\"\"PROMO SUPER 30D\"\", \"\"PROMO SUPER\"\"])\r\n  - search_products([\"\"DEG HBO 30D\"\", \"\"DEG HBO\"\", \"\"DEGUSTAÇÃO HBO\"\"])\r\n- Para cada componente, escolha o produto com MAIOR percentual de acerto.\r\n\r\n### Uso do Percentual de Acerto (%)\r\n\r\nOs resultados de `search_products` incluem o percentual de acerto para cada produto.\r\n- **Sempre prefira o produto com maior percentual de acerto.**\r\n- Se dois produtos têm acerto similar (diferença < 5%), prefira o que tem nome mais próximo ao texto original.\r\n- O percentual indica quantas palavras do nome do produto foram encontradas na busca.\r\n\r\nExemplo de resultado:\r\n```\r\n- Código: 1-21D3Z3E | Nome: PROMO SUPER 30D + DEG HBO 30D | Acerto: 100%\r\n- Código: 1-20XSM69 | Nome: SUPER 30D FAIXA 3 | Acerto: 40%\r\n```\r\n→ Escolha o produto com 100% de acert","range":{"startLineNumber":31,"startColumn":1,"endLineNumber":42,"endColumn":98}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","epoch":38,"edits":[{"text":".\r\n\r\n**Se a busca combinada NÃO encontrou match >= 80%, retorne cada produto separadamente:**\r\nExemplo: \"\"incluir a recarga: PROMO SUPER 30D + DEG HBO 30D\"\" → busca combinada não encontrou match >= 80% → 2 produtos separados, ambos com action=\"\"product-add\"\"\r\n\r\n**Cada produto separado DEVE ter sua própria entrada em classifiedProducts:**\r\n- `productName` deve conter o nome INDIVIDUAL do produto como mencionado no texto.\r\n- `productCode` deve ser o código do produto com MAIOR percentual de acerto na busca individual.\r\n\r\n**Se a busca combinada encontrou match >= 80%, retorne como produto ÚNICO:**\r\nExemplo: \"\"PROMO SUPER 30D + DEG HBO 30D\"\" existe no catálogo com 100% → 1 produto com o código do catálogo.\r\n\r\n**CORRETO (quando separados - sem match combinado >= 80%):**\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código-promo-super\"\", \"\"productName\"\": \"\"PROMO SUPER 30D\"\", \"\"action\"\": \"\"product-add\"\" },\r\n    { \"\"productCode\"\": \"\"código-deg-hbo\"\", \"\"productName\"\": \"\"DEG HBO 30D\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ]\r\n}\r\n```\r\n\r\n**CORRETO (quando combinado - match combinado >= 80%):**\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [","range":{"startLineNumber":98,"startColumn":63,"endLineNumber":128,"endColumn":124}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","epoch":40,"edits":[{"text":"Sempre use o produto com MAIOR percentual de acerto (%) na busca.**\r\n- **Para textos com `+`, `,`, `e`, `ou`: busque PRIMEIRO o texto combinado. Se acerto >= 80%, retorne como produto único. Caso contrário, busque cada componente separadamente","range":{"startLineNumber":155,"startColumn":5,"endLineNumber":156,"endColumn":246}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","epoch":42,"edits":[{"text":"Retorna produtos com percentual de acerto (%). Use esta ferramenta para encontrar produtos mencionados no texto do usuário. IMPORTANTE: Primeiro busque o nome completo/combinado. Se nenhum resultado tiver acerto >= 80%, busque cada produto separadamente","range":{"startLineNumber":148,"startColumn":86,"endLineNumber":148,"endColumn":288}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","epoch":44,"edits":[{"text":"Pode incluir nomes combinados (ex: 'PROMO SUPER 30D + DEG HBO 30D') para verificar se existe como produto único. Os resultados incluem percentual de acerto (%).","range":{"startLineNumber":156,"startColumn":249,"endLineNumber":156,"endColumn":325}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","epoch":46,"edits":[{"text":"Use o percentual de acerto (%) para decidir se o produto é combinado (>= 80%) ou deve ser separado (< 80%)","range":{"startLineNumber":132,"startColumn":3,"endLineNumber":132,"endColumn":133}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\Models\\IntentClassificationResult.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","scheme":"file"},"requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","epoch":61,"edits":[{"text":"","range":{"startLineNumber":92,"startColumn":1,"endLineNumber":115,"endColumn":1}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\Contracts\\IntentClassifications\\IntentClassificationsResponse.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","scheme":"file"},"requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","epoch":62,"edits":[{"text":"","range":{"startLineNumber":84,"startColumn":1,"endLineNumber":107,"endColumn":1}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\Mappings\\IntentClassificationMappingExtensions.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Mappings/IntentClassificationMappingExtensions.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/Mappings/IntentClassificationMappingExtensions.cs","scheme":"file"},"requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","epoch":63,"edits":[{"text":"result.Log","range":{"startLineNumber":24,"startColumn":23,"endLineNumber":30,"endColumn":18}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\Models\\IntentClassificationResult.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","scheme":"file"},"requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","epoch":64,"edits":[{"text":"string Log { get; init; } = string.Empty","range":{"startLineNumber":49,"startColumn":16,"endLineNumber":49,"endColumn":78}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\Contracts\\IntentClassifications\\IntentClassificationsResponse.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","scheme":"file"},"requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","epoch":65,"edits":[{"text":"string Log { get; init; } = string.Empty","range":{"startLineNumber":48,"startColumn":16,"endLineNumber":48,"endColumn":94}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","epoch":68,"edits":[{"text":"","range":{"startLineNumber":400,"startColumn":1,"endLineNumber":408,"endColumn":1}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","epoch":69,"edits":[{"text":"logMessage","range":{"startLineNumber":323,"startColumn":23,"endLineNumber":327,"endColumn":18}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","epoch":70,"edits":[{"text":"log = parsed.TryGetValue(\"log\", out var logVal) ? logVal?.ToString() ?? string.Empty : string.Empty;\r\n\r\n            var result = new IntentClassificationResult\r\n            {\r\n                Description = description,\r\n                ClassifiedProducts = classifiedProducts,\r\n                Keywords = keywords,\r\n                Log = log","range":{"startLineNumber":236,"startColumn":17,"endLineNumber":250,"endColumn":18}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","epoch":71,"edits":[{"text":"","range":{"startLineNumber":214,"startColumn":51,"endLineNumber":215,"endColumn":56}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","epoch":72,"edits":[{"text":"","range":{"startLineNumber":132,"startColumn":100,"endLineNumber":132,"endColumn":118}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","epoch":73,"edits":[{"text":"                        }\r\n                        else\r\n                        {\r\n                            _logger.LogWarning(\"Ferramenta desconhecida solicitada: {ToolName}\", toolCall.FunctionName);\r\n                            messages.Add(new ToolChatMessage(toolCall.Id, \"Ferramenta não reconhecida.\")","range":{"startLineNumber":92,"startColumn":1,"endLineNumber":112,"endColumn":30}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_7597ad00-1d79-4bd5-bd07-c8d932ce02d9","epoch":74,"edits":[{"text":"","range":{"startLineNumber":50,"startColumn":64,"endLineNumber":51,"endColumn":69}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\Models\\IntentClassificationResult.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","scheme":"file"},"requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","epoch":86,"edits":[{"text":",\r\n        double MatchPercentage","range":{"startLineNumber":82,"startColumn":27,"endLineNumber":82,"endColumn":27}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\Contracts\\IntentClassifications\\IntentClassificationsResponse.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","scheme":"file"},"requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","epoch":87,"edits":[{"text":",\r\n        double MatchPercentage","range":{"startLineNumber":82,"startColumn":27,"endLineNumber":82,"endColumn":27}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\Mappings\\IntentClassificationMappingExtensions.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Mappings/IntentClassificationMappingExtensions.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/Mappings/IntentClassificationMappingExtensions.cs","scheme":"file"},"requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","epoch":88,"edits":[{"text":"MatchedProducts = result.MatchedProducts,\r\n                UnmatchedProducts = result.UnmatchedProducts,\r\n                SearchQueries = result.SearchQueries\r\n                    .Select(q => new ProductSearchQueryResponse(\r\n                        q.Keywords,\r\n                        q.ProductsReturned\r\n                            .Select(p => new ProductCandidateResponse(p.ProductCode, p.ProductName, p.MatchPercentag","range":{"startLineNumber":25,"startColumn":17,"endLineNumber":30,"endColumn":98}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","epoch":89,"edits":[{"text":"MatchedProducts = matchedProducts,\r\n                ","range":{"startLineNumber":227,"startColumn":17,"endLineNumber":227,"endColumn":17}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\UseCases\\Intent\\ClassifyIntent\\ClassifyIntentQueryHandler.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs","scheme":"file"},"requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","epoch":90,"edits":[{"text":"MatchedProducts = classificationResult.MatchedProducts,\r\n                ","range":{"startLineNumber":99,"startColumn":17,"endLineNumber":99,"endColumn":17}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\Models\\IntentClassificationResult.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","scheme":"file"},"requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","epoch":91,"edits":[{"text":"that were successfully matched in the catalog (match >= 80%).\r\n        /// </summary>\r\n        public IReadOnlyList<string> MatchedProducts { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// List of product names ","range":{"startLineNumber":58,"startColumn":35,"endLineNumber":58,"endColumn":35}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\Contracts\\IntentClassifications\\IntentClassificationsResponse.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","scheme":"file"},"requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","epoch":92,"edits":[{"text":"that were successfully matched in the catalog (match >= 80%).\r\n        /// </summary>\r\n        public IReadOnlyList<string> MatchedProducts { get; init; } = new List<string>();\r\n\r\n        /// <summary>\r\n        /// List of product names ","range":{"startLineNumber":51,"startColumn":35,"endLineNumber":51,"endColumn":35}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","epoch":93,"edits":[{"text":", 0))\r\n                .ToList();\r\n\r\n            // Extrair nomes dos produtos com match > 80% (a partir dos searchQueries)\r\n            var matchedProducts = searchQueries\r\n                .SelectMany(q => q.ProductsReturned)\r\n                .Where(p => p.MatchPercentage > 80)\r\n                .Select(p => p.ProductName)\r\n                .Distinct(","range":{"startLineNumber":200,"startColumn":65,"endLineNumber":200,"endColumn":66}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","epoch":94,"edits":[{"text":"\r\n                // Somente considerar produtos com mais de 80% de match\r\n                var qualifiedMatches = foundMatches\r\n                    .Where(m => m.MatchPercentage > 80)\r\n                    .ToList();\r\n\r\n                allFoundProducts.AddRange(qualifiedMatches\r\n                    .Where(m => !allFoundProducts.Any(ap => ap.Code == m.Product.Code))\r\n                    .Select(m => m.Product));\r\n\r\n                // Registrar a busca realizada (keywords + TODOS os produtos retornados com percentual)\r\n                var productsReturned = foundMatches\r\n                    .Select(m => new ProductCandidate(m.Product.Code, m.Product.Name, m.MatchPercentag","range":{"startLineNumber":161,"startColumn":1,"endLineNumber":167,"endColumn":84}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","epoch":96,"edits":[{"text":", 0","range":{"startLineNumber":315,"startColumn":69,"endLineNumber":315,"endColumn":69}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Settings\\AzureOpenAiSettings.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Settings/AzureOpenAiSettings.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Settings/AzureOpenAiSettings.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":113,"edits":[{"text":"\r\n        /// <summary>\r\n        /// Minimum match percentage threshold for a product to be considered a valid match.\r\n        /// Products with match percentage above this value will be included in results.\r\n        /// Default: 80\r\n        /// </summary>\r\n        public double MinMatchPercentage { get; set; } = 80;\r\n","range":{"startLineNumber":14,"startColumn":1,"endLineNumber":14,"endColumn":1}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\appsettings.json","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/appsettings.json","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/appsettings.json","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":114,"edits":[{"text":",\r\n    \"MinMatchPercentage\": 80","range":{"startLineNumber":6,"startColumn":31,"endLineNumber":6,"endColumn":31}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":115,"edits":[{"text":"MinMatchPercentage% (a partir dos searchQueries)\r\n            var matchedProducts = searchQueries\r\n                .SelectMany(q => q.ProductsReturned)\r\n                .Where(p => p.MatchPercentage > _settings.MinMatchPercentage","range":{"startLineNumber":209,"startColumn":55,"endLineNumber":212,"endColumn":51}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":116,"edits":[{"text":"{minMatchPercentage}","range":{"startLineNumber":156,"startColumn":90,"endLineNumber":156,"endColumn":92}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\Models\\IntentClassificationResult.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":117,"edits":[{"text":"above configured MinMatchPercentage","range":{"startLineNumber":58,"startColumn":88,"endLineNumber":58,"endColumn":94}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\Contracts\\IntentClassifications\\IntentClassificationsResponse.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":118,"edits":[{"text":"above configured MinMatchPercentage","range":{"startLineNumber":51,"startColumn":88,"endLineNumber":51,"endColumn":94}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":119,"edits":[{"text":"MinMatchPercentage% de match\r\n                var qualifiedMatches = foundMatches\r\n                    .Where(m => m.MatchPercentage > _settings.MinMatchPercentage","range":{"startLineNumber":162,"startColumn":60,"endLineNumber":164,"endColumn":55}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":120,"edits":[{"text":"{minMatchPercentage}%) ou deve ser separado (< {minMatchPercentage}","range":{"startLineNumber":132,"startColumn":76,"endLineNumber":132,"endColumn":107}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":121,"edits":[{"text":"$\"Busca produtos no catálogo por palavras-chave. Retorna produtos com percentual de acerto (%). Use esta ferramenta para encontrar produtos mencionados no texto do usuário. IMPORTANTE: Primeiro busque o nome completo/combinado. Se nenhum resultado tiver acerto >= {_settings.MinMatchPercentage}","range":{"startLineNumber":131,"startColumn":38,"endLineNumber":131,"endColumn":303}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":122,"edits":[{"text":"{minMatchPercentage}","range":{"startLineNumber":120,"startColumn":50,"endLineNumber":120,"endColumn":52}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":123,"edits":[{"text":"_settings.MinMatchPercentage","range":{"startLineNumber":48,"startColumn":73,"endLineNumber":48,"endColumn":73}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":124,"edits":[{"text":"{minMatchPercentage}%, retorne como produto ÚNICO:**\r\nExemplo: \"\"PROMO SUPER 30D + DEG HBO 30D\"\" existe no catálogo com 100% → 1 produto com o código do catálogo.\r\n\r\n**CORRETO (quando separados - sem match combinado >= {minMatchPercentage}","range":{"startLineNumber":107,"startColumn":43,"endLineNumber":110,"endColumn":56}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":125,"edits":[{"text":"{minMatchPercentage}%, retorne cada produto separadamente:**\r\nExemplo: \"\"incluir a recarga: PROMO SUPER 30D + DEG HBO 30D\"\" → busca combinada não encontrou match >= {minMatchPercentage}","range":{"startLineNumber":100,"startColumn":47,"endLineNumber":101,"endColumn":106}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":126,"edits":[{"text":"{minMatchPercentage}%, use-o como produto ÚNICO (é um pacote/combo real no catálogo).\r\n- Se NÃO encontrou nenhum produto com acerto >= {minMatchPercentage}","range":{"startLineNumber":40,"startColumn":41,"endLineNumber":41,"endColumn":51}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":127,"edits":[{"text":"double minMatchPercentage = 80","range":{"startLineNumber":5,"startColumn":46,"endLineNumber":5,"endColumn":46}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":129,"edits":[{"text":"##MIN_MATCH##%, use-o como produto ÚNICO (é um pacote/combo real no catálogo).\r\n- Se NÃO encontrou nenhum produto com acerto >= ##MIN_MATCH##%, trate como MÚLTIPLOS produtos separados.\r\n\r\n**Passo 3 - Se for múltiplos produtos, buscar cada um separadamente:**\r\n- Faça buscas separadas para cada componente:\r\n  - search_products([\"\"PROMO SUPER 30D\"\", \"\"PROMO SUPER\"\"])\r\n  - search_products([\"\"DEG HBO 30D\"\", \"\"DEG HBO\"\", \"\"DEGUSTAÇÃO HBO\"\"])\r\n- Para cada componente, escolha o produto com MAIOR percentual de acerto.\r\n\r\n### Uso do Percentual de Acerto (%)\r\n\r\nOs resultados de `search_products` incluem o percentual de acerto para cada produto.\r\n- **Sempre prefira o produto com maior percentual de acerto.**\r\n- Se dois produtos têm acerto similar (diferença < 5%), prefira o que tem nome mais próximo ao texto original.\r\n- O percentual indica quantas palavras do nome do produto foram encontradas na busca.\r\n\r\nExemplo de resultado:\r\n```\r\n- Código: 1-21D3Z3E | Nome: PROMO SUPER 30D + DEG HBO 30D | Acerto: 100%\r\n- Código: 1-20XSM69 | Nome: SUPER 30D FAIXA 3 | Acerto: 40%\r\n```\r\n→ Escolha o produto com 100% de acerto.\r\n\r\n## 2. Tratamento de Abreviações e Erros\r\n\r\n**Abreviações comuns que você deve expandir ao buscar:**\r\n- DEG = DEGUSTAÇÃO\r\n- PROMO = PROMOÇÃO ou PROMOCIONAL\r\n- 30D, 7D, 15D = 30 dias, 7 dias, 15 dias (período)\r\n- DEB/DEG = pode ser erro de digitação\r\n\r\n**Ao buscar, inclua variações:**\r\n- Termo original + termo expandido\r\n- Termos parciais do nome do produto\r\n- Combinações com e sem períodos (30D, 7D)\r\n\r\n## 3. Determinação da Ação\r\n\r\nPara CADA produto identificado, determine a ação correspondente:\r\n- `product-add`: inclusão, incluir, adicionar, ativar, ativação, liberação, reativação, pedido, destino, recarga\r\n- `product-remove`: cancelar, cancelamento, excluir, exclusão, retirada, origem, correção, duplicidade, remover\r\n- `none`: quando não for possível determinar a ação\r\n\r\n**Indicadores de ação no contexto:**\r\n- \"\"por favor incluir\"\" → product-add\r\n- \"\"ativar recarga\"\" → product-add\r\n- \"\"valor ficou liberado\"\" + \"\"incluir\"\" → product-add\r\n- \"\"cancelar\"\" → product-remove\r\n- \"\"retirar da grade\"\" → product-remove\r\n\r\n## 4. Tratamento de Valores e Preços\r\n\r\n**IGNORE valores monetários ao identificar produtos:**\r\n- \"\"R$ 89,91\"\", \"\"R  89,91\"\", \"\"89,91\"\" → não fazem parte do nome do produto\r\n- \"\"valor disponível: 129,80\"\" → contexto informativo, não é produto\r\n\r\n## 5. Múltiplos Produtos com Mesma Ação\r\n\r\nUm mesmo texto pode conter MÚLTIPLOS produtos com a MESMA ação.\r\n\r\n**Se a busca combinada NÃO encontrou match >= ##MIN_MATCH##%, retorne cada produto separadamente:**\r\nExemplo: \"\"incluir a recarga: PROMO SUPER 30D + DEG HBO 30D\"\" → busca combinada não encontrou match >= ##MIN_MATCH##% → 2 produtos separados, ambos com action=\"\"product-add\"\"\r\n\r\n**Cada produto separado DEVE ter sua própria entrada em classifiedProducts:**\r\n- `productName` deve conter o nome INDIVIDUAL do produto como mencionado no texto.\r\n- `productCode` deve ser o código do produto com MAIOR percentual de acerto na busca individual.\r\n\r\n**Se a busca combinada encontrou match >= ##MIN_MATCH##%, retorne como produto ÚNICO:**\r\nExemplo: \"\"PROMO SUPER 30D + DEG HBO 30D\"\" existe no catálogo com 100% → 1 produto com o código do catálogo.\r\n\r\n**CORRETO (quando separados - sem match combinado >= ##MIN_MATCH##%):**\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código-promo-super\"\", \"\"productName\"\": \"\"PROMO SUPER 30D\"\", \"\"action\"\": \"\"product-add\"\" },\r\n    { \"\"productCode\"\": \"\"código-deg-hbo\"\", \"\"productName\"\": \"\"DEG HBO 30D\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ]\r\n}\r\n```\r\n\r\n**CORRETO (quando combinado - match combinado >= ##MIN_MATCH##%):**\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código-combo\"\", \"\"productName\"\": \"\"PROMO SUPER 30D + DEG HBO 30D\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ]\r\n}\r\n```\r\n\r\n## 6. Formato de Resposta\r\n\r\nApós identificar todos os produtos e ações, retorne um objeto JSON.\r\n**Use o percentual de acerto (%) para decidir se o produto é combinado (>= ##MIN_MATCH##%) ou deve ser separado (< ##MIN_MATCH##%).**\r\n**Produtos mencionados no texto mas NÃO encontrados pelo search_products devem ser listados em unmatchedProducts.**\r\n\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código1\"\", \"\"productName\"\": \"\"Nome do Produto 1\"\", \"\"action\"\": \"\"product-add\"\" },\r\n    { \"\"productCode\"\": \"\"código2\"\", \"\"productName\"\": \"\"Nome do Produto 2\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ],\r\n  \"\"unmatchedProducts\"\": [\"\"Nome do Produto Não Encontrado\"\"],\r\n  \"\"keywords\"\": [\"\"incluir\"\", \"\"recarga\"\"],\r\n  \"\"log\"\": \"\"Explicação do raciocínio usado\"\"\r\n}\r\n```\r\n\r\n## 7. Regras Importantes\r\n\r\n- O output final deve ser APENAS o JSON sem texto adicional.\r\n- Use múltiplas chamadas a `search_products` para encontrar cada produto.\r\n- Jamais invente códigos de produtos. Use apenas os retornados pela função search_products.\r\n- keywords deve conter as palavras-chave de ação encontradas no texto.\r\n- **Se não conseguir determinar a ação, use action=\"\"none\"\".**\r\n- **Se o produto não for encontrado pelo search_products, adicione-o em `unmatchedProducts` (apenas o nome) e NÃO o inclua em `classifiedProducts`.**\r\n- **Sempre use o produto com MAIOR percentual de acerto (%) na busca.**\r\n- **Para textos com `+`, `,`, `e`, `ou`: busque PRIMEIRO o texto combinado. Se acerto >= ##MIN_MATCH##%, retorne como produto único. Caso contrário, busque cada componente separadamente.**\r\n\r\n## 8. Retorno com Ação ou Produto Não Identificado\r\n\r\nQuando não for possível identificar a ação OU o produto:\r\n- Se o produto foi buscado via search_products e NÃO foi encontrado, adicione o nome do produto em `unmatchedProducts` e NÃO o inclua em `classifiedProducts`.\r\n- Se a ação não puder ser determinada mas o produto existe, use action=\"\"none\"\" em `classifiedProducts`.\r\n\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [],\r\n  \"\"unmatchedProducts\"\": [\"\"Nome mencionado no texto\"\"],\r\n  \"\"keywords\"\": [],\r\n  \"\"log\"\": \"\"Produto não encontrado no catálogo\"\" \r\n}\r\n```\r\n\r\n## 9. Se Nenhum Produto For Mencionado no Texto\r\n\r\nSe o texto não mencionar nenhum produto, retorne:\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [],\r\n  \"\"unmatchedProducts\"\": [],\r\n  \"\"keywords\"\": [],\r\n  \"\"log\"\": \"\"Nenhum produto mencionado no texto\"\"\r\n}\r\n```\".Replace(\"##MIN_MATCH##\", minMatchPercentage.ToString(\"0.#\"))","range":{"startLineNumber":40,"startColumn":41,"endLineNumber":183,"endColumn":5}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Api\\appsettings.Development.json","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/appsettings.Development.json","path":"/d:/Repos/_sk/Sky.HubAI/src/Api/appsettings.Development.json","scheme":"file"},"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","epoch":132,"edits":[{"text":",\r\n    \"MinMatchPercentage\": 80","range":{"startLineNumber":6,"startColumn":31,"endLineNumber":6,"endColumn":31}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\Models\\IntentClassificationResult.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","scheme":"file"},"requestId":"request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539","epoch":140,"edits":[{"text":"from classified products.\r\n        /// Derived automatically from ClassifiedProducts.\r\n        /// </summary>\r\n        public IReadOnlyList<string> MatchedProducts => ClassifiedProducts\r\n            .Select(p => p.ProductName)\r\n            .Where(name => !string.IsNullOrWhiteSpace(name))\r\n            .Distinct()\r\n            .ToList","range":{"startLineNumber":58,"startColumn":35,"endLineNumber":60,"endColumn":87}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539","epoch":141,"edits":[{"text":"","range":{"startLineNumber":241,"startColumn":17,"endLineNumber":242,"endColumn":17}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Application\\UseCases\\Intent\\ClassifyIntent\\ClassifyIntentQueryHandler.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs","scheme":"file"},"requestId":"request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539","epoch":142,"edits":[{"text":"","range":{"startLineNumber":99,"startColumn":17,"endLineNumber":100,"endColumn":17}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539","epoch":143,"edits":[{"text":"","range":{"startLineNumber":209,"startColumn":13,"endLineNumber":217,"endColumn":13}}]}],"epochCounter":144},"recentSnapshot":{"entries":[{"resource":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","languageId":"csharp","originalHash":"1be94e8","currentHash":"1be94e8","state":1,"snapshotUri":"chat-editing-snapshot-text-model:/d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs?%7B%22session%22%3A%7B%22%24mid%22%3A1%2C%22external%22%3A%22vscode-chat-session%3A%2F%2Flocal%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22path%22%3A%22%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22scheme%22%3A%22vscode-chat-session%22%2C%22authority%22%3A%22local%22%7D%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-opus-4.6","modeId":"agent"}},{"resource":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Domain/Entities/Product.cs","languageId":"csharp","originalHash":"9b0dbe0","currentHash":"9b0dbe0","state":1,"snapshotUri":"chat-editing-snapshot-text-model:/d%3A/Repos/_sk/Sky.HubAI/src/Domain/Entities/Product.cs?%7B%22session%22%3A%7B%22%24mid%22%3A1%2C%22external%22%3A%22vscode-chat-session%3A%2F%2Flocal%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22path%22%3A%22%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22scheme%22%3A%22vscode-chat-session%22%2C%22authority%22%3A%22local%22%7D%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-opus-4.6","modeId":"agent"}},{"resource":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Domain/Services/Interfaces/IProductMatchingService.cs","languageId":"csharp","originalHash":"3b569cf","currentHash":"3b569cf","state":1,"snapshotUri":"chat-editing-snapshot-text-model:/d%3A/Repos/_sk/Sky.HubAI/src/Domain/Services/Interfaces/IProductMatchingService.cs?%7B%22session%22%3A%7B%22%24mid%22%3A1%2C%22external%22%3A%22vscode-chat-session%3A%2F%2Flocal%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22path%22%3A%22%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22scheme%22%3A%22vscode-chat-session%22%2C%22authority%22%3A%22local%22%7D%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-opus-4.6","modeId":"agent"}},{"resource":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Domain/Services/Implementations/ProductMatchingService.cs","languageId":"csharp","originalHash":"1489937","currentHash":"1489937","state":1,"snapshotUri":"chat-editing-snapshot-text-model:/d%3A/Repos/_sk/Sky.HubAI/src/Domain/Services/Implementations/ProductMatchingService.cs?%7B%22session%22%3A%7B%22%24mid%22%3A1%2C%22external%22%3A%22vscode-chat-session%3A%2F%2Flocal%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22path%22%3A%22%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22scheme%22%3A%22vscode-chat-session%22%2C%22authority%22%3A%22local%22%7D%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-opus-4.6","modeId":"agent"}},{"resource":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs","languageId":"csharp","originalHash":"3ebc1c4","currentHash":"3ebc1c4","state":1,"snapshotUri":"chat-editing-snapshot-text-model:/d%3A/Repos/_sk/Sky.HubAI/src/Application/UseCases/Intent/ClassifyIntent/ClassifyIntentQueryHandler.cs?%7B%22session%22%3A%7B%22%24mid%22%3A1%2C%22external%22%3A%22vscode-chat-session%3A%2F%2Flocal%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22path%22%3A%22%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22scheme%22%3A%22vscode-chat-session%22%2C%22authority%22%3A%22local%22%7D%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-opus-4.6","modeId":"agent"}},{"resource":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Abstractions/IOpenAiIntentClassifyService.cs","languageId":"csharp","originalHash":"6950411","currentHash":"6950411","state":1,"snapshotUri":"chat-editing-snapshot-text-model:/d%3A/Repos/_sk/Sky.HubAI/src/Application/Abstractions/IOpenAiIntentClassifyService.cs?%7B%22session%22%3A%7B%22%24mid%22%3A1%2C%22external%22%3A%22vscode-chat-session%3A%2F%2Flocal%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22path%22%3A%22%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22scheme%22%3A%22vscode-chat-session%22%2C%22authority%22%3A%22local%22%7D%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_49043e35-303e-4ac3-91d7-e0f94ee08aba","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-opus-4.6","modeId":"agent"}},{"resource":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","languageId":"csharp","originalHash":"e7a9c26","currentHash":"e7a9c26","state":1,"snapshotUri":"chat-editing-snapshot-text-model:/d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs?%7B%22session%22%3A%7B%22%24mid%22%3A1%2C%22external%22%3A%22vscode-chat-session%3A%2F%2Flocal%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22path%22%3A%22%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22scheme%22%3A%22vscode-chat-session%22%2C%22authority%22%3A%22local%22%7D%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-opus-4.6","modeId":"agent"}},{"resource":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs","languageId":"csharp","originalHash":"a9c1fa8","currentHash":"a9c1fa8","state":1,"snapshotUri":"chat-editing-snapshot-text-model:/d%3A/Repos/_sk/Sky.HubAI/src/Api/Contracts/IntentClassifications/IntentClassificationsResponse.cs?%7B%22session%22%3A%7B%22%24mid%22%3A1%2C%22external%22%3A%22vscode-chat-session%3A%2F%2Flocal%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22path%22%3A%22%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22scheme%22%3A%22vscode-chat-session%22%2C%22authority%22%3A%22local%22%7D%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-opus-4.6","modeId":"agent"}},{"resource":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/Mappings/IntentClassificationMappingExtensions.cs","languageId":"csharp","originalHash":"1c32cfe","currentHash":"1c32cfe","state":1,"snapshotUri":"chat-editing-snapshot-text-model:/d%3A/Repos/_sk/Sky.HubAI/src/Api/Mappings/IntentClassificationMappingExtensions.cs?%7B%22session%22%3A%7B%22%24mid%22%3A1%2C%22external%22%3A%22vscode-chat-session%3A%2F%2Flocal%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22path%22%3A%22%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22scheme%22%3A%22vscode-chat-session%22%2C%22authority%22%3A%22local%22%7D%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_7940bb37-9bec-489b-9854-972e458844d6","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-opus-4.6","modeId":"agent"}},{"resource":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs","languageId":"csharp","originalHash":"7f1346e","currentHash":"7f1346e","state":1,"snapshotUri":"chat-editing-snapshot-text-model:/d%3A/Repos/_sk/Sky.HubAI/src/Application/Models/IntentClassificationResult.cs?%7B%22session%22%3A%7B%22%24mid%22%3A1%2C%22external%22%3A%22vscode-chat-session%3A%2F%2Flocal%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22path%22%3A%22%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22scheme%22%3A%22vscode-chat-session%22%2C%22authority%22%3A%22local%22%7D%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_c4c7a76c-38d7-4b87-8f09-cc5ca8e92539","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-opus-4.6","modeId":"agent"}},{"resource":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Settings/AzureOpenAiSettings.cs","languageId":"csharp","originalHash":"8e6b565","currentHash":"8e6b565","state":1,"snapshotUri":"chat-editing-snapshot-text-model:/d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Settings/AzureOpenAiSettings.cs?%7B%22session%22%3A%7B%22%24mid%22%3A1%2C%22external%22%3A%22vscode-chat-session%3A%2F%2Flocal%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22path%22%3A%22%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22scheme%22%3A%22vscode-chat-session%22%2C%22authority%22%3A%22local%22%7D%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-opus-4.6","modeId":"agent"}},{"resource":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/appsettings.json","languageId":"json","originalHash":"abb2f3e","currentHash":"abb2f3e","state":1,"snapshotUri":"chat-editing-snapshot-text-model:/d%3A/Repos/_sk/Sky.HubAI/src/Api/appsettings.json?%7B%22session%22%3A%7B%22%24mid%22%3A1%2C%22external%22%3A%22vscode-chat-session%3A%2F%2Flocal%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22path%22%3A%22%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22scheme%22%3A%22vscode-chat-session%22%2C%22authority%22%3A%22local%22%7D%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-opus-4.6","modeId":"agent"}},{"resource":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Api/appsettings.Development.json","languageId":"json","originalHash":"47581f0","currentHash":"47581f0","state":1,"snapshotUri":"chat-editing-snapshot-text-model:/d%3A/Repos/_sk/Sky.HubAI/src/Api/appsettings.Development.json?%7B%22session%22%3A%7B%22%24mid%22%3A1%2C%22external%22%3A%22vscode-chat-session%3A%2F%2Flocal%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22path%22%3A%22%2FMmE4M2ZlNTgtZTgyZS00Mzk4LTk0NjctY2JkYjhlMDdhYWY5%22%2C%22scheme%22%3A%22vscode-chat-session%22%2C%22authority%22%3A%22local%22%7D%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_c461a1a3-4de4-4857-825f-ce170dca8e15","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-opus-4.6","modeId":"agent"}}]}}