using MediatR;
using Microsoft.Extensions.Logging;
using Sky.HubAI.Application.Abstractions;
using Sky.HubAI.Application.Models;
using Sky.HubAI.Domain.Services.Interfaces;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace Sky.HubAI.Application.UseCases.Intent.ClassifyIntent
{
    /// <summary>
    /// Use case handler for classifying user intent from text descriptions.
    /// Orchestrates: product search via function calling, calling AI service, normalizing results.
    /// </summary>
    public class ClassifyIntentQueryHandler : IRequestHandler<ClassifyIntentQuery, ClassifyIntentResult>
    {
        private readonly IOpenAiIntentClassifyService _openAiService;
        private readonly IProductMemoryCacheService _productCache;
        private readonly IProductMatchingService _productMatching;
        private readonly ILogger<ClassifyIntentQueryHandler> _logger;

        private const int TopCandidatesPerKeyword = 10;

        public ClassifyIntentQueryHandler(
            IOpenAiIntentClassifyService openAiService,
            IProductMemoryCacheService productCache,
            IProductMatchingService productMatching,
            ILogger<ClassifyIntentQueryHandler> logger)
        {
            _openAiService = openAiService;
            _productCache = productCache;
            _productMatching = productMatching;
            _logger = logger;
        }

        public async Task<ClassifyIntentResult> Handle(ClassifyIntentQuery request, CancellationToken cancellationToken)
        {
            _logger.LogInformation(
                "Iniciando análise de intenção. Descrição: {DescriptionLength} caracteres",
                request.Description?.Length ?? 0);

            // 1. Buscar todos os produtos do cache (para uso na função de busca)
            var allProducts = _productCache.GetAllProducts();
            _logger.LogInformation("Produtos carregados do cache: {ProductCount}", allProducts.Count);

            // 2. Criar função de busca para function calling
            // Esta função será chamada pela LLM quando precisar buscar produtos
            IReadOnlyList<Domain.Entities.ProductMatchResult> SearchProducts(string[] keywords)
            {
                _logger.LogInformation("Function calling: buscando produtos com keywords: {Keywords}", 
                    string.Join(", ", keywords));

                var results = new List<Domain.Entities.ProductMatchResult>();
                foreach (var keyword in keywords)
                {
                    var matches = _productMatching.FindTopMatchingProductsWithScore(
                        allProducts,
                        keyword,
                        TopCandidatesPerKeyword);
                    
                    // Adicionar apenas produtos não duplicados
                    foreach (var match in matches)
                    {
                        if (!results.Any(r => r.Product.Code == match.Product.Code))
                        {
                            results.Add(match);
                        }
                    }
                }

                _logger.LogInformation("Function calling: encontrados {Count} produtos únicos", results.Count);
                return results;
            }

            // 3. Chamar serviço de IA com function calling
            var classificationResult = await _openAiService.ClassifyIntentAsync(
                request.Description,
                SearchProducts,
                cancellationToken);

            // 4. Normalizar ações de todos os produtos classificados (regra de aplicação)
            var normalizedProducts = classificationResult.ClassifiedProducts
                .Select(p => new ClassifiedProduct(
                    p.ProductCode,
                    p.ProductName,
                    NormalizeAction(p.Action)))
                .ToList();

            // 4.1 Determinar ação principal (none se ações mistas ou troca/substituição detectada)
            var mainAction = DetermineMainAction(normalizedProducts, request.Description);

            // 5. Construir resultado final
            var result = new ClassifyIntentResult(new IntentClassificationResult
            {
                Description = classificationResult.Description,
                Action = mainAction,
                ClassifiedProducts = normalizedProducts,
                Keywords = classificationResult.Keywords,
                Log = classificationResult.Log,
                PossibleProducts = classificationResult.PossibleProducts,
                UnmatchedProducts = classificationResult.UnmatchedProducts,
                SearchQueries = classificationResult.SearchQueries
            });

            _logger.LogInformation(
                "Classificação concluída. {ProductCount} produtos classificados. Primeiro: Action={Action}, ProductCode={ProductCode}",
                result.Data.ClassifiedProducts.Count,
                result.Data.Action,
                result.Data.ProductCode);

            return result;
        }

        /// <summary>
        /// Determines the main action for the classification result.
        /// Returns "none" when mixed actions are detected (both product-add and product-remove)
        /// or when swap/substitution keywords are found in the original description.
        /// Individual product actions remain unchanged.
        /// </summary>
        private string DetermineMainAction(List<ClassifiedProduct> products, string description)
        {
            if (products.Count == 0)
                return string.Empty;

            var distinctActions = products
                .Select(p => p.Action)
                .Where(a => a is "product-add" or "product-remove")
                .Distinct()
                .ToList();

            // Mixed actions (both add and remove) → none
            if (distinctActions.Count > 1)
            {
                _logger.LogWarning(
                    "Mixed actions detected (product-add + product-remove). Main action set to 'none' for human review.");
                return "none";
            }

            // Swap/substitution keywords in description → none
            if (ContainsSwapKeywords(description))
            {
                _logger.LogWarning(
                    "Swap/substitution keywords detected in description. Main action set to 'none' for human review.");
                return "none";
            }

            // Single action type → use it; otherwise fallback to first product's action
            return distinctActions.Count == 1
                ? distinctActions[0]
                : products[0].Action;
        }

        /// <summary>
        /// Checks if the description contains swap/substitution keywords
        /// that indicate the request involves replacing one product with another.
        /// </summary>
        private static bool ContainsSwapKeywords(string description)
        {
            if (string.IsNullOrWhiteSpace(description))
                return false;

            var normalized = description.ToLowerInvariant();

            var swapKeywords = new[]
            {
                "trocar", "troca", "substituir", "substituição", "subistituir",
                "migrar", "migração", "alterar pacote", "mudar para", "passar para",
                "não reconhece", "nao reconhece", "desconhece"
            };

            foreach (var keyword in swapKeywords)
            {
                if (normalized.Contains(keyword))
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Normalizes action names to standardized values.
        /// Application-level business rule for consistency.
        /// </summary>
        private static string NormalizeAction(string action)
        {
            if (string.IsNullOrWhiteSpace(action))
                return string.Empty;

            var normalized = action.Trim().ToLowerInvariant();

            // Mapeia ações conhecidas
            return normalized switch
            {
                "product-add" or "inclusão" or "incluir" or "adicionar" or "ativação" or "liberação" => "product-add",
                "product-remove" or "cancelamento" or "cancelar" or "retirada" or "excluir" or "exclusão" => "product-remove",
                "none" => "none",
                _ => string.Empty
            };
        }
    }
}