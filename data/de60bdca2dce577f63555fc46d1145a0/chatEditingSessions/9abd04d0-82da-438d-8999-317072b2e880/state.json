{"version":2,"initialFileContents":[["file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","a945786"],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","183ef26"]],"timeline":{"checkpoints":[{"checkpointId":"7d977067-7375-414a-aec4-997965d99fa9","epoch":0,"label":"Initial State","description":"Starting point before any edits"},{"checkpointId":"dc43288d-b904-4fae-8a97-bd4e4ac42493","requestId":"request_44493456-1cf2-4573-b4c9-ff2248a3a4b9","epoch":1,"label":"Request request_44493456-1cf2-4573-b4c9-ff2248a3a4b9"},{"checkpointId":"c558beec-0836-4f96-b747-0fd127036aec","requestId":"request_44493456-1cf2-4573-b4c9-ff2248a3a4b9","undoStopId":"090e22fc-1b27-4a35-a178-531eaf40a964","epoch":2,"label":"Request request_44493456-1cf2-4573-b4c9-ff2248a3a4b9 - Stop 090e22fc-1b27-4a35-a178-531eaf40a964"},{"checkpointId":"6a0c4754-c807-4ad5-bec4-9952eb361412","requestId":"request_44493456-1cf2-4573-b4c9-ff2248a3a4b9","undoStopId":"0184f18c-6cda-4e11-808f-2cd938f32c4a","epoch":5,"label":"Request request_44493456-1cf2-4573-b4c9-ff2248a3a4b9 - Stop 0184f18c-6cda-4e11-808f-2cd938f32c4a"},{"checkpointId":"8aec1ccb-db35-407a-a5f2-3af082539337","requestId":"request_be449d50-f2c8-4cdb-a299-5869e46a1a10","epoch":8,"label":"Request request_be449d50-f2c8-4cdb-a299-5869e46a1a10"},{"checkpointId":"8111b6e0-74d8-4b43-ba50-f4adb8a44050","requestId":"request_be449d50-f2c8-4cdb-a299-5869e46a1a10","undoStopId":"a5e34340-3ccf-4787-892d-c5a5f61431db","epoch":9,"label":"Request request_be449d50-f2c8-4cdb-a299-5869e46a1a10 - Stop a5e34340-3ccf-4787-892d-c5a5f61431db"}],"currentEpoch":12,"fileBaselines":[["file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs::request_44493456-1cf2-4573-b4c9-ff2248a3a4b9",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_44493456-1cf2-4573-b4c9-ff2248a3a4b9","content":"namespace Sky.HubAI.Infrastructure.OpenAI.Prompts\r\n{\r\n    public static class TextClassificationPrompt\r\n    {\r\n        public static string GetSystemPrompt() =>\r\n            @\"Você é um especialista em classificação de ações e produtos a partir de descrições textuais. Possui habilidade em interpretar textos com erros de grafia, identificar intenções implícitas e extrair informações estruturadas com precisão.\r\n\r\n# Task\r\n\r\nAnalisar descrições fornecidas em texto livre e classificar:\r\n(1) a ação a ser tomada para CADA produto mencionado (adição ou remoção);\r\n(2) Identificar o código de TODOS os produtos mencionados.\r\n\r\n# Context\r\n\r\nEste sistema processa solicitações de clientes que podem conter imprecisões ortográficas, palavras escritas em conjunto ou formatação irregular. A classificação precisa alimenta fluxos de trabalho operacionais, tornando a precisão crítica para o roteamento correto de tarefas e gestão de produtos.\r\n\r\n# Instructions\r\n\r\n1. Analise a descrição fornecida e identifique TODOS os produtos mencionados.\r\n   Use a função `search_products` para buscar produtos no catálogo com base nas palavras-chave extraídas do texto.\r\n   Você pode chamar a função múltiplas vezes se necessário para encontrar todos os produtos.\r\n\r\n2. Para CADA produto identificado, determine a ação correspondente:\r\n   - `product-add`: inclusão, adicionar, ativar, ativação, liberação, reativação, pedido, destino\r\n   - `product-remove`: cancelar, cancelamento, excluir, exclusão, retirada, origem, correção, duplicidade\r\n   - `none`: quando não for possível determinar a ação\r\n\r\n3. Um mesmo texto pode conter MÚLTIPLOS produtos com ações DIFERENTES.\r\n   Exemplo: \"\"Adicionar HBO Max e cancelar Telecine\"\" → 2 produtos com ações diferentes.\r\n\r\n4. Após identificar todos os produtos e ações, retorne um objeto JSON com a estrutura:\r\n   {\r\n     \"\"classifiedProducts\"\": [\r\n       { \"\"productCode\"\": \"\"código1\"\", \"\"productName\"\": \"\"Nome do Produto 1\"\", \"\"action\"\": \"\"product-add\"\" },\r\n       { \"\"productCode\"\": \"\"código2\"\", \"\"productName\"\": \"\"Nome do Produto 2\"\", \"\"action\"\": \"\"product-remove\"\" }\r\n     ],\r\n     \"\"keywords\"\": [\"\"keyword1\"\", \"\"keyword2\"\"],\r\n     \"\"log\"\": \"\"Explicação do raciocínio usado\"\"\r\n   }\r\n\r\n5. Regras importantes:\r\n   - O output final deve ser APENAS o JSON sem texto adicional.\r\n   - Em caso de ambiguidade sobre o produto, use os resultados da função search_products.\r\n   - Em caso de ambiguidade sobre a ação, use action = \"\"none\"\".\r\n   - Jamais invente códigos de produtos. Use apenas os retornados pela função search_products.\r\n   - keywords deve conter apenas palavras-chave de ação encontradas no texto.\r\n\r\n6. Se não conseguir identificar nenhum produto, retorne:\r\n   {\r\n     \"\"classifiedProducts\"\": [],\r\n     \"\"keywords\"\": [],\r\n     \"\"log\"\": \"\"Motivo pelo qual não foi possível identificar produtos\"\"\r\n   }\";\r\n    }\r\n}","epoch":3,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs::request_44493456-1cf2-4573-b4c9-ff2248a3a4b9",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_44493456-1cf2-4573-b4c9-ff2248a3a4b9","content":"using Azure;\r\nusing Azure.AI.OpenAI;\r\nusing Microsoft.Extensions.Logging;\r\nusing Microsoft.Extensions.Options;\r\nusing OpenAI.Chat;\r\nusing Sky.HubAI.Application.Abstractions;\r\nusing Sky.HubAI.Application.Models;\r\nusing Sky.HubAI.Domain.Entities;\r\nusing Sky.HubAI.Infrastructure.OpenAI.Prompts;\r\nusing Sky.HubAI.Infrastructure.OpenAI.Settings;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Sky.HubAI.Infrastructure.OpenAI.Services\r\n{\r\n    public class OpenAiIntentClassifyService : IOpenAiIntentClassifyService\r\n    {\r\n        private readonly AzureOpenAiSettings _settings;\r\n        private readonly AzureOpenAIClient _client;\r\n        private readonly ILogger<OpenAiIntentClassifyService> _logger;\r\n\r\n        private const string SearchProductsToolName = \"search_products\";\r\n        private const int MaxFunctionCallingIterations = 5;\r\n\r\n        public OpenAiIntentClassifyService(\r\n            IOptions<AzureOpenAiSettings> settings,\r\n            ILogger<OpenAiIntentClassifyService> logger)\r\n        {\r\n            _settings = settings.Value;\r\n            _client = new AzureOpenAIClient(new Uri(_settings.Endpoint), new AzureKeyCredential(_settings.ApiKey));\r\n            _logger = logger;\r\n        }\r\n\r\n        public async Task<IntentClassificationResult> ClassifyIntentAsync(\r\n            string description,\r\n            Func<string[], IReadOnlyList<Product>> productSearchFunction,\r\n            CancellationToken cancellationToken = default)\r\n        {\r\n            _logger.LogInformation(\"Iniciando classificação de intenção com function calling\");\r\n\r\n            var chatClient = _client.GetChatClient(_settings.DeploymentName);\r\n            var systemPrompt = TextClassificationPrompt.GetSystemPrompt();\r\n            var allFoundProducts = new List<Product>();\r\n            var searchQueries = new List<ProductSearchQuery>();\r\n\r\n            var messages = new List<ChatMessage>\r\n            {\r\n                new SystemChatMessage(systemPrompt),\r\n                new UserChatMessage(description)\r\n            };\r\n\r\n            var tools = new List<ChatTool> { CreateSearchProductsTool() };\r\n            var chatOptions = new ChatCompletionOptions\r\n            {\r\n                Tools = { tools[0] }\r\n            };\r\n\r\n            // Function calling loop\r\n            for (int iteration = 0; iteration < MaxFunctionCallingIterations; iteration++)\r\n            {\r\n                var response = await chatClient.CompleteChatAsync(messages, chatOptions, cancellationToken);\r\n                var chatCompletion = response?.Value;\r\n\r\n                if (chatCompletion == null)\r\n                {\r\n                    _logger.LogWarning(\"Modelo OpenAI retornou resposta vazia na iteração {Iteration}\", iteration);\r\n                    break;\r\n                }\r\n\r\n                // Check if the model wants to call a tool\r\n                if (chatCompletion.FinishReason == ChatFinishReason.ToolCalls)\r\n                {\r\n                    _logger.LogInformation(\"LLM solicitou chamada de ferramenta na iteração {Iteration}\", iteration);\r\n\r\n                    // Add assistant message with tool calls\r\n                    messages.Add(new AssistantChatMessage(chatCompletion));\r\n\r\n                    // Process each tool call\r\n                    foreach (var toolCall in chatCompletion.ToolCalls)\r\n                    {\r\n                        if (toolCall.FunctionName == SearchProductsToolName)\r\n                        {\r\n                            var toolResult = ProcessSearchProductsCall(toolCall, productSearchFunction, allFoundProducts, searchQueries);\r\n                            messages.Add(new ToolChatMessage(toolCall.Id, toolResult));\r\n                        }\r\n                        else\r\n                        {\r\n                            _logger.LogWarning(\"Ferramenta desconhecida solicitada: {ToolName}\", toolCall.FunctionName);\r\n                            messages.Add(new ToolChatMessage(toolCall.Id, \"Ferramenta não reconhecida.\"));\r\n                        }\r\n                    }\r\n\r\n                    continue; // Continue loop to get final response\r\n                }\r\n\r\n                // Final response - parse classification\r\n                if (chatCompletion.FinishReason == ChatFinishReason.Stop)\r\n                {\r\n                    var contentItems = chatCompletion.Content;\r\n                    if (contentItems == null || contentItems.Count == 0)\r\n                    {\r\n                        _logger.LogWarning(\"Resposta final sem conteúdo\");\r\n                        break;\r\n                    }\r\n\r\n                    var content = contentItems[0].Text;\r\n                    _logger.LogDebug(\"Resposta final da OpenAI: {ContentLength} caracteres\", content?.Length ?? 0);\r\n\r\n                    return ParseFinalResponse(description, content, allFoundProducts, searchQueries);\r\n                }\r\n\r\n                _logger.LogWarning(\"Finish reason inesperado: {FinishReason}\", chatCompletion.FinishReason);\r\n                break;\r\n            }\r\n\r\n            // Fallback if loop exhausted\r\n            _logger.LogWarning(\"Loop de function calling esgotado sem resposta final\");\r\n            return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Não foi possível obter classificação após múltiplas tentativas.\");\r\n        }\r\n\r\n        private ChatTool CreateSearchProductsTool()\r\n        {\r\n            return ChatTool.CreateFunctionTool(\r\n                functionName: SearchProductsToolName,\r\n                functionDescription: \"Busca produtos no catálogo por palavras-chave. Use esta ferramenta para encontrar produtos mencionados no texto do usuário.\",\r\n                functionParameters: BinaryData.FromString(\"\"\"\r\n                {\r\n                    \"type\": \"object\",\r\n                    \"properties\": {\r\n                        \"keywords\": {\r\n                            \"type\": \"array\",\r\n                            \"items\": { \"type\": \"string\" },\r\n                            \"description\": \"Lista de palavras-chave ou termos para buscar produtos (ex: ['HBO', 'Telecine', 'pacote futebol'])\"\r\n                        }\r\n                    },\r\n                    \"required\": [\"keywords\"]\r\n                }\r\n                \"\"\"));\r\n        }\r\n\r\n        private string ProcessSearchProductsCall(\r\n            ChatToolCall toolCall,\r\n            Func<string[], IReadOnlyList<Product>> productSearchFunction,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries)\r\n        {\r\n            try\r\n            {\r\n                var arguments = JsonSerializer.Deserialize<SearchProductsArguments>(toolCall.FunctionArguments);\r\n                var keywords = arguments?.Keywords ?? Array.Empty<string>();\r\n\r\n                _logger.LogInformation(\"Buscando produtos com keywords: {Keywords}\", string.Join(\", \", keywords));\r\n\r\n                var foundProducts = productSearchFunction(keywords);\r\n                allFoundProducts.AddRange(foundProducts.Where(p => !allFoundProducts.Any(ap => ap.Code == p.Code)));\r\n\r\n                // Registrar a busca realizada (keywords + produtos retornados)\r\n                var productsReturned = foundProducts\r\n                    .Select(p => new ProductCandidate(p.Code, p.Name))\r\n                    .ToList();\r\n                searchQueries.Add(new ProductSearchQuery(keywords, productsReturned));\r\n\r\n                _logger.LogInformation(\"Encontrados {Count} produtos para as keywords\", foundProducts.Count);\r\n\r\n                if (foundProducts.Count == 0)\r\n                {\r\n                    return \"Nenhum produto encontrado para as palavras-chave fornecidas.\";\r\n                }\r\n\r\n                var sb = new StringBuilder();\r\n                sb.AppendLine($\"Encontrados {foundProducts.Count} produtos:\");\r\n                foreach (var product in foundProducts)\r\n                {\r\n                    sb.AppendLine($\"- Código: {product.Code} | Nome: {product.Name}\");\r\n                }\r\n                return sb.ToString();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                _logger.LogError(ex, \"Erro ao processar chamada search_products\");\r\n                return \"Erro ao buscar produtos.\";\r\n            }\r\n        }\r\n\r\n        private IntentClassificationResult ParseFinalResponse(\r\n            string description,\r\n            string? content,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries)\r\n        {\r\n            var possibleProducts = allFoundProducts\r\n                .Select(p => new ProductCandidate(p.Code, p.Name))\r\n                .ToList();\r\n\r\n            if (string.IsNullOrWhiteSpace(content))\r\n            {\r\n                return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Resposta vazia do modelo.\");\r\n            }\r\n\r\n            var parsed = ParseResponseToDictionary(content);\r\n            if (parsed == null)\r\n            {\r\n                _logger.LogWarning(\"Falha ao interpretar JSON da resposta final\");\r\n                return CreateEmptyResult(description, allFoundProducts, searchQueries, \"Falha ao interpretar JSON da resposta.\");\r\n            }\r\n\r\n            var keywords = ExtractKeywords(parsed);\r\n            var classifiedProducts = ExtractClassifiedProducts(parsed, allFoundProducts);\r\n            var log = parsed.TryGetValue(\"log\", out var logVal) ? logVal?.ToString() ?? string.Empty : string.Empty;\r\n\r\n            var result = new IntentClassificationResult\r\n            {\r\n                Description = description,\r\n                ClassifiedProducts = classifiedProducts,\r\n                Keywords = keywords,\r\n                Log = log,\r\n                PossibleProducts = possibleProducts,\r\n                SearchQueries = searchQueries\r\n            };\r\n\r\n            _logger.LogInformation(\r\n                \"Classificação concluída. {ProductCount} produtos classificados\",\r\n                classifiedProducts.Count);\r\n\r\n            return result;\r\n        }\r\n\r\n        private IReadOnlyList<ClassifiedProduct> ExtractClassifiedProducts(\r\n            Dictionary<string, object>? parsed,\r\n            List<Product> allFoundProducts)\r\n        {\r\n            if (parsed == null) return Array.Empty<ClassifiedProduct>();\r\n\r\n            var result = new List<ClassifiedProduct>();\r\n\r\n            // Try to extract \"classifiedProducts\" array\r\n            if (parsed.TryGetValue(\"classifiedProducts\", out var productsVal) && productsVal is JsonElement jsonArray)\r\n            {\r\n                if (jsonArray.ValueKind == JsonValueKind.Array)\r\n                {\r\n                    foreach (var item in jsonArray.EnumerateArray())\r\n                    {\r\n                        var productCode = item.TryGetProperty(\"productCode\", out var codeEl) ? codeEl.GetString() ?? string.Empty : string.Empty;\r\n                        var productName = item.TryGetProperty(\"productName\", out var nameEl) ? nameEl.GetString() ?? string.Empty : string.Empty;\r\n                        var action = item.TryGetProperty(\"action\", out var actionEl) ? actionEl.GetString() ?? string.Empty : string.Empty;\r\n\r\n                        // If productName is empty, try to get from found products\r\n                        if (string.IsNullOrEmpty(productName) && !string.IsNullOrEmpty(productCode))\r\n                        {\r\n                            productName = allFoundProducts.FirstOrDefault(p => p.Code == productCode)?.Name ?? string.Empty;\r\n                        }\r\n\r\n                        if (!string.IsNullOrEmpty(productCode) || !string.IsNullOrEmpty(productName))\r\n                        {\r\n                            result.Add(new ClassifiedProduct(productCode, productName, action));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Fallback: try legacy single product format\r\n            if (result.Count == 0)\r\n            {\r\n                var action = parsed.TryGetValue(\"action\", out var actionVal) ? actionVal?.ToString() ?? string.Empty : string.Empty;\r\n                var productCode = parsed.TryGetValue(\"product_code\", out var codeVal) ? codeVal?.ToString() ?? string.Empty : string.Empty;\r\n                var productDescription = parsed.TryGetValue(\"productDescription\", out var descVal) ? descVal?.ToString() ?? string.Empty : string.Empty;\r\n\r\n                if (!string.IsNullOrEmpty(productCode) || !string.IsNullOrEmpty(productDescription))\r\n                {\r\n                    result.Add(new ClassifiedProduct(productCode, productDescription, action));\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private IntentClassificationResult CreateEmptyResult(\r\n            string description,\r\n            List<Product> allFoundProducts,\r\n            List<ProductSearchQuery> searchQueries,\r\n            string logMessage)\r\n        {\r\n            return new IntentClassificationResult\r\n            {\r\n                Description = description,\r\n                ClassifiedProducts = Array.Empty<ClassifiedProduct>(),\r\n                Keywords = Array.Empty<string>(),\r\n                Log = logMessage,\r\n                PossibleProducts = allFoundProducts\r\n                    .Select(p => new ProductCandidate(p.Code, p.Name))\r\n                    .ToList(),\r\n                SearchQueries = searchQueries\r\n            };\r\n        }\r\n\r\n        private IReadOnlyList<string> ExtractKeywords(Dictionary<string, object>? parsed)\r\n        {\r\n            if (parsed == null) return Array.Empty<string>();\r\n\r\n            if (parsed.TryGetValue(\"keywords\", out var keyVal) && keyVal != null)\r\n            {\r\n                if (keyVal is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.Array)\r\n                {\r\n                    return jsonElement.EnumerateArray()\r\n                        .Select(e => e.GetString() ?? string.Empty)\r\n                        .Where(s => !string.IsNullOrWhiteSpace(s))\r\n                        .ToList();\r\n                }\r\n\r\n                var str = keyVal.ToString() ?? string.Empty;\r\n                if (!string.IsNullOrWhiteSpace(str))\r\n                {\r\n                    return str.Split(new[] { ',', ';' }, StringSplitOptions.RemoveEmptyEntries)\r\n                        .Select(s => s.Trim())\r\n                        .Where(s => !string.IsNullOrWhiteSpace(s))\r\n                        .ToList();\r\n                }\r\n            }\r\n\r\n            return Array.Empty<string>();\r\n        }\r\n\r\n        private static Dictionary<string, object>? ParseResponseToDictionary(string content)\r\n        {\r\n            if (string.IsNullOrWhiteSpace(content))\r\n                return null;\r\n            try\r\n            {\r\n                content = content.Replace(\"```json\", \"\", StringComparison.OrdinalIgnoreCase)\r\n                                 .Replace(\"```\", \"\", StringComparison.OrdinalIgnoreCase)\r\n                                 .Trim();\r\n                var extractedData = JsonSerializer.Deserialize<Dictionary<string, object>>(content, new JsonSerializerOptions\r\n                {\r\n                    NumberHandling = JsonNumberHandling.AllowReadingFromString\r\n                });\r\n                return extractedData;\r\n            }\r\n            catch { return null; }\r\n        }\r\n\r\n        private class SearchProductsArguments\r\n        {\r\n            [JsonPropertyName(\"keywords\")]\r\n            public string[] Keywords { get; set; } = Array.Empty<string>();\r\n        }\r\n    }\r\n}","epoch":6,"telemetryInfo":{}}],["file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs::request_be449d50-f2c8-4cdb-a299-5869e46a1a10",{"uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_be449d50-f2c8-4cdb-a299-5869e46a1a10","content":"namespace Sky.HubAI.Infrastructure.OpenAI.Prompts\r\n{\r\n    public static class TextClassificationPrompt\r\n    {\r\n        public static string GetSystemPrompt() =>\r\n            @\"Você é um especialista em classificação de ações e produtos a partir de descrições textuais. Possui habilidade em interpretar textos com erros de grafia, identificar intenções implícitas e extrair informações estruturadas com precisão.\r\n\r\n# Task\r\n\r\nAnalisar descrições fornecidas em texto livre e classificar:\r\n(1) a ação a ser tomada para CADA produto mencionado (adição ou remoção);\r\n(2) Identificar o código de TODOS os produtos mencionados.\r\n\r\n# Context\r\n\r\nEste sistema processa solicitações de clientes que podem conter imprecisões ortográficas, palavras escritas em conjunto ou formatação irregular. A classificação precisa alimenta fluxos de trabalho operacionais, tornando a precisão crítica para o roteamento correto de tarefas e gestão de produtos.\r\n\r\n# Instructions\r\n\r\n## 1. Identificação de Produtos\r\n\r\nAnalise a descrição e identifique TODOS os produtos mencionados.\r\n\r\n**IMPORTANTE - Produtos podem estar listados de várias formas:**\r\n- Separados por `+` : \"\"PROMO SUPER 30D + DEG HBO 30D\"\"\r\n- Separados por `,` : \"\"HBO Max, Telecine, Premiere\"\"\r\n- Separados por `e`/`ou` : \"\"HBO e Telecine\"\"\r\n- Em texto corrido: \"\"incluir recarga PROMO SUPER 30D e também DEG HBO\"\"\r\n- Com valores/preços junto: \"\"PROMO SUPER 30D - R$ 89,91\"\"\r\n\r\n**Ao encontrar múltiplos produtos, busque CADA UM separadamente usando `search_products`.**\r\n\r\nExemplo: Para \"\"PROMO SUPER 30D + DEG HBO 30D\"\", faça buscas separadas:\r\n- search_products([\"\"PROMO SUPER 30D\"\", \"\"PROMO SUPER\"\"])\r\n- search_products([\"\"DEG HBO 30D\"\", \"\"DEG HBO\"\", \"\"HBO 30D\"\", \"\"DEGUSTAÇÃO HBO\"\"])\r\n\r\n## 2. Tratamento de Abreviações e Erros\r\n\r\n**Abreviações comuns que você deve expandir ao buscar:**\r\n- DEG = DEGUSTAÇÃO\r\n- PROMO = PROMOÇÃO ou PROMOCIONAL\r\n- 30D, 7D, 15D = 30 dias, 7 dias, 15 dias (período)\r\n- DEB/DEG = pode ser erro de digitação\r\n\r\n**Ao buscar, inclua variações:**\r\n- Termo original + termo expandido\r\n- Termos parciais do nome do produto\r\n- Combinações com e sem períodos (30D, 7D)\r\n\r\n## 3. Determinação da Ação\r\n\r\nPara CADA produto identificado, determine a ação correspondente:\r\n- `product-add`: inclusão, incluir, adicionar, ativar, ativação, liberação, reativação, pedido, destino, recarga\r\n- `product-remove`: cancelar, cancelamento, excluir, exclusão, retirada, origem, correção, duplicidade, remover\r\n- `none`: quando não for possível determinar a ação\r\n\r\n**Indicadores de ação no contexto:**\r\n- \"\"por favor incluir\"\" → product-add\r\n- \"\"ativar recarga\"\" → product-add\r\n- \"\"valor ficou liberado\"\" + \"\"incluir\"\" → product-add\r\n- \"\"cancelar\"\" → product-remove\r\n- \"\"retirar da grade\"\" → product-remove\r\n\r\n## 4. Tratamento de Valores e Preços\r\n\r\n**IGNORE valores monetários ao identificar produtos:**\r\n- \"\"R$ 89,91\"\", \"\"R  89,91\"\", \"\"89,91\"\" → não fazem parte do nome do produto\r\n- \"\"valor disponível: 129,80\"\" → contexto informativo, não é produto\r\n\r\n## 5. Múltiplos Produtos com Mesma Ação\r\n\r\nUm mesmo texto pode conter MÚLTIPLOS produtos com a MESMA ação:\r\nExemplo: \"\"incluir a recarga: PROMO SUPER 30D + DEG HBO 30D\"\" → 2 produtos, ambos com action=\"\"product-add\"\"\r\n\r\n## 6. Formato de Resposta\r\n\r\nApós identificar todos os produtos e ações, retorne um objeto JSON:\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código1\"\", \"\"productName\"\": \"\"Nome do Produto 1\"\", \"\"action\"\": \"\"product-add\"\" },\r\n    { \"\"productCode\"\": \"\"código2\"\", \"\"productName\"\": \"\"Nome do Produto 2\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ],\r\n  \"\"keywords\"\": [\"\"incluir\"\", \"\"recarga\"\"],\r\n  \"\"log\"\": \"\"Explicação do raciocínio usado\"\"\r\n}\r\n```\r\n\r\n## 7. Regras Importantes\r\n\r\n- O output final deve ser APENAS o JSON sem texto adicional.\r\n- Use múltiplas chamadas a `search_products` para encontrar cada produto.\r\n- Jamais invente códigos de produtos. Use apenas os retornados pela função search_products.\r\n- Se um produto não for encontrado pelo search_products, não o inclua no resultado.\r\n- keywords deve conter as palavras-chave de ação encontradas no texto.\r\n- Em caso de ambiguidade sobre a ação, use action=\"\"none\"\".\r\n\r\n## 8. Se Nenhum Produto For Encontrado\r\n\r\nRetorne:\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [],\r\n  \"\"keywords\"\": [],\r\n  \"\"log\"\": \"\"Motivo pelo qual não foi possível identificar produtos\"\"\r\n}\r\n```\";\r\n    }\r\n}","epoch":10,"telemetryInfo":{}}]],"operations":[{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_44493456-1cf2-4573-b4c9-ff2248a3a4b9","epoch":4,"edits":[{"text":"## 1. Identificação de Produtos\r\n\r\nAnalise a descrição e identifique TODOS os produtos mencionados.\r\n\r\n**IMPORTANTE - Produtos podem estar listados de várias formas:**\r\n- Separados por `+` : \"\"PROMO SUPER 30D + DEG HBO 30D\"\"\r\n- Separados por `,` : \"\"HBO Max, Telecine, Premiere\"\"\r\n- Separados por `e`/`ou` : \"\"HBO e Telecine\"\"\r\n- Em texto corrido: \"\"incluir recarga PROMO SUPER 30D e também DEG HBO\"\"\r\n- Com valores/preços junto: \"\"PROMO SUPER 30D - R$ 89,91\"\"\r\n\r\n**Ao encontrar múltiplos produtos, busque CADA UM separadamente usando `search_products`.**\r\n\r\nExemplo: Para \"\"PROMO SUPER 30D + DEG HBO 30D\"\", faça buscas separadas:\r\n- search_products([\"\"PROMO SUPER 30D\"\", \"\"PROMO SUPER\"\"])\r\n- search_products([\"\"DEG HBO 30D\"\", \"\"DEG HBO\"\", \"\"HBO 30D\"\", \"\"DEGUSTAÇÃO HBO\"\"])\r\n\r\n## 2. Tratamento de Abreviações e Erros\r\n\r\n**Abreviações comuns que você deve expandir ao buscar:**\r\n- DEG = DEGUSTAÇÃO\r\n- PROMO = PROMOÇÃO ou PROMOCIONAL\r\n- 30D, 7D, 15D = 30 dias, 7 dias, 15 dias (período)\r\n- DEB/DEG = pode ser erro de digitação\r\n\r\n**Ao buscar, inclua variações:**\r\n- Termo original + termo expandido\r\n- Termos parciais do nome do produto\r\n- Combinações com e sem períodos (30D, 7D)\r\n\r\n## 3. Determinação da Ação\r\n\r\nPara CADA produto identificado, determine a ação correspondente:\r\n- `product-add`: inclusão, incluir, adicionar, ativar, ativação, liberação, reativação, pedido, destino, recarga\r\n- `product-remove`: cancelar, cancelamento, excluir, exclusão, retirada, origem, correção, duplicidade, remover\r\n- `none`: quando não for possível determinar a ação\r\n\r\n**Indicadores de ação no contexto:**\r\n- \"\"por favor incluir\"\" → product-add\r\n- \"\"ativar recarga\"\" → product-add\r\n- \"\"valor ficou liberado\"\" + \"\"incluir\"\" → product-add\r\n- \"\"cancelar\"\" → product-remove\r\n- \"\"retirar da grade\"\" → product-remove\r\n\r\n## 4. Tratamento de Valores e Preços\r\n\r\n**IGNORE valores monetários ao identificar produtos:**\r\n- \"\"R$ 89,91\"\", \"\"R  89,91\"\", \"\"89,91\"\" → não fazem parte do nome do produto\r\n- \"\"valor disponível: 129,80\"\" → contexto informativo, não é produto\r\n\r\n## 5. Múltiplos Produtos com Mesma Ação\r\n\r\nUm mesmo texto pode conter MÚLTIPLOS produtos com a MESMA ação:\r\nExemplo: \"\"incluir a recarga: PROMO SUPER 30D + DEG HBO 30D\"\" → 2 produtos, ambos com action=\"\"product-add\"\"\r\n\r\n## 6. Formato de Resposta\r\n\r\nApós identificar todos os produtos e ações, retorne um objeto JSON:\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"código1\"\", \"\"productName\"\": \"\"Nome do Produto 1\"\", \"\"action\"\": \"\"product-add\"\" },\r\n    { \"\"productCode\"\": \"\"código2\"\", \"\"productName\"\": \"\"Nome do Produto 2\"\", \"\"action\"\": \"\"product-add\"\" }\r\n  ],\r\n  \"\"keywords\"\": [\"\"incluir\"\", \"\"recarga\"\"],\r\n  \"\"log\"\": \"\"Explicação do raciocínio usado\"\"\r\n}\r\n```\r\n\r\n## 7. Regras Importantes\r\n\r\n- O output final deve ser APENAS o JSON sem texto adicional.\r\n- Use múltiplas chamadas a `search_products` para encontrar cada produto.\r\n- Jamais invente códigos de produtos. Use apenas os retornados pela função search_products.\r\n- Se um produto não for encontrado pelo search_products, não o inclua no resultado.\r\n- keywords deve conter as palavras-chave de ação encontradas no texto.\r\n- Em caso de ambiguidade sobre a ação, use action=\"\"none\"\".\r\n\r\n## 8. Se Nenhum Produto For Encontrado\r\n\r\nRetorne:\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [],\r\n  \"\"keywords\"\": [],\r\n  \"\"log\"\": \"\"Motivo pelo qual não foi possível identificar produtos\"\"\r\n}\r\n```","range":{"startLineNumber":20,"startColumn":1,"endLineNumber":54,"endColumn":5}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Services\\OpenAiIntentClassifyService.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","scheme":"file"},"requestId":"request_44493456-1cf2-4573-b4c9-ff2248a3a4b9","epoch":7,"edits":[{"text":" IMPORTANTE: Faça buscas separadas para cada produto quando houver múltiplos produtos no texto (separados por +, vírgula, etc). Inclua variações e abreviações expandidas nas keywords (ex: DEG → DEGUSTAÇÃO).\",\r\n                functionParameters: BinaryData.FromString(\"\"\"\r\n                {\r\n                    \"type\": \"object\",\r\n                    \"properties\": {\r\n                        \"keywords\": {\r\n                            \"type\": \"array\",\r\n                            \"items\": { \"type\": \"string\" },\r\n                            \"description\": \"Lista de palavras-chave ou termos para buscar produtos. Para melhores resultados: use o nome completo do produto, variações com abreviações expandidas (DEG→DEGUSTAÇÃO, PROMO→PROMOÇÃO), e termos parciais. Exemplo: para 'DEG HBO 30D' use ['DEG HBO 30D', 'DEGUSTAÇÃO HBO', 'HBO 30D']","range":{"startLineNumber":131,"startColumn":162,"endLineNumber":139,"endColumn":143}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"d:\\Repos\\_sk\\Sky.HubAI\\src\\Infrastructure.OpenAI\\Prompts\\TextClassificationPrompt.cs","_sep":1,"external":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","path":"/d:/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","scheme":"file"},"requestId":"request_be449d50-f2c8-4cdb-a299-5869e46a1a10","epoch":11,"edits":[{"text":"keywords deve conter as palavras-chave de ação encontradas no texto.\r\n- **Se não conseguir determinar a ação, use action=\"\"none\"\".**\r\n- **Se o produto não for encontrado pelo search_products, inclua-o com productCode vazio e action=\"\"none\"\".**\r\n\r\n## 8. Retorno com Ação ou Produto Não Identificado\r\n\r\nQuando não for possível identificar a ação OU o produto, retorne action=\"\"none\"\":\r\n\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [\r\n    { \"\"productCode\"\": \"\"\"\", \"\"productName\"\": \"\"Nome mencionado no texto\"\", \"\"action\"\": \"\"none\"\" }\r\n  ],\r\n  \"\"keywords\"\": [],\r\n  \"\"log\"\": \"\"Produto não encontrado no catálogo\"\" \r\n}\r\n```\r\n\r\n## 9. Se Nenhum Produto For Mencionado no Texto\r\n\r\nSe o texto não mencionar nenhum produto, retorne:\r\n```json\r\n{\r\n  \"\"classifiedProducts\"\": [],\r\n  \"\"keywords\"\": [],\r\n  \"\"log\"\": \"\"Nenhum produto mencionado no texto","range":{"startLineNumber":94,"startColumn":3,"endLineNumber":105,"endColumn":68}}]}],"epochCounter":12},"recentSnapshot":{"entries":[{"resource":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs","languageId":"csharp","originalHash":"24474c6","currentHash":"24474c6","state":1,"snapshotUri":"chat-editing-snapshot-text-model:/d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Prompts/TextClassificationPrompt.cs?%7B%22session%22%3A%7B%22%24mid%22%3A1%2C%22external%22%3A%22vscode-chat-session%3A%2F%2Flocal%2FOWFiZDA0ZDAtODJkYS00MzhkLTg5OTktMzE3MDcyYjJlODgw%22%2C%22path%22%3A%22%2FOWFiZDA0ZDAtODJkYS00MzhkLTg5OTktMzE3MDcyYjJlODgw%22%2C%22scheme%22%3A%22vscode-chat-session%22%2C%22authority%22%3A%22local%22%7D%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_be449d50-f2c8-4cdb-a299-5869e46a1a10","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-opus-4.5","modeId":"agent"}},{"resource":"file:///d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs","languageId":"csharp","originalHash":"ebeb78a","currentHash":"ebeb78a","state":1,"snapshotUri":"chat-editing-snapshot-text-model:/d%3A/Repos/_sk/Sky.HubAI/src/Infrastructure.OpenAI/Services/OpenAiIntentClassifyService.cs?%7B%22session%22%3A%7B%22%24mid%22%3A1%2C%22external%22%3A%22vscode-chat-session%3A%2F%2Flocal%2FOWFiZDA0ZDAtODJkYS00MzhkLTg5OTktMzE3MDcyYjJlODgw%22%2C%22path%22%3A%22%2FOWFiZDA0ZDAtODJkYS00MzhkLTg5OTktMzE3MDcyYjJlODgw%22%2C%22scheme%22%3A%22vscode-chat-session%22%2C%22authority%22%3A%22local%22%7D%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_44493456-1cf2-4573-b4c9-ff2248a3a4b9","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-opus-4.5","modeId":"agent"}}]}}