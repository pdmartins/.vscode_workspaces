# Lessons Learned

Registro de aprendizados e decisões importantes do projeto.

---

## Estrutura

Cada lição segue o formato:

```xml
<lesson date="YYYY-MM-DD" category="categoria">
  <context>Contexto do problema</context>
  <decision>Decisão tomada</decision>
  <outcome>Resultado/impacto</outcome>
</lesson>
```

### Categorias

| Categoria | Descrição |
|-----------|-----------|
| arquitetura | Estrutura do projeto |
| padrões | Convenções de código |
| tooling | Ferramentas e configs |
| workflow | Processos |
| debug | Problemas resolvidos |
| performance | Otimizações |
| segurança | Práticas de segurança |

---

## Registro

<!-- Adicionar lições aqui, mais recente primeiro -->

<lesson date="2026-02-10" category="arquitetura">
  <context>Análise profunda revelou que API e Consumer possuem enums WorkStatus com valores numéricos divergentes (API: Processing=0, Completed=1, Pending=2 vs Consumer: Completed=0, Pending=1). Ambos projetos são independentes mas gravam/leem da mesma tabela BigQuery.</context>
  <decision>Documentar a divergência como tech debt. Qualquer alteração no WorkStatus deve considerar ambos os projetos e a compatibilidade com dados existentes no BigQuery.</decision>
  <outcome>Risco identificado — mudanças no enum de um projeto podem quebrar o outro silenciosamente.</outcome>
</lesson>

<lesson date="2026-02-10" category="padrões">
  <context>Análise revelou que o namespace do projeto Infra.Data.Queries da API tem typo persistente: `Hapvvida` (duplo 'v') no RootNamespace do csproj, causando inconsistência em imports.</context>
  <decision>Manter awareness do typo. Ao gerar código referenciando Infra.Data.Queries, usar o namespace correto com `Hapvvida` (duplo v) para compilar, mas sinalizar o issue.</decision>
  <outcome>Evita erros de compilação por namespace incorreto ao gerar código.</outcome>
</lesson>

<lesson date="2026-02-10" category="padrões">
  <context>API UnitTests usa AMBOS Moq e NSubstitute no mesmo projeto. Alguns test classes usam Moq, outros NSubstitute.</context>
  <decision>Ao criar novos testes para a API, verificar qual framework o test class existente já usa e seguir o mesmo. Para novos test classes, preferir NSubstitute (mais recente nos testes).</decision>
  <outcome>Consistência dentro de cada test class, minimizando confusão.</outcome>
</lesson>

<lesson date="2026-02-10" category="arquitetura">
  <context>Consumer possui BaseConsumerHandler (herda de Hapvida.Core) que não é utilizado — TransactionConsumerHandler herda diretamente de BackgroundService.</context>
  <decision>BaseConsumerHandler é dead code / legado do padrão Service Bus do Hapvida.Core. O Consumer atual usa Pub/Sub diretamente via SubscriberClient.</decision>
  <outcome>Não usar BaseConsumerHandler como referência para novos consumers neste projeto.</outcome>
</lesson>

<lesson date="2026-02-10" category="arquitetura">
  <context>API Domain.csproj exclui pasta Commands da compilação (`Compile Remove="Commands\**"`), e Infra.Data.Queries.csproj referencia pacotes não utilizados visivelmente (NAudio, Xabe.FFmpeg, Refit, System.Management).</context>
  <decision>Código em Domain/Commands pode ser vestígio de refatoração. Packages potencialmente não utilizados são tech debt mas não devem ser removidos sem validação completa.</decision>
  <outcome>Awareness para não referenciar esses artefatos como padrões a seguir.</outcome>
</lesson>

<lesson date="2026-02-10" category="tooling">
  <context>Ambos projetos usam System.Text.Json como serialização primária, mas Consumer usa Newtonsoft.Json pontualmente no BigQueryService.InsertCompletedTranscriptionAsync (JsonConvert.SerializeObject).</context>
  <decision>Para novas serializações, usar System.Text.Json (JsonSerializer) como padrão. Newtonsoft apenas se houver necessidade específica documentada.</decision>
  <outcome>Consistência nas dependências de serialização.</outcome>
</lesson>

<lesson date="2026-02-10" category="arquitetura">
  <context>Consumer K8s deployment não possui health checks (liveness/readiness probes), enquanto API possui ambos (/health e /ready).</context>
  <decision>Documentado como tech debt. Worker Services .NET podem implementar health checks via IHealthCheck + endpoints HTTP em background.</decision>
  <outcome>Risco de pods zombie em produção sem probes.</outcome>
</lesson>
